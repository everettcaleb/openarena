Index: code/sdl/sdl_glimp.c
===================================================================
--- code/sdl/sdl_glimp.c	(revision 1216)
+++ code/sdl/sdl_glimp.c	(working copy)
@@ -85,6 +85,37 @@
 void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 void (APIENTRYP qglUnlockArraysEXT) (void);
 
+//added framebuffer extensions
+void (APIENTRYP qglGenFramebuffers )(GLsizei, GLuint *);
+void (APIENTRYP qglBindFramebuffer )(GLenum, GLuint);
+void (APIENTRYP qglGenRenderbuffers )(GLsizei, GLuint *);
+void (APIENTRYP qglBindRenderbuffer )(GLenum, GLuint);
+void (APIENTRYP qglRenderbufferStorage )(GLenum, GLenum, GLsizei, GLsizei);
+void (APIENTRYP qglFramebufferRenderbuffer )(GLenum, GLenum, GLenum, GLuint);
+void (APIENTRYP qglFramebufferTexture2D )(GLenum, GLenum, GLenum, GLuint, GLint);
+GLenum (APIENTRYP qglCheckFramebufferStatus )(GLenum);
+void (APIENTRYP qglDeleteFramebuffers )(GLsizei, const GLuint *);
+void (APIENTRYP qglDeleteRenderbuffers )(GLsizei, const GLuint *);
+
+//added fragment/vertex program extensions
+void (APIENTRYP qglAttachShader) (GLuint, GLuint);
+void (APIENTRYP qglBindAttribLocation) (GLuint, GLuint, const GLchar *);
+void (APIENTRYP qglCompileShader) (GLuint);
+GLuint (APIENTRYP qglCreateProgram) (void);
+GLuint (APIENTRYP qglCreateShader) (GLenum);
+void (APIENTRYP qglDeleteProgram) (GLuint);
+void (APIENTRYP qglDeleteShader) (GLuint);
+void (APIENTRYP qglShaderSource) (GLuint, GLsizei, const GLchar* *, const GLint *);
+void (APIENTRYP qglLinkProgram) (GLuint);
+void (APIENTRYP qglUseProgram) (GLuint);	
+GLint (APIENTRYP qglGetUniformLocation) (GLuint, const GLchar *);
+void (APIENTRYP qglUniform1f) (GLint, GLfloat);
+void (APIENTRYP qglUniform2f) (GLint, GLfloat, GLfloat);
+void (APIENTRYP qglUniform1i) (GLint, GLint);
+void (APIENTRYP qglGetProgramiv) (GLuint, GLenum, GLint *);
+void (APIENTRYP qglGetProgramInfoLog) (GLuint, GLsizei, GLsizei *, GLchar *);
+void (APIENTRYP qglGetShaderiv) (GLuint, GLenum, GLint *);
+void (APIENTRYP qglGetShaderInfoLog) (GLuint, GLsizei, GLsizei *, GLchar *);
 /*
 ===============
 GLimp_Shutdown
@@ -96,7 +127,7 @@
 
 	SDL_QuitSubSystem( SDL_INIT_VIDEO );
 	screen = NULL;
-
+	
 	Com_Memset( &glConfig, 0, sizeof( glConfig ) );
 	Com_Memset( &glState, 0, sizeof( glState ) );
 }
@@ -340,6 +371,7 @@
 */
 static void GLimp_InitExtensions( void )
 {
+	printf("InitExtensions\n");
 	if ( !r_allowExtensions->integer )
 	{
 		ri.Printf( PRINT_ALL, "* IGNORING OPENGL EXTENSIONS *\n" );
@@ -475,6 +507,96 @@
 	{
 		ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not found\n" );
 	}
+
+	qglGenFramebuffers = NULL;
+	qglBindFramebuffer = NULL;
+	qglGenRenderbuffers = NULL;
+	qglBindRenderbuffer = NULL;
+	qglRenderbufferStorage = NULL;
+	qglFramebufferRenderbuffer = NULL;
+	qglFramebufferTexture2D = NULL;
+	qglCheckFramebufferStatus = NULL;
+	qglDeleteFramebuffers = NULL;
+	qglDeleteRenderbuffers =NULL;
+			//added fragment/vertex program extensions
+	qglAttachShader = NULL;
+	qglBindAttribLocation = NULL;
+	qglCompileShader = NULL;
+	qglCreateProgram = NULL;
+	qglCreateShader = NULL;
+	qglDeleteProgram = NULL;
+	qglDeleteShader = NULL;
+	qglShaderSource = NULL;
+	qglLinkProgram = NULL;
+	qglUseProgram =NULL;
+	qglGetUniformLocation = NULL;
+	qglUniform1f = NULL;
+	qglUniform2f = NULL;
+	qglUniform1i = NULL;
+	qglGetProgramiv = NULL;
+	qglGetProgramInfoLog = NULL;
+	qglGetShaderiv =NULL;
+	qglGetShaderInfoLog = NULL;
+			
+	framebufferSupported = qfalse;
+	glslSupported = qfalse;
+	if ( strstr( glConfig.extensions_string, "GL_EXT_framebuffer_object" ) &&
+		 strstr( glConfig.extensions_string, "GL_ARB_texture_non_power_of_two" ))
+	{
+		ri.Printf( PRINT_ALL, "...using GL_EXT_framebuffer_object\n" );
+		framebufferSupported = qtrue;
+		qglGenFramebuffers = ( void (APIENTRY *  )(GLsizei, GLuint *) ) SDL_GL_GetProcAddress( "glGenFramebuffersEXT");
+		qglBindFramebuffer = ( void (APIENTRY *  )(GLenum, GLuint) ) SDL_GL_GetProcAddress( "glBindFramebufferEXT");
+		qglGenRenderbuffers = ( void (APIENTRY *  )(GLsizei, GLuint *) ) SDL_GL_GetProcAddress( "glGenRenderbuffersEXT");
+		qglBindRenderbuffer = ( void (APIENTRY *  )(GLenum, GLuint) ) SDL_GL_GetProcAddress( "glBindRenderbufferEXT");
+		qglRenderbufferStorage = ( void (APIENTRY *  )(GLenum, GLenum, GLsizei, GLsizei) ) SDL_GL_GetProcAddress( "glRenderbufferStorageEXT");
+		qglFramebufferRenderbuffer = ( void (APIENTRY *  )(GLenum, GLenum, GLenum, GLuint) ) SDL_GL_GetProcAddress( "glFramebufferRenderbufferEXT");
+		qglFramebufferTexture2D = ( void (APIENTRY *  )(GLenum, GLenum, GLenum, GLuint, GLint) ) SDL_GL_GetProcAddress( "glFramebufferTexture2DEXT");
+		qglCheckFramebufferStatus = ( GLenum (APIENTRY *)(GLenum) ) SDL_GL_GetProcAddress( "glCheckFramebufferStatusEXT");
+		qglDeleteFramebuffers = ( void (APIENTRY * )(GLsizei, const GLuint *) ) SDL_GL_GetProcAddress( "glDeleteFramebuffersEXT");
+		qglDeleteRenderbuffers = ( void (APIENTRY * )(GLsizei, const GLuint *) ) SDL_GL_GetProcAddress( "glDeleteRenderbuffersEXT");
+	
+		if ( !strstr( glConfig.extensions_string, "GL_ARB_depth_texture" ) )  {
+			ri.Printf( PRINT_WARNING, "WARNING: GL_ARB_depth_texture is missing\n");
+		}
+		if (	!strstr( glConfig.extensions_string, "GL_EXT_packed_depth_stencil" )  || 
+				!strstr( glConfig.extensions_string, "GL_NV_packed_depth_stencil" ) ) {
+			ri.Printf( PRINT_WARNING, "WARNING: packed_depth_stencil is missing\n");
+		}
+	
+	}
+	//added fragment/vertex program extensions
+	if ( strstr( glConfig.extensions_string, "GL_ARB_fragment_shader" ) && 
+		 strstr( glConfig.extensions_string, "GL_ARB_vertex_program" ) &&
+		 strstr( glConfig.extensions_string, "GL_ARB_vertex_shader" ) &&
+		 strstr( glConfig.extensions_string, "GL_ARB_fragment_program" ) &&
+		 strstr( glConfig.extensions_string, "GL_ARB_shading_language_100" ))
+	{
+		ri.Printf( PRINT_ALL, "...using GL_ARB_fragment_program\n" );
+		ri.Printf( PRINT_ALL, "...using GL_ARB_vertex_program\n" );
+		ri.Printf( PRINT_ALL, "...using GL_ARB_shading_language_100\n" );
+		glslSupported = qtrue;
+		qglAttachShader = ( void (APIENTRY * ) (GLuint, GLuint) ) SDL_GL_GetProcAddress( "glAttachShader");
+		qglBindAttribLocation = ( void (APIENTRY * ) (GLuint, GLuint, const GLchar *) ) SDL_GL_GetProcAddress( "glBindAttribLocation");
+		qglCompileShader = ( void (APIENTRY * ) (GLuint) ) SDL_GL_GetProcAddress( "glCompileShader");
+		qglCreateProgram = ( GLuint (APIENTRY * ) (void) ) SDL_GL_GetProcAddress( "glCreateProgram");
+		qglCreateShader = ( GLuint (APIENTRY * ) (GLenum) ) SDL_GL_GetProcAddress( "glCreateShader");
+		qglDeleteProgram = ( void (APIENTRY * ) (GLuint) ) SDL_GL_GetProcAddress( "glDeleteProgram");
+		qglDeleteShader = ( void (APIENTRY * ) (GLuint) ) SDL_GL_GetProcAddress( "glDeleteShader");
+		qglShaderSource = ( void (APIENTRY * ) (GLuint, GLsizei, const GLchar* *, const GLint *) ) SDL_GL_GetProcAddress( "glShaderSource");
+		qglLinkProgram = ( void (APIENTRY * ) (GLuint) ) SDL_GL_GetProcAddress( "glLinkProgram");
+		qglUseProgram = ( void (APIENTRY * ) (GLuint) ) SDL_GL_GetProcAddress( "glUseProgram");
+		qglGetUniformLocation = ( GLint (APIENTRY * ) (GLuint, const GLchar *) ) SDL_GL_GetProcAddress( "glGetUniformLocation");
+		qglUniform1f = ( void (APIENTRY * ) (GLint, GLfloat) ) SDL_GL_GetProcAddress( "glUniform1f");
+		qglUniform2f = ( void (APIENTRY * ) (GLint, GLfloat, GLfloat) ) SDL_GL_GetProcAddress( "glUniform2f");
+		qglUniform1i = ( void (APIENTRY * ) (GLint, GLint) ) SDL_GL_GetProcAddress( "glUniform1i");
+		qglGetProgramiv = ( void (APIENTRY * ) (GLuint, GLenum, GLint *) ) SDL_GL_GetProcAddress( "glGetProgramiv");
+		qglGetProgramInfoLog = ( void (APIENTRY * ) (GLuint, GLsizei, GLsizei *, GLchar *) ) SDL_GL_GetProcAddress( "glGetProgramInfoLog");
+		qglGetShaderiv = ( void (APIENTRY * ) (GLuint, GLenum, GLint *) ) SDL_GL_GetProcAddress( "glGetShaderiv");
+		qglGetShaderInfoLog = ( void (APIENTRY * ) (GLuint, GLsizei, GLsizei *, GLchar *) ) SDL_GL_GetProcAddress( "glGetShaderInfoLog");
+			
+	}
+	
 }
 
 #define R_MODE_FALLBACK 3 // 640 * 480
Index: code/renderer/tr_local.h
===================================================================
--- code/renderer/tr_local.h	(revision 1216)
+++ code/renderer/tr_local.h	(working copy)
@@ -975,6 +975,10 @@
 // the glconfig_t struct.
 extern qboolean		textureFilterAnisotropic;
 extern int		maxAnisotropy;
+
+//same as above
+extern qboolean	framebufferSupported;
+extern qboolean	glslSupported;
                 
 
 //
@@ -1103,6 +1107,18 @@
 
 extern	cvar_t	*r_GLlibCoolDownMsec;
 
+extern cvar_t *r_framebuffer;
+extern cvar_t *r_framebuffer_bloom;
+extern cvar_t *r_framebuffer_blur_size;
+extern cvar_t *r_framebuffer_blur_ammount;
+extern cvar_t *r_framebuffer_blur_samples;
+
+extern cvar_t *r_framebuffer_bloom_sharpness;
+extern cvar_t *r_framebuffer_bloom_brightness;
+
+extern cvar_t *r_framebuffer_rotoscope;
+extern cvar_t *r_framebuffer_rotoscope_zedge;
+
 //====================================================================
 
 float R_NoiseGet4f( float x, float y, float z, float t );
@@ -1246,6 +1262,19 @@
 /*
 ====================================================================
 
+FRAMEBUFFER RENDER PATH SPECIFIC FUNCTIONS AND STATE VARIABLES
+
+====================================================================
+*/
+void 		R_FrameBufferBind( void );
+void 		R_FrameBufferUnBind( void );
+void		R_FrameBuffer_Init( void );
+void		R_FrameBuffer_EndFrame( void );
+void		R_FrameBuffer_Shutdown( void );
+
+/*
+====================================================================
+
 IMPLEMENTATION SPECIFIC FUNCTIONS
 
 ====================================================================
Index: code/renderer/tr_init.c
===================================================================
--- code/renderer/tr_init.c	(revision 1216)
+++ code/renderer/tr_init.c	(working copy)
@@ -152,6 +152,18 @@
 cvar_t	*r_maxpolyverts;
 int		max_polyverts;
 
+cvar_t *r_framebuffer;
+cvar_t *r_framebuffer_bloom;
+cvar_t *r_framebuffer_blur_size;
+cvar_t *r_framebuffer_blur_ammount;
+cvar_t *r_framebuffer_blur_samples;
+
+cvar_t *r_framebuffer_bloom_sharpness;
+cvar_t *r_framebuffer_bloom_brightness;
+
+cvar_t *r_framebuffer_rotoscope;
+cvar_t *r_framebuffer_rotoscope_zedge;
+
 static void AssertCvarRange( cvar_t *cv, float minVal, float maxVal, qboolean shouldBeIntegral )
 {
 	if ( shouldBeIntegral )
@@ -1021,6 +1033,17 @@
 	r_maxpolys = ri.Cvar_Get( "r_maxpolys", va("%d", MAX_POLYS), 0);
 	r_maxpolyverts = ri.Cvar_Get( "r_maxpolyverts", va("%d", MAX_POLYVERTS), 0);
 
+	// Framebuffer variables
+	r_framebuffer = ri.Cvar_Get( "r_framebuffer", "0", CVAR_ARCHIVE | CVAR_LATCH);	
+	r_framebuffer_bloom = ri.Cvar_Get( "r_framebuffer_bloom", "0", CVAR_ARCHIVE | CVAR_LATCH);
+	r_framebuffer_blur_size = ri.Cvar_Get( "r_framebuffer_blur_size", "256", CVAR_ARCHIVE | CVAR_LATCH);
+	r_framebuffer_blur_ammount = ri.Cvar_Get( "r_framebuffer_blur_amount", "7", CVAR_ARCHIVE);
+	r_framebuffer_blur_samples = ri.Cvar_Get( "r_framebuffer_blur_samples", "9", CVAR_ARCHIVE | CVAR_LATCH);
+	r_framebuffer_bloom_sharpness = ri.Cvar_Get( "r_framebuffer_bloom_sharpness", "0.75", CVAR_ARCHIVE );
+	r_framebuffer_bloom_brightness = ri.Cvar_Get( "r_framebuffer_bloom_brightness", "0.85", CVAR_ARCHIVE );
+	r_framebuffer_rotoscope = ri.Cvar_Get( "r_framebuffer_rotoscope", "0", CVAR_ARCHIVE | CVAR_LATCH);
+	r_framebuffer_rotoscope_zedge = ri.Cvar_Get( "r_framebuffer_rotoscope_zedge", "0", CVAR_ARCHIVE | CVAR_LATCH);
+
 	// make sure all the commands added here are also
 	// removed in R_Shutdown
 	ri.Cmd_AddCommand( "imagelist", R_ImageList_f );
@@ -1119,6 +1142,8 @@
 
 	InitOpenGL();
 
+	R_FrameBuffer_Init();
+	
 	R_InitImages();
 
 	R_InitShaders();
@@ -1163,6 +1188,7 @@
 		R_DeleteTextures();
 	}
 
+	R_FrameBuffer_Shutdown();
 	R_DoneFreeType();
 
 	// shut down platform specific OpenGL stuff
Index: code/renderer/tr_glslprogs.c
===================================================================
--- code/renderer/tr_glslprogs.c	(revision 0)
+++ code/renderer/tr_glslprogs.c	(revision 0)
@@ -0,0 +1,270 @@
+/*
+ *      tr_glslprogs.c
+ *      
+ *      Copyright 2007 Gord Allott <gordallott@gmail.com>
+ *      
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *      
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *      
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ *      MA 02110-1301, USA.
+ */
+
+#include "tr_glslprogs.h"
+//for all the glsl source its best if we keep them in the mainline code unless
+//someone (not me!) wants to impliment them into the q3 mainline pak code
+//and of course provide a 'standard library' for paks that don't have the glsl
+//sources in them. this would allow mod authors to code their own effects but 
+//meh, they might as well just hack them into the source and send the changes
+//upstream.
+
+//when implimenting glsl code try and stick to the carmark q3 coding style ie, 
+//variables go myVariable and stuff. also end lines with \n\ instead of \ as it 
+//makes debugging glsl code 15,823x easier. (looks nasty either way...)
+
+
+//this vertex shader is basically complete, we shouldn't really need anything 
+//else(?). it just maps the vertex position to a screen position. 
+const char *glslBase_vert = "\n\
+void main() {\n\
+  gl_TexCoord[0] = gl_MultiTexCoord0;\n\
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n\
+}\
+";
+
+const char *glslGauss9 = "\n\
+#define NK9_0 0.17857142857142855\n\
+#define NK9_1 0.1607142857142857\n\
+#define NK9_2 0.14285714285714285\n\
+#define NK9_3 0.071428571428571425\n\
+#define NK9_4 0.035714285714285712\n\
+\
+vec4 GaussPass(sampler2D src, vec2 coord, vec2 blrsize) {\n\
+  //blrsize is the size (in texture coordinates) of the blur kernel\n\
+\n\
+  vec4 accum;\n\
+  vec2 step, pos;\n\
+  step = blrsize / 9.0;\n\
+  pos = coord - (step * 4.0);\n\
+\n\
+  accum  = texture2D(src, pos) * NK9_4; pos += step;\n\
+  accum += texture2D(src, pos) * NK9_3; pos += step;\n\
+  accum += texture2D(src, pos) * NK9_2; pos += step;\n\
+  accum += texture2D(src, pos) * NK9_1; pos += step;\n\
+  accum += texture2D(src, pos) * NK9_0; pos += step;\n\
+  accum += texture2D(src, pos) * NK9_1; pos += step;\n\
+  accum += texture2D(src, pos) * NK9_2; pos += step;\n\
+  accum += texture2D(src, pos) * NK9_3; pos += step;\n\
+  accum += texture2D(src, pos) * NK9_4; pos += step;\n\
+\n\
+  return accum;\n\
+\n\
+}\n\
+";
+
+
+const char *glslGauss7 = "\n\
+#define NK7_0 0.19230769230769229\n\
+#define NK7_1 0.18269230769230768\n\
+#define NK7_2 0.15384615384615385\n\
+#define NK7_3 0.067307692307692304\n\
+\n\
+vec4 GaussPass(sampler2D src, vec2 coord, vec2 blrsize) {\n\
+  //blrsize is the size (in texture coordinates) of the blur kernel\n\
+\n\
+  vec4 accum;\n\
+  vec2 step, pos;\n\
+  step = blrsize / 7.0;\n\
+  pos = coord - (step * 3.0);\n\
+\n\
+  accum  = texture2D(src, pos) * NK7_3; pos += step;\n\
+  accum += texture2D(src, pos) * NK7_2; pos += step;\n\
+  accum += texture2D(src, pos) * NK7_1; pos += step;\n\
+  accum += texture2D(src, pos) * NK7_0; pos += step;\n\
+  accum += texture2D(src, pos) * NK7_1; pos += step;\n\
+  accum += texture2D(src, pos) * NK7_2; pos += step;\n\
+  accum += texture2D(src, pos) * NK7_3; pos += step;\n\
+  \n\
+  return accum;\n\
+\n\
+}\n\
+";
+
+const char *glslGauss5 = "\n\
+#define NK5_0 0.33333333\n\
+#define NK5_1 0.26666666\n\
+#define NK5_2 0.06666666\n\
+\n\
+vec4 GaussPass(sampler2D src, vec2 coord, vec2 blrsize) {\n\
+  //blrsize is the size (in texture coordinates) of the blur kernel\n\
+  \n\
+  vec4 accum;\n\
+  vec2 step, pos;\n\
+  step = blrsize / 5.0;\n\
+  pos = coord - (step * 2.0);\n\
+  \n\
+  accum  = texture2D(src, pos) * NK5_2; pos += step;\n\
+  accum += texture2D(src, pos) * NK5_1; pos += step;\n\
+  accum += texture2D(src, pos) * NK5_0; pos += step;\n\
+  accum += texture2D(src, pos) * NK5_1; pos += step;\n\
+  accum += texture2D(src, pos) * NK5_2; pos += step;\n\
+  \n\
+  return accum;\n\
+  \n\
+}\n\
+";
+
+const char *glslBlurMain = "\n\
+uniform sampler2D srcSampler;\n\
+uniform vec2 blurSize;\n\
+void main()\n\
+{\n\
+  gl_FragColor = GaussPass(srcSampler, gl_TexCoord[0].xy, blurSize);\n\
+}\n\
+";
+
+const char *glslSigScreen = "\n\
+uniform sampler2D srcSampler;\n\
+uniform sampler2D blurSampler;\n\
+//#define sharpness 0.75 \n\
+uniform float     sharpness;\n\
+//#define brightness 0.85\n\
+uniform float     brightness;\n\
+#define SIGMOIDAL_BASE          2.0\n\
+#define SIGMOIDAL_RANGE         20.0\n\
+\n\
+void main()\n\
+{\n\
+	\n\
+  vec4 blurcolor 	= texture2D( blurSampler, gl_TexCoord[0].xy);\n\
+  vec4 basecolor 	= texture2D( srcSampler, gl_TexCoord[0].xy);\n\
+  \n\
+  //vec4 val = 1.0 / (1.0 + exp (-(SIGMOIDAL_BASE + (sharpness * SIGMOIDAL_RANGE)) * (blurcolor - 0.5)));\n\
+  vec4 val;\n\
+  val = -(SIGMOIDAL_BASE + (sharpness * SIGMOIDAL_RANGE)) * (blurcolor - 0.5);\n\
+  val = 1.0 + pow(vec4(2.718281828459045), val);\n\
+  val = 1.0 / val;\n\
+  val = val * brightness;\n\
+  \n\
+  gl_FragColor = 1.0 - ((1.0 - basecolor) * (1.0 - val));\n\
+}\n\
+";
+
+const char *glslSobel = "\n\
+float sobel(sampler2D tex, vec2 basecoord, vec2 texel_size) {\n\
+  /* computes a sobel value from the surrounding pixels */\n\
+  vec4 hori, vert;\n\
+  //vec2 basecoord = coord;\n\
+  float stepw, steph;\n\
+  stepw = texel_size.x;\n\
+  steph = texel_size.y;\n\
+  \n\
+  vert  = texture2D(tex, basecoord + vec2(-stepw, -steph)) * -1.0;\n\
+  vert += texture2D(tex, basecoord + vec2(-stepw,  0.0  )) * -2.0;\n\
+  vert += texture2D(tex, basecoord + vec2(-stepw, +steph)) * -1.0;\n\
+  \n\
+  vert += texture2D(tex, basecoord + vec2( stepw, -steph)) * 1.0;\n\
+  vert += texture2D(tex, basecoord + vec2( stepw,  0.0  )) * 2.0;\n\
+  vert += texture2D(tex, basecoord + vec2( stepw, +steph)) * 1.0;\n\
+  \n\
+  hori  = texture2D(tex, basecoord + vec2(-stepw, -steph)) * -1.0;\n\
+  hori += texture2D(tex, basecoord + vec2( 0.0  , -steph)) * -2.0;\n\
+  hori += texture2D(tex, basecoord + vec2(+stepw, -steph)) * -1.0;\n\
+\n\
+  hori += texture2D(tex, basecoord + vec2(-stepw,  steph)) * 1.0;\n\
+  hori += texture2D(tex, basecoord + vec2( 0.0  ,  steph)) * 2.0;\n\
+  hori += texture2D(tex, basecoord + vec2(+stepw,  steph)) * 1.0;\n\
+\n\
+  /* could use dist() but this is more compatible */\n\
+  return sqrt(float((vert * vert) + (hori * hori)));\n\
+  \n\
+}\n\
+";
+
+const char *glslToonColour = "\n\
+vec4 ToonColour(vec4 incolour) {\n\
+\n\
+  vec3 huetemp;\n\
+  huetemp.x = 0.0;\n\
+  huetemp.y = 0.0;\n\
+  huetemp.z = 0.0;\n\
+\n\
+  huetemp.x = incolour.x + incolour.y + incolour.z;\n\
+  huetemp.y = 1.0 / huetemp.x;\n\
+  \n\
+  /* multiply the pixel colourby 1 / sumrgb */\n\
+  incolour = incolour * huetemp.y;\n\
+  /* get the  tones */\n\
+  \n\
+  if (huetemp.x > 0.2) {\n\
+    huetemp.z = 0.4;\n\
+   \n\
+  } else {\n\
+    huetemp.z = 0.0;\n\
+  }\n\
+  \n\
+  if (huetemp.x > 0.4) {\n\
+    huetemp.y = 1.0;\n\
+  } else {\n\
+    huetemp.y = 0.0;\n\
+  }\n\
+  \n\
+  if (huetemp.x > 1.0) {\n\
+    huetemp.x = 1.5;\n\
+  } else {\n\
+    huetemp.x = 0.0;\n\
+  }\n\
+\n\
+  \n\
+  /* sum the huetones */\n\
+  \n\
+  huetemp.x = huetemp.x + huetemp.y + huetemp.z;\n\
+  \n\
+  /* multiply the pixel colour with the resulting intensity */\n\
+  \n\
+  incolour = incolour * huetemp.x;\n\
+\n\
+  return vec4(incolour);\n\
+}\n\
+";
+
+const char *glslRotoscope = "\n\
+uniform vec2 texelSize;\n\
+uniform sampler2D srcSampler;\n\
+void main()\n\
+{\n\
+\n\
+  float fragsobel = sobel(srcSampler, gl_TexCoord[0].xy, texelSize);\n\
+  vec4 final_color = ToonColour(texture2D(srcSampler, gl_TexCoord[0].xy));\n\
+\n\
+  fragsobel = 1.0 - clamp(fragsobel - 0.2, 0.0, 1.0);\n\
+  gl_FragColor = final_color * fragsobel;\n\
+\n\
+}\n\
+";
+
+const char *glslRotoscopeZ = "\n\
+uniform vec2 texelSize;\n\
+uniform sampler2D srcSampler;\n\
+uniform sampler2D depthSampler;\n\
+\n\
+void main()\n\
+{\n\
+\n\
+  float fragsobel = sobel(depthSampler, gl_TexCoord[0].xy, texelSize) * 32.0;\n\
+  vec4 final_color = ToonColour(texture2D(srcSampler, gl_TexCoord[0].xy));\n\
+\n\
+  fragsobel = 1.0 - clamp(fragsobel - 0.0, 0.0, 1.0);\n\
+  gl_FragColor = final_color * fragsobel;\n\
+\n\
+}\n\
+";
Index: code/renderer/tr_glslprogs.h
===================================================================
--- code/renderer/tr_glslprogs.h	(revision 0)
+++ code/renderer/tr_glslprogs.h	(revision 0)
@@ -0,0 +1,42 @@
+/*
+ *      tr_glslprogs.h
+ *      
+ *      Copyright 2007 Gord Allott <gordallott@gmail.com>
+ *      
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *      
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *      
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ *      MA 02110-1301, USA.
+ */
+
+#ifndef TR_GLSLPROGS_H
+#define TR_GLSLPROGS_H
+
+//basicly the idea here is to just store fragments of glsl source files so that
+//we can reuse the code in different programs. the problem with glsl is that 
+//there is no defined way of 'including' code from other places. so we will 
+//just have to live with this for now
+
+
+extern const char *glslBase_vert;
+extern const char *glslGauss9; 
+extern const char *glslGauss7;
+extern const char *glslGauss5;
+extern const char *glslBlurMain;
+extern const char *glslSigScreen;
+extern const char *glslToonColour;
+extern const char *glslSobel;
+extern const char *glslRotoscope;
+extern const char *glslRotoscopeZ;
+
+#endif //TR_GLSLPROGS_H
Index: code/renderer/qgl.h
===================================================================
--- code/renderer/qgl.h	(revision 1216)
+++ code/renderer/qgl.h	(working copy)
@@ -39,7 +39,37 @@
 extern void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 extern void (APIENTRYP qglUnlockArraysEXT) (void);
 
+//added framebuffer extensions
+extern void (APIENTRYP qglGenFramebuffers )(GLsizei, GLuint *);
+extern void (APIENTRYP qglBindFramebuffer )(GLenum, GLuint);
+extern void (APIENTRYP qglGenRenderbuffers )(GLsizei, GLuint *);
+extern void (APIENTRYP qglBindRenderbuffer )(GLenum, GLuint);
+extern void (APIENTRYP qglRenderbufferStorage )(GLenum, GLenum, GLsizei, GLsizei);
+extern void (APIENTRYP qglFramebufferRenderbuffer )(GLenum, GLenum, GLenum, GLuint);
+extern void (APIENTRYP qglFramebufferTexture2D )(GLenum, GLenum, GLenum, GLuint, GLint);
+extern GLenum (APIENTRYP qglCheckFramebufferStatus )(GLenum);
+extern void (APIENTRYP qglDeleteFramebuffers )(GLsizei, const GLuint *);
+extern void (APIENTRYP qglDeleteRenderbuffers )(GLsizei, const GLuint *);
 
+//added fragment/vertex program extensions
+extern  void (APIENTRYP qglAttachShader) (GLuint, GLuint);
+extern  void (APIENTRYP qglBindAttribLocation) (GLuint, GLuint, const GLchar *);
+extern  void (APIENTRYP qglCompileShader) (GLuint);
+extern GLuint (APIENTRYP qglCreateProgram) (void);
+extern GLuint (APIENTRYP qglCreateShader) (GLenum);
+extern void (APIENTRYP qglDeleteProgram) (GLuint);
+extern void (APIENTRYP qglDeleteShader) (GLuint);
+extern void (APIENTRYP qglShaderSource) (GLuint, GLsizei, const GLchar* *, const GLint *);
+extern void (APIENTRYP qglLinkProgram) (GLuint);
+extern void (APIENTRYP qglUseProgram) (GLuint);	
+extern GLint (APIENTRYP qglGetUniformLocation) (GLuint, const GLchar *);
+extern void (APIENTRYP qglUniform1f) (GLint, GLfloat);
+extern void (APIENTRYP qglUniform2f) (GLint, GLfloat, GLfloat);
+extern void (APIENTRYP qglUniform1i) (GLint, GLint);
+extern void (APIENTRYP qglGetProgramiv) (GLuint, GLenum, GLint *);
+extern void (APIENTRYP qglGetProgramInfoLog) (GLuint, GLsizei, GLsizei *, GLchar *);
+extern void (APIENTRYP qglGetShaderiv) (GLuint, GLenum, GLint *);
+extern void (APIENTRYP qglGetShaderInfoLog) (GLuint, GLsizei, GLsizei *, GLchar *);
 //===========================================================================
 
 #define qglAccum glAccum
@@ -378,3 +408,4 @@
 #define qglViewport glViewport
 
 #endif
+
Index: code/renderer/tr_framebuffer.c
===================================================================
--- code/renderer/tr_framebuffer.c	(revision 0)
+++ code/renderer/tr_framebuffer.c	(revision 0)
@@ -0,0 +1,1013 @@
+/*
+ *      tr_framebuffer.c
+ *      
+ *      Copyright 2007 Gord Allott <gordallott@gmail.com>
+ *      
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *      
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *      
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ *      MA 02110-1301, USA.
+ */
+// tr_framebuffer.c: framebuffer object rendering path code
+// Okay i am going to try and document what I doing here, appologies to anyone 
+// that already understands this. basically the idea is that normally everything
+// opengl renders will be rendered into client memory, that is the space the 
+// graphics card reserves for anything thats going to be sent to the monitor.
+// Using this method we instead redirect all the rendering to a seperate bit of 
+// memory called a frame buffer. 
+// we can then bind this framebuffer to a texture and render that texture to the
+// client memory again so that the image will be sent to the monitor. this 
+// redirection allows for some neat effects to be applied.
+
+// Some ideas for what to use this path for:
+//		- Bloom	-done
+//		- Rotoscope cartoon effects (edge detect + colour mapping)
+//		- Fake anti-aliasing. (edge detect and blur positive matches)
+//		- Motion blur
+//			- generate a speed vector based on how the camera has moved since 
+//			  the last frame and use that to compute per pixel blur vectors 
+//		- These would require mods to use some sort of framebuffer qvm api
+//			- special effects for certain powerups 
+//			- Image Blur when the player is hit
+//			- Depth of field blur
+
+
+#include "tr_local.h"
+#include "tr_glslprogs.h"
+#include "qgl.h"
+
+#ifndef GL_DEPTH_STENCIL_EXT
+#define GL_DEPTH_STENCIL_EXT GL_DEPTH_STENCIL_NV
+#endif
+
+#ifndef GL_UNSIGNED_INT_24_8_EXT
+#define GL_UNSIGNED_INT_24_8_EXT GL_UNSIGNED_INT_24_8_NV
+#endif
+
+qboolean	framebufferSupported;
+qboolean	glslSupported;
+qboolean	packedDepthStencilSupported;
+qboolean	depthTextureSupported;
+qboolean	seperateDepthStencilSupported;
+
+struct glslobj {
+	const char **vertex_glsl;
+	int vert_numSources;
+	const char **fragment_glsl;
+	int frag_numSources;
+	GLuint vertex;
+	GLuint fragment;
+	GLuint program;
+} glslobj;
+struct r_fbuffer {
+	GLuint 	fbo;
+	GLuint	numBuffers;
+	GLuint	*buffers;
+	GLuint	*front;					//front buffer
+	GLuint	*back;					//back buffer
+	GLuint	*depth;					//depth buffer
+	GLuint	*stencil;				//stencil buffer
+	int		modeFlags;				//the modeflags
+	int		renderbuff;				//either FB_FRONT or FB_BACK
+} r_fbuffer;
+
+qboolean needBlur = 0;				 //is set if effects need a blur
+
+struct r_fbuffer screenBuffer;
+struct r_fbuffer gaussblurBuffer;
+
+//two functions to bind and unbind the main framebuffer, generally just to be
+//called externaly
+void R_FrameBufferBind(void) {
+	if (!framebufferSupported) {
+		return;
+	}
+	if (r_framebuffer->integer != 1) {
+		return;
+	}
+
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, screenBuffer.fbo);
+}
+
+void R_FrameBufferUnBind(void) {
+	if (!framebufferSupported) {
+		return;
+	}
+	if (r_framebuffer->integer != 1) {
+		return;
+	}
+
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+}
+void R_SetGL2DSize (int width, int height) {
+
+	// set 2D virtual screen size
+	qglViewport( 0, 0, width, height );
+	qglScissor( 0, 0, width, height );
+	qglMatrixMode(GL_PROJECTION);
+    qglLoadIdentity ();
+	qglOrtho (0, width, height, 0, 0, 1);
+	qglMatrixMode(GL_MODELVIEW);
+    qglLoadIdentity ();
+
+	GL_State( GLS_DEPTHTEST_DISABLE );
+	qglDisable( GL_BLEND );
+}
+
+void R_DrawQuadMT( GLuint tex1, GLuint tex2, int width, int height ) {
+	qglEnable(GL_TEXTURE_2D);
+	if ( glState.currenttextures[1] != tex2 ) {
+		GL_SelectTexture( 1 );
+		qglBindTexture(GL_TEXTURE_2D, tex2); 
+		glState.currenttextures[1] = tex2; 
+		}
+	if ( glState.currenttextures[0] != tex1 ) {
+		GL_SelectTexture( 0 );
+		qglBindTexture(GL_TEXTURE_2D, tex1);
+		glState.currenttextures[0] = tex1; 
+	}
+	  
+	qglBegin(GL_QUADS);
+	  qglMultiTexCoord2fARB(GL_TEXTURE0, 0.0, 1.0); qglMultiTexCoord2fARB(GL_TEXTURE1, 0.0, 1.0); qglVertex2f(0.0  , 0.0   );	
+	  qglMultiTexCoord2fARB(GL_TEXTURE0, 1.0, 1.0); qglMultiTexCoord2fARB(GL_TEXTURE1, 1.0, 1.0); qglVertex2f(width, 0.0   );	
+	  qglMultiTexCoord2fARB(GL_TEXTURE0, 1.0, 0.0); qglMultiTexCoord2fARB(GL_TEXTURE1, 1.0, 0.0); qglVertex2f(width, height);	
+	  qglMultiTexCoord2fARB(GL_TEXTURE0, 0.0, 0.0); qglMultiTexCoord2fARB(GL_TEXTURE1, 0.0, 0.0); qglVertex2f(0.0  , height);	
+	qglEnd();	;
+	
+	qglActiveTextureARB(GL_TEXTURE0);
+	//qglDisable(GL_TEXTURE_2D);
+}
+
+void R_DrawQuad( GLuint tex, int width, int height) {
+	qglEnable(GL_TEXTURE_2D);
+	if ( glState.currenttextures[0] != tex ) {
+		GL_SelectTexture( 0 );
+		qglBindTexture(GL_TEXTURE_2D, tex);
+		glState.currenttextures[0] = tex; 
+	};
+
+	qglBegin(GL_QUADS);
+	  qglTexCoord2f(0.0, 1.0); qglVertex2f(0.0  , 0.0   );	
+	  qglTexCoord2f(1.0, 1.0); qglVertex2f(width, 0.0   );	
+	  qglTexCoord2f(1.0, 0.0); qglVertex2f(width, height);	
+	  qglTexCoord2f(0.0, 0.0); qglVertex2f(0.0  , height);	
+	qglEnd();	
+}
+
+GLuint *R_CreateTexbuffer(	GLuint *store, int width, int height, 
+							qboolean smooth, GLenum bindSize, GLenum bindType) 
+{
+	//GLuint *store = malloc(sizeof(GLuint));
+	GLenum filter = GL_NEAREST;
+	
+	if (smooth) {
+		filter = GL_LINEAR;
+	}
+	
+	glGenTextures( 1, store );
+	glBindTexture(	GL_TEXTURE_2D, *store );
+	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filter );
+	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter );
+
+	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
+	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
+	glTexImage2D(	GL_TEXTURE_2D, 0, bindType, width, height, 0, 
+					bindType, bindSize, 0 );
+	return store;
+}
+
+GLuint *R_CreateRenderbuffer(	GLuint *store, int width, int height, 
+								GLenum bindType) 
+{
+	//GLuint *store = malloc(sizeof(GLuint));
+	
+	qglGenRenderbuffers( 1, store );
+	qglBindRenderbuffer( GL_RENDERBUFFER_EXT, *store );
+	qglRenderbufferStorage(	GL_RENDERBUFFER_EXT, bindType, width, height );
+	
+	return store;
+}
+
+//------------------------------
+// better framebuffer creation
+//------------------------------
+// for this we do a more opengl way of figuring out what level of framebuffer
+// objects are supported. we try each mode from 'best' to 'worst' until we 
+// get a mode that works.
+
+#define FB_ZBUFFER 		0x01
+#define FB_STENCIL 		0x02
+#define FB_PACKED 		0x04
+#define FB_ZTEXTURE 	0x08
+#define FB_BACKBUFFER	0x10
+#define FB_SEPERATEZS	0x20
+#define FB_SMOOTH		0x40
+
+#define FB_FRONT		0x01
+#define FB_BACK			0x02
+
+int R_DeleteFBuffer( struct r_fbuffer *buffer) {
+	int flags = buffer->modeFlags;
+	
+	if (flags & FB_STENCIL) {
+			if (flags & FB_ZTEXTURE) {
+				qglDeleteFramebuffers(1, buffer->depth);
+				qglDeleteFramebuffers(1, buffer->stencil);
+				qglDeleteTextures(1, buffer->depth);
+			}
+			else {
+				qglDeleteRenderbuffers(1, buffer->depth);
+				qglDeleteRenderbuffers(1, buffer->stencil);
+			}
+	}
+	else if (flags & FB_ZBUFFER) {
+			if (flags & FB_ZTEXTURE) {
+				qglDeleteFramebuffers(1, buffer->depth);
+				qglDeleteTextures(1, buffer->depth);
+			}
+			else {
+				qglDeleteRenderbuffers(1, buffer->depth);
+			}
+	}
+	if (flags & FB_BACKBUFFER) {
+		qglDeleteFramebuffers(1, buffer->back);
+		qglDeleteTextures(1, buffer->back);
+	}
+	
+	qglDeleteFramebuffers(1, buffer->front);
+	qglDeleteTextures(1, buffer->front);
+	
+	free(buffer->buffers);
+	
+	qglDeleteFramebuffers(1, &(buffer->fbo));
+	
+	return 0;
+	
+}
+
+int R_CreateFBuffer( struct r_fbuffer *buffer, int width, int height, int flags)
+{
+	
+	//do some checks
+	if ((flags & FB_PACKED) && (flags & FB_SEPERATEZS)) {
+		return -1;
+	}
+	if ((flags & FB_PACKED) && !(flags & FB_STENCIL)) {
+		return -2;
+	}
+	if ((flags & FB_SEPERATEZS) && !(flags & FB_STENCIL)) {
+		return -3;
+	}
+	
+	//store the flags in the struct
+	buffer->modeFlags = flags;
+	
+	//allocate enough storage buffers
+	buffer->numBuffers = 1;
+	if (flags & FB_STENCIL) {
+		if (flags & FB_PACKED) {
+			buffer->numBuffers += 1;
+		}
+		if (flags & FB_SEPERATEZS) {
+			buffer->numBuffers += 2;
+		}
+	}
+	if (flags & FB_ZBUFFER) {
+		buffer->numBuffers += 1;
+	}
+	if (flags & FB_BACKBUFFER) {
+		buffer->numBuffers += 1;
+	}
+	
+	buffer->buffers = malloc(sizeof(GLuint) * buffer->numBuffers);
+	
+	//link the named variables to the storage space
+	int index = 0;
+	buffer->front = &(buffer->buffers[index]);
+	index++;
+	
+	if (flags & FB_BACKBUFFER) {
+		buffer->back = &(buffer->buffers[index]);
+		index++;
+	}
+	
+	if (flags & FB_STENCIL) {
+		if (flags & FB_PACKED) {
+			buffer->stencil = &(buffer->buffers[index]);
+			buffer->depth = &(buffer->buffers[index]);
+			index++;
+		}
+		if (flags & FB_SEPERATEZS) {
+			buffer->depth = &(buffer->buffers[index]);
+			index++;
+			buffer->stencil = &(buffer->buffers[index]);
+			index++;
+		}
+	}
+	else if (flags & FB_ZBUFFER) {
+		buffer->depth = &(buffer->buffers[index]);
+		index++;
+	}
+
+	//set the filter state
+	qboolean filter = qfalse;
+	if (flags & FB_SMOOTH) {
+		filter = qtrue;
+	}
+
+	//gen the frame buffer
+	qglGenFramebuffers(1, &(buffer->fbo));
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, buffer->fbo);
+	
+	if (flags & FB_STENCIL) {
+		if (flags & FB_PACKED) {
+			if (flags & FB_ZTEXTURE) {
+				R_CreateTexbuffer( 	buffer->depth, width, height, qfalse, 
+									GL_UNSIGNED_INT_24_8_EXT, GL_DEPTH_STENCIL_EXT);
+	
+				qglFramebufferTexture2D(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, 
+										GL_TEXTURE_2D, *buffer->depth, 0);
+				
+				qglFramebufferTexture2D(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, 
+										GL_TEXTURE_2D, *buffer->stencil, 0);	
+			}
+			else {
+				R_CreateRenderbuffer(buffer->depth, width, height, GL_DEPTH_STENCIL_EXT);
+				qglFramebufferRenderbuffer(		GL_FRAMEBUFFER_EXT, 
+												GL_DEPTH_ATTACHMENT_EXT,
+												GL_RENDERBUFFER_EXT, 
+												*buffer->depth);
+
+				qglFramebufferRenderbuffer(		GL_FRAMEBUFFER_EXT, 
+												GL_STENCIL_ATTACHMENT_EXT,
+												GL_RENDERBUFFER_EXT, 
+												*buffer->stencil);
+			}		
+
+		}
+		if (flags & FB_SEPERATEZS) {
+			if (flags & FB_ZTEXTURE) {
+				R_CreateTexbuffer( 	buffer->depth, width, height, qfalse, 
+									GL_UNSIGNED_INT, GL_DEPTH_COMPONENT);
+	
+				qglFramebufferTexture2D(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, 
+										GL_TEXTURE_2D, *buffer->depth, 0);
+										
+				R_CreateRenderbuffer(buffer->stencil, width, height, GL_STENCIL_INDEX8_EXT);
+				
+				qglFramebufferRenderbuffer(	GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, 
+											GL_RENDERBUFFER_EXT, *buffer->stencil);	
+			}
+			else {
+				R_CreateRenderbuffer(buffer->depth, width, height, GL_DEPTH_STENCIL_EXT);
+				qglFramebufferRenderbuffer(		GL_FRAMEBUFFER_EXT, 
+												GL_DEPTH_ATTACHMENT_EXT,
+												GL_RENDERBUFFER_EXT, 
+												*buffer->depth);
+												
+				R_CreateRenderbuffer(buffer->stencil, width, height, GL_STENCIL_INDEX8_EXT);
+				qglFramebufferRenderbuffer(		GL_FRAMEBUFFER_EXT, 
+												GL_STENCIL_ATTACHMENT_EXT,
+												GL_RENDERBUFFER_EXT, 
+												*buffer->stencil);
+			}
+		}
+	}
+	else if (flags & FB_ZBUFFER) {
+		if (flags & FB_ZTEXTURE) {
+			R_CreateTexbuffer( 	buffer->depth, width, height, qfalse, 
+								GL_UNSIGNED_INT, GL_DEPTH_COMPONENT);
+	
+			qglFramebufferTexture2D(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, 
+									GL_TEXTURE_2D, *buffer->depth, 0);
+		}
+		else {
+			R_CreateRenderbuffer(buffer->depth, width, height, GL_DEPTH_STENCIL_EXT);
+			qglFramebufferRenderbuffer(		GL_FRAMEBUFFER_EXT, 
+											GL_DEPTH_ATTACHMENT_EXT,
+											GL_RENDERBUFFER_EXT, 
+											*buffer->depth);
+		}
+	}
+	
+	if (flags & FB_BACKBUFFER) {
+		R_CreateTexbuffer(	buffer->back, width, height, filter, 
+							GL_UNSIGNED_BYTE, GL_RGBA);
+	
+		//we link to the second colour attachment
+		qglFramebufferTexture2D(	GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT,
+									GL_TEXTURE_2D, *buffer->back, 0);
+	}
+	
+	//create the main colour buffer
+	R_CreateTexbuffer(	buffer->front, width, height, filter, 
+						GL_UNSIGNED_BYTE, GL_RGBA);
+	
+	qglFramebufferTexture2D(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
+							GL_TEXTURE_2D, *buffer->front, 0);
+	
+	buffer->renderbuff = FB_FRONT;
+	
+	GLenum glstatus = qglCheckFramebufferStatus(GL_FRAMEBUFFER_EXT);
+	if (!(glstatus == GL_FRAMEBUFFER_COMPLETE_EXT)) {
+		return -1;
+	}		
+	
+	return 0;
+}
+
+qboolean R_TestFbuffer_SeperateDS( void ) {	
+	int width = 512;
+	int height = 512;
+	//try and get a perfect seperate stencil/zbuffer
+	//this does not work on any hardware i know, but might in the future.
+	GLuint buffers[3]; //three buffers GL_UNSIGNED_INT_24_8_EXT
+	qglGenFramebuffers(3, buffers);
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, buffers[0]);
+		
+	//create the depth buffer
+	R_CreateRenderbuffer( &buffers[2], width, height, GL_DEPTH_COMPONENT);
+							
+	//stencil buffer as a render buffer
+	R_CreateRenderbuffer( &buffers[2], width, height, GL_STENCIL_INDEX8_EXT);
+	//attach the textures/renderbuffers to the framebuffer
+	qglFramebufferRenderbuffer(	GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
+								GL_RENDERBUFFER_EXT, buffers[1]);									
+	qglFramebufferRenderbuffer(	GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT,
+								GL_RENDERBUFFER_EXT, buffers[2]);	
+									
+	//create our framebuffer context		
+	
+	R_CreateTexbuffer(	&buffers[0], width, height, qfalse, 
+						GL_UNSIGNED_BYTE, GL_RGBA);
+	
+	//shall we link our texture to the frame buffer? yes!
+	qglFramebufferTexture2D(	GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
+								GL_TEXTURE_2D, buffers[0], 0);
+	
+	qboolean status;
+	status = qtrue;
+	GLenum glstatus = qglCheckFramebufferStatus(GL_FRAMEBUFFER_EXT);
+	if (!(glstatus == GL_FRAMEBUFFER_COMPLETE_EXT)) {
+		status = qfalse;
+	}	
+	
+	
+	qglDeleteFramebuffers(1, &buffers[0]);
+	qglDeleteTextures(1,  &buffers[0]);
+	qglDeleteRenderbuffers(1, &buffers[1]);
+	qglDeleteRenderbuffers(1, &buffers[2]);
+	
+	return status;
+}
+
+qboolean R_TestFbuffer_PackedDS( void ) {	
+	int width = 512;
+	int height = 512;
+	//try and get a packed seperate stencil/zbuffer
+	GLuint buffers[2];
+	qglGenFramebuffers(2, buffers);
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, buffers[0]);
+		
+	//create the buffer
+	R_CreateRenderbuffer( &buffers[1], width, height, GL_DEPTH_STENCIL_EXT);
+	//attach the textures/renderbuffers to the framebuffer
+	qglFramebufferRenderbuffer(	GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
+								GL_RENDERBUFFER_EXT, buffers[1]);									
+	qglFramebufferRenderbuffer(	GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT,
+								GL_RENDERBUFFER_EXT, buffers[1]);
+
+	
+	qglBindRenderbuffer(GL_RENDERBUFFER_EXT, buffers[1]);						
+	//create our framebuffer context		
+	
+	R_CreateTexbuffer(	&buffers[0], width, height, qfalse, 
+						GL_UNSIGNED_BYTE, GL_RGBA);
+	
+	//shall we link our texture to the frame buffer? yes!
+	qglFramebufferTexture2D(	GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
+								GL_TEXTURE_2D, buffers[0], 0);
+	
+	qboolean status;
+	status = qtrue;
+	GLenum glstatus = qglCheckFramebufferStatus(GL_FRAMEBUFFER_EXT);
+	if (!(glstatus == GL_FRAMEBUFFER_COMPLETE_EXT)) {
+		status = qfalse;
+	}	
+	
+	qglDeleteFramebuffers(1, &buffers[0]);
+	qglDeleteTextures(1,  &buffers[0]);
+	qglDeleteRenderbuffers(1, &buffers[1]);
+	
+	return status;
+}
+
+qboolean R_TestFbuffer_texD( void ) {	
+	int width = 512;
+	int height = 512;
+	//try and get a packed seperate stencil/zbuffer
+	GLuint buffers[2];
+	qglGenFramebuffers(2, buffers);
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, buffers[0]);
+		
+	//create the buffer
+
+	R_CreateTexbuffer(	&buffers[0], width, height, qfalse, 
+						GL_UNSIGNED_INT, GL_DEPTH_COMPONENT);
+	
+	qglFramebufferTexture2D(	GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, 
+								GL_TEXTURE_2D, buffers[1], 0);
+						
+	//create our framebuffer context		
+	
+	R_CreateTexbuffer(	&buffers[0], width, height, qfalse, 
+						GL_UNSIGNED_BYTE, GL_RGBA);
+	
+	//shall we link our texture to the frame buffer? yes!
+	qglFramebufferTexture2D(	GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
+								GL_TEXTURE_2D, buffers[0], 0);
+	
+	qboolean status;
+	status = qtrue;
+	GLenum glstatus = qglCheckFramebufferStatus(GL_FRAMEBUFFER_EXT);
+	if (!(glstatus == GL_FRAMEBUFFER_COMPLETE_EXT)) {
+		status = qfalse;
+	}	
+	
+	qglDeleteFramebuffers(1, &buffers[0]);
+	qglDeleteTextures(1,  &buffers[0]);
+	qglDeleteFramebuffers(1, &buffers[1]);
+	qglDeleteTextures(1,  &buffers[1]);
+	
+	return status;
+}
+
+
+// for shader debugging
+void printShaderInfoLog(GLuint obj)
+{
+    int infologLength = 0;
+    int charsWritten  = 0;
+    char *infoLog;
+
+	qglGetShaderiv(obj, GL_INFO_LOG_LENGTH,&infologLength);
+
+    if (infologLength > 1)
+    {
+        infoLog = (char *)malloc(infologLength);
+        qglGetShaderInfoLog(obj, infologLength, &charsWritten, infoLog);
+		ri.Printf( PRINT_ALL, "----- Shader InfoLog -----\n" );;
+		ri.Printf( PRINT_ALL, infoLog );
+        free(infoLog);
+    }
+}
+
+void printProgramInfoLog(GLuint obj)
+{
+    int infologLength = 0;
+    int charsWritten  = 0;
+    char *infoLog;
+
+	qglGetProgramiv(obj, GL_INFO_LOG_LENGTH,&infologLength);
+
+    if (infologLength > 1)
+    {
+        infoLog = (char *)malloc(infologLength);
+        qglGetProgramInfoLog(obj, infologLength, &charsWritten, infoLog);
+		ri.Printf( PRINT_ALL, "----- Program InfoLog -----\n" );;
+		ri.Printf( PRINT_ALL, infoLog );
+        free(infoLog);
+    }
+}
+
+void R_Build_glsl(struct glslobj *obj) {
+	GLuint vert_shader, frag_shader, program;
+	
+	vert_shader = qglCreateShader(GL_VERTEX_SHADER);
+	frag_shader = qglCreateShader(GL_FRAGMENT_SHADER);
+	
+	qglShaderSource(vert_shader, obj->vert_numSources, obj->vertex_glsl, NULL);
+	qglShaderSource(frag_shader, obj->frag_numSources, obj->fragment_glsl, NULL);
+
+	printShaderInfoLog(vert_shader);
+	printShaderInfoLog(frag_shader);
+
+	qglCompileShader(vert_shader);
+	qglCompileShader(frag_shader);
+
+	program = qglCreateProgram();
+	qglAttachShader(program, vert_shader);
+	qglAttachShader(program, frag_shader);
+	qglLinkProgram(program);
+
+	printProgramInfoLog(program);
+
+	obj->vertex = vert_shader;
+	obj->fragment = frag_shader;
+	obj->program = program;
+
+}
+
+void R_Delete_glsl(struct glslobj *obj) {
+	qglDeleteProgram(obj->program);
+	qglDeleteShader(obj->vertex);
+	qglDeleteShader(obj->fragment);
+}
+
+struct glslobj glslBlur;
+
+void R_FrameBuffer_BlurInit( void ) {
+	//inits our blur code;
+	if ( needBlur != 1 ) {
+		return;
+	}
+	if ( r_framebuffer_blur_size->integer < 2 ) {
+		return;
+	}
+	int fb_size = r_framebuffer_blur_size->integer;
+	
+	R_CreateFBuffer( &gaussblurBuffer, fb_size, fb_size, FB_BACKBUFFER | FB_SMOOTH);
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+	
+	int samples = r_framebuffer_blur_samples->integer;
+	//create our glsl shader
+	glslBlur.vert_numSources = 1;
+	glslBlur.frag_numSources = 2;
+	
+	glslBlur.vertex_glsl = malloc(sizeof(char *) * glslBlur.vert_numSources); 
+	glslBlur.vertex_glsl[0] = glslBase_vert;
+	
+	glslBlur.fragment_glsl = malloc(sizeof(char *) * glslBlur.frag_numSources); 
+	switch (samples) {
+		case (5):
+			glslBlur.fragment_glsl[0] = glslGauss5;
+			break;
+		case (7):
+			glslBlur.fragment_glsl[0] = glslGauss7;
+			break;
+		case (9):
+			glslBlur.fragment_glsl[0] = glslGauss9;
+			break;
+		default:
+			glslBlur.fragment_glsl[0] = glslGauss9;
+			break;
+	}
+	glslBlur.fragment_glsl[1] = glslBlurMain;
+
+	R_Build_glsl(&glslBlur);
+	
+}
+
+void R_FrameBuffer_BlurDraw( GLuint *srcTex ) {
+	if ( r_framebuffer_blur_size->integer < 2 ) {
+		return;
+	}
+	
+	if ( needBlur != 1 ) {
+		return;
+	}
+	int fb_size = r_framebuffer_blur_size->integer;
+	GLuint program, loc;
+	// first we draw the framebuffer into the blur buffer before any fragment
+	// programs are used is quicker, the rational behind this is that we want 
+	// as many texels to fit inside the texture cache as possible for the 
+	// gaussian sampling
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, gaussblurBuffer.fbo);
+	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+	R_SetGL2DSize(fb_size, fb_size);		
+	qglUseProgram(0);
+	R_DrawQuad(	*srcTex, fb_size, fb_size);
+	
+	//now we do the first gaussian pass
+	
+	glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);
+	R_SetGL2DSize(fb_size, fb_size);		
+	
+	program = glslBlur.program;
+	qglUseProgram(0);
+	qglUseProgram(program);
+	
+	//find and set the samplers
+	//set the texture number... silly this really. oh well thats glsl
+	loc = qglGetUniformLocation(program, "srcSampler");
+	qglUniform1i(loc, 0);
+	loc = qglGetUniformLocation(program, "blurSize");
+	qglUniform2f(loc, r_framebuffer_blur_ammount->value / 100.0, 0.0);
+	
+	R_DrawQuad(	*gaussblurBuffer.front, fb_size, fb_size);
+		
+	//we do the second pass of the blur here
+	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+	loc = qglGetUniformLocation(program, "blurSize");
+	qglUniform2f(loc, 0.0, r_framebuffer_blur_ammount->value / 100.0);
+	
+	R_SetGL2DSize(fb_size, fb_size);
+	R_DrawQuad(	*gaussblurBuffer.back, fb_size, fb_size);
+	qglUseProgram(0);
+	
+	//finally the FRONT buffer in the fbo is given the blurred image
+	
+}
+
+void R_FrameBuffer_BlurDelete( void ) {
+	
+	R_Delete_glsl(&glslBlur);
+	free(glslBlur.vertex_glsl);
+	free(glslBlur.fragment_glsl);
+	
+	R_DeleteFBuffer(&gaussblurBuffer);
+}
+
+struct glslobj glslRoto;
+void R_FrameBuffer_RotoInit( struct r_fbuffer *src ) {
+	
+	// check to see if we need to create a framebuffer for this (only if there
+	// is a shader running after this)
+	 
+	//create our glsl shader
+	glslRoto.vert_numSources = 1;
+	glslRoto.frag_numSources = 3;
+	
+	glslRoto.vertex_glsl = malloc(sizeof(char *) * glslRoto.vert_numSources); 
+	glslRoto.vertex_glsl[0] = glslBase_vert;
+	
+	glslRoto.fragment_glsl = malloc(sizeof(char *) * glslRoto.frag_numSources); 
+	glslRoto.fragment_glsl[0] = glslSobel;
+	glslRoto.fragment_glsl[1] = glslToonColour;
+	
+	if ((r_framebuffer_rotoscope_zedge->integer) && (src->modeFlags & FB_ZTEXTURE)) {
+		glslRoto.fragment_glsl[2] = glslRotoscopeZ;
+	} else { 
+		glslRoto.fragment_glsl[2] = glslRotoscope;
+	}
+	
+	R_Build_glsl(&glslRoto);
+}
+
+void R_FrameBuffer_RotoDraw( struct r_fbuffer *src, GLuint *srcTex ) { 
+	GLuint program, loc;
+	program = glslRoto.program;
+	qglUseProgram(0);
+	qglUseProgram(program);
+	
+	R_SetGL2DSize(glConfig.vidWidth, glConfig.vidHeight);
+	
+	//find and set the samplers
+	loc = qglGetUniformLocation(program, "srcSampler");
+	qglUniform1i(loc, 0);
+	loc = qglGetUniformLocation(program, "depthSampler");
+	qglUniform1i(loc, 1);
+	loc = qglGetUniformLocation(program, "texelSize");
+	qglUniform2f(loc, 1.0 / glConfig.vidWidth, 1.0 / glConfig.vidHeight);
+	
+	if ((r_framebuffer_rotoscope_zedge->integer) && (src->modeFlags & FB_ZTEXTURE)) {
+		R_DrawQuadMT(	*srcTex, *src->depth, 
+						glConfig.vidWidth, glConfig.vidHeight);
+	} else {
+		R_DrawQuad(	*srcTex, glConfig.vidWidth, glConfig.vidHeight);
+	} 
+	qglUseProgram(0);
+}
+
+void R_FrameBuffer_RotoDelete( void ) {
+	R_Delete_glsl(&glslRoto);
+	free(glslRoto.vertex_glsl);
+	free(glslRoto.fragment_glsl);
+}
+
+struct glslobj glslBloom;
+
+void R_FrameBuffer_BloomInit( void ) {
+	//we need blur for this
+	needBlur = 1;
+	//create our glsl shader
+	glslBloom.vert_numSources = 1;
+	glslBloom.frag_numSources = 1;
+	glslBloom.vertex_glsl = malloc(sizeof(char *) * glslBlur.frag_numSources); 
+	glslBloom.vertex_glsl[0] = glslBase_vert;
+	glslBloom.fragment_glsl = malloc(sizeof(char *) * glslBlur.frag_numSources); 
+	glslBloom.fragment_glsl[0] = glslSigScreen;
+
+	R_Build_glsl(&glslBloom);
+}
+
+void R_FrameBuffer_BloomDraw( GLuint *srcTex ) {
+	GLuint program, loc;
+	program = glslBloom.program;
+	qglUseProgram(0);
+	qglUseProgram(program);
+	
+	R_SetGL2DSize(glConfig.vidWidth, glConfig.vidHeight);
+	
+	//find and set the samplers
+	loc = qglGetUniformLocation(program, "srcSampler");
+	qglUniform1i(loc, 0);
+	loc = qglGetUniformLocation(program, "blurSampler");
+	qglUniform1i(loc, 1);
+	loc = qglGetUniformLocation(program, "brightness");
+	qglUniform1f(loc, r_framebuffer_bloom_brightness->value);
+	loc = qglGetUniformLocation(program, "sharpness");
+	qglUniform1f(loc, r_framebuffer_bloom_sharpness->value);
+	
+	R_DrawQuadMT(	*srcTex, *gaussblurBuffer.front, 
+					glConfig.vidWidth, glConfig.vidHeight);
+	qglUseProgram(0);
+	//quick test to just see the blur
+	//R_DrawQuad(*gaussblurBuffer.front, glConfig.vidWidth, glConfig.vidHeight);
+}
+
+void R_FrameBuffer_BloomDelete( void ) {
+	R_Delete_glsl(&glslBloom);
+	free(glslBloom.vertex_glsl);
+	free(glslBloom.fragment_glsl);
+}
+
+void R_FrameBuffer_Draw( void ) {
+	//draws the framebuffer to the screen, pretty simple really.
+	R_SetGL2DSize(glConfig.vidWidth, glConfig.vidHeight);
+	R_DrawQuad(	*(screenBuffer.front), glConfig.vidWidth, glConfig.vidHeight);
+}
+
+void R_FrameBuffer_Init( void ) {
+	
+	if (!framebufferSupported | !glslSupported) {
+		ri.Printf( PRINT_WARNING, "WARNING: Framebuffer rendering path disabled\n");
+		return;
+	}
+	
+	if (r_framebuffer->integer != 1) {
+		return;
+	}
+
+	ri.Printf( PRINT_ALL, "----- Enabling FrameBuffer Path -----\n" );
+
+	//lets see what works and what doesn't
+	packedDepthStencilSupported = qfalse;
+	depthTextureSupported = qfalse;
+	seperateDepthStencilSupported = qfalse;
+
+	if (R_TestFbuffer_PackedDS()) {
+		packedDepthStencilSupported = qtrue;
+	} else {
+		ri.Printf( PRINT_WARNING, "WARNING: packed_depth_stencil failed\n");
+	}
+	if (R_TestFbuffer_SeperateDS()) {
+		seperateDepthStencilSupported = qtrue;
+	} else {
+		ri.Printf( PRINT_WARNING, "WARNING: seperate depth stencil failed\n");
+	}
+	if (R_TestFbuffer_texD()) {
+		depthTextureSupported = qtrue;
+	} else {
+		ri.Printf( PRINT_WARNING, "WARNING: depth texture failed\n");
+	}
+	
+	GLint maxbuffers;
+	qglGetIntegerv(GL_MAX_COLOR_ATTACHMENTS_EXT, &maxbuffers);
+	if (maxbuffers < 2) {
+		framebufferSupported = qfalse;
+		ri.Printf( PRINT_WARNING, "WARNING: Not enough color buffers available\n");
+		ri.Printf( PRINT_WARNING, "WARNING: Framebuffer rendering path disabled\n");
+	}
+		
+		
+	//set our main screen flags									
+	int screenbuff_flags = 0x00;
+	if ((glConfig.stencilBits > 0)) {
+		if ( packedDepthStencilSupported ) {
+			screenbuff_flags |= FB_PACKED | FB_STENCIL;
+		}
+		else if ( seperateDepthStencilSupported ) {
+			screenbuff_flags |= FB_SEPERATEZS | FB_STENCIL;
+		}
+	}
+	
+	if ((depthTextureSupported) && (r_framebuffer_rotoscope_zedge->integer)) {
+		screenbuff_flags |= FB_ZTEXTURE;
+	}
+	screenbuff_flags |= FB_BACKBUFFER;
+	
+	screenbuff_flags |= FB_ZBUFFER;
+	
+	int status;
+	//create our main frame buffer
+	status = R_CreateFBuffer( 	&screenBuffer, glConfig.vidWidth, 
+								glConfig.vidHeight, screenbuff_flags);
+	
+	if (status) {
+		// if the main fbuffer failed then we should disable framebuffer 
+		// rendering
+		framebufferSupported = qfalse;
+		ri.Printf( PRINT_WARNING, "WARNING: Framebuffer creation failed\n");
+		ri.Printf( PRINT_WARNING, "WARNING: Framebuffer rendering path disabled\n");
+	}
+						
+	//init our effects
+	if (r_framebuffer_rotoscope->integer == 1) {
+		R_FrameBuffer_RotoInit(&screenBuffer);
+	}
+	
+	if (r_framebuffer_bloom->integer == 1) {
+		R_FrameBuffer_BloomInit();
+	}
+	//we don't need an if here, if any effects before need a blur then this 
+	//auto detects that its needed
+	R_FrameBuffer_BlurInit();
+
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, *screenBuffer.front);
+
+	
+}
+
+void R_FrameBuffer_EndFrame( void ) {
+	if (!framebufferSupported | !glslSupported) {
+		return;
+	}
+	if (r_framebuffer->integer != 1) {
+		return;
+	}
+	
+	//don't flip if drawing to front buffer
+	if ( Q_stricmp( r_drawBuffer->string, "GL_FRONT" ) == 0 ) {
+		return;
+	}
+	
+	GL_State( GLS_DEPTHTEST_DISABLE );
+	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
+	
+	qboolean screenDrawDone = 0;
+	qglColor4f( 1, 1, 1, 1 );
+	
+	GLuint *srcBuffer = screenBuffer.front;
+	
+	
+	
+	if (r_framebuffer_rotoscope->integer == 1) {
+		if (r_framebuffer_bloom->integer == 1) {
+			//we need to draw to the back buffer
+			glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);
+			R_FrameBuffer_RotoDraw(&screenBuffer, srcBuffer);
+			srcBuffer = screenBuffer.back;
+			glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+		}
+		else {
+			qglBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+			R_FrameBuffer_RotoDraw(&screenBuffer, srcBuffer);
+			screenDrawDone = 1;
+		}
+	}
+	//everything before this point does not need blurred surfaces (or can do
+	//with the last frames burred surface)
+	//call the blur code, it auto detects weather its needed :)
+	R_FrameBuffer_BlurDraw(srcBuffer);
+	
+	if (r_framebuffer_bloom->integer == 1) {
+		qglBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+		R_FrameBuffer_BloomDraw(srcBuffer);
+		screenDrawDone = 1;
+	}
+	
+	if (screenDrawDone == 0) {
+		qglBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+		//R_SetGL2DSize(glConfig.vidWidth, glConfig.vidHeight);
+		R_DrawQuad(	*srcBuffer, glConfig.vidWidth, glConfig.vidHeight);
+	}
+	
+	//Finally we re-bind our framebuffer so everything gets rendered into it.
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, screenBuffer.fbo);
+	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+	
+	
+}
+void R_FrameBuffer_Shutdown( void ) {
+	//cleanup
+	
+	if (!r_framebuffer->integer) {
+		return;
+	}
+	qglBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+	
+	
+	if (r_framebuffer_bloom->integer == 1) {
+		R_FrameBuffer_BloomDelete();
+	}
+	if ( needBlur == 1 ) {
+		R_FrameBuffer_BlurDelete();
+	}
+	if ( r_framebuffer_rotoscope->integer == 1) {
+		R_FrameBuffer_RotoDelete();
+	}
+	
+	//delete the main screen buffer
+	R_DeleteFBuffer(&screenBuffer);
+}
Index: code/renderer/tr_backend.c
===================================================================
--- code/renderer/tr_backend.c	(revision 1216)
+++ code/renderer/tr_backend.c	(working copy)
@@ -1028,7 +1028,7 @@
 		ri.Hunk_FreeTempMemory( stencilReadback );
 	}
 
-
+	R_FrameBuffer_EndFrame(); //draws our framebuffer if we are using that
 	if ( !glState.finishCalled ) {
 		qglFinish();
 	}
@@ -1078,11 +1078,16 @@
 		case RC_SWAP_BUFFERS:
 			data = RB_SwapBuffers( data );
 			break;
+		//these two use a hack to let them copy the framebuffer effects too
 		case RC_SCREENSHOT:
+			R_FrameBufferUnBind();
 			data = RB_TakeScreenshotCmd( data );
+			R_FrameBufferBind();
 			break;
 		case RC_VIDEOFRAME:
+			R_FrameBufferUnBind();
 			data = RB_TakeVideoFrameCmd( data );
+			R_FrameBufferBind();
 			break;
 
 		case RC_END_OF_LIST:
Index: code/null/null_glimp.c
===================================================================
--- code/null/null_glimp.c	(revision 1216)
+++ code/null/null_glimp.c	(working copy)
@@ -31,7 +31,39 @@
 void ( * qglLockArraysEXT)( int, int);
 void ( * qglUnlockArraysEXT) ( void );
 
+//added framebuffer extensions
+ void ( * qglGenFramebuffers )(GLsizei, GLuint *);
+ void ( * qglBindFramebuffer )(GLenum, GLuint);
+ void ( * glGenRenderbuffers )(GLsizei, GLuint *);
+ void ( * glBindRenderbuffer )(GLenum, GLuint);
+ void ( * glRenderbufferStorage )(GLenum, GLenum, GLsizei, GLsizei);
+ void ( * glFramebufferRenderbuffer )(GLenum, GLenum, GLenum, GLuint);
+ void ( * glFramebufferTexture2D )(GLenum, GLenum, GLenum, GLuint, GLint);
+ GLenum ( * glCheckFramebufferStatus )(GLenum);
+ void ( * glDeleteFramebuffers )(GLsizei, const GLuint *);
+ void ( * glDeleteRenderbuffers )(GLsizei, const GLuint *);
 
+//added fragment/vertex program extensions
+ void ( * glAttachShader) (GLuint, GLuint);
+ void ( * glBindAttribLocation) (GLuint, GLuint, const GLchar *);
+ void ( * glCompileShader) (GLuint);
+GLuint ( * glCreateProgram) (void);
+GLuint ( * glCreateShader) (GLenum);
+void ( * glDeleteProgram) (GLuint);
+void ( * glDeleteShader) (GLuint);
+void ( * glShaderSource) (GLuint, GLsizei, const GLchar* *, const GLint *);
+void ( * glLinkProgram) (GLuint);
+void ( * glUseProgram) (GLuint);	
+GLint ( * glGetUniformLocation) (GLuint, const GLchar *);
+void ( * glUniform1f) (GLint, GLfloat);
+void ( * glUniform2f) (GLint, GLfloat, GLfloat);
+void ( * glUniform1i) (GLint, GLint);
+void ( * glGetProgramiv) (GLuint, GLenum, GLint *);
+void ( * glGetProgramInfoLog) (GLuint, GLsizei, GLsizei *, GLchar *);
+void ( * glGetShaderiv) (GLuint, GLenum, GLint *);
+void ( * glGetShaderInfoLog) (GLuint, GLsizei, GLsizei *, GLchar *);
+
+
 void		GLimp_EndFrame( void ) {
 }
 
Index: Makefile
===================================================================
--- Makefile	(revision 1216)
+++ Makefile	(working copy)
@@ -1233,6 +1233,8 @@
   $(B)/client/tr_sky.o \
   $(B)/client/tr_surface.o \
   $(B)/client/tr_world.o \
+  $(B)/client/tr_framebuffer.o \
+  $(B)/client/tr_glslprogs.o \
   \
   $(B)/client/sdl_gamma.o \
   $(B)/client/sdl_input.o \
