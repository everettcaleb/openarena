Index: code/q3_ui/ui_mods.c
===================================================================
--- code/q3_ui/ui_mods.c	(revision 1145)
+++ code/q3_ui/ui_mods.c	(working copy)
@@ -161,7 +161,7 @@
 
 	// always start off with baseq3
 	s_mods.list.numitems = 1;
-	s_mods.list.itemnames[0] = s_mods.descriptionList[0] = "Quake III Arena";
+	s_mods.list.itemnames[0] = s_mods.descriptionList[0] = "OpenArena";
 	s_mods.fs_gameList[0] = "";
 
 	numdirs = trap_FS_GetFileList( "$modlist", "", dirlist, sizeof(dirlist) );
Index: code/q3_ui/ui_menu.c
===================================================================
--- code/q3_ui/ui_menu.c	(revision 1145)
+++ code/q3_ui/ui_menu.c	(working copy)
@@ -221,12 +221,11 @@
 		Menu_Draw( &s_main.menu );		
 	}
 
-	if (uis.demoversion) {
-		UI_DrawProportionalString( 320, 372, "DEMO      FOR MATURE AUDIENCES      DEMO", UI_CENTER|UI_SMALLFONT, color );
-		UI_DrawString( 320, 400, "Quake III Arena(c) 1999-2000, Id Software, Inc.  All Rights Reserved", UI_CENTER|UI_SMALLFONT, color );
-	} else {
-		UI_DrawString( 320, 450, "Quake III Arena(c) 1999-2000, Id Software, Inc.  All Rights Reserved", UI_CENTER|UI_SMALLFONT, color );
-	}
+		UI_DrawProportionalString( 320, 372, "", UI_CENTER|UI_SMALLFONT, color );
+		UI_DrawString( 320, 400, "OpenArena(c) 2005-2007 OpenArena Team", UI_CENTER|UI_SMALLFONT, color );
+		UI_DrawString( 320, 414, "OpenArena comes with ABSOLUTELY NO WARRANTY; this is free software", UI_CENTER|UI_SMALLFONT, color );
+		UI_DrawString( 320, 428, "and you are welcome to redistribute it under certain conditions;", UI_CENTER|UI_SMALLFONT, color );
+		UI_DrawString( 320, 444, "read COPYING for details.", UI_CENTER|UI_SMALLFONT, color );
 }
 
 
@@ -374,7 +373,7 @@
 		s_main.teamArena.generic.y				= y;
 		s_main.teamArena.generic.id				= ID_TEAMARENA;
 		s_main.teamArena.generic.callback		= Main_MenuEvent; 
-		s_main.teamArena.string					= "TEAM ARENA";
+		s_main.teamArena.string					= "MISSION PACK";
 		s_main.teamArena.color					= color_red;
 		s_main.teamArena.style					= style;
 	}
Index: code/q3_ui/ui_servers2.c
===================================================================
--- code/q3_ui/ui_servers2.c	(revision 1145)
+++ code/q3_ui/ui_servers2.c	(working copy)
@@ -32,16 +32,16 @@
 #include "ui_local.h"
 
 
-#define MAX_GLOBALSERVERS		128
+#define MAX_GLOBALSERVERS		124
 #define MAX_PINGREQUESTS		32
 #define MAX_ADDRESSLENGTH		64
 #define MAX_HOSTNAMELENGTH		22
 #define MAX_MAPNAMELENGTH		16
-#define MAX_LISTBOXITEMS		128
-#define MAX_LOCALSERVERS		128
+#define MAX_LISTBOXITEMS		124
+#define MAX_LOCALSERVERS		124
 #define MAX_STATUSLENGTH		64
 #define MAX_LEAGUELENGTH		28
-#define MAX_LISTBOXWIDTH		68
+#define MAX_LISTBOXWIDTH		62
 
 #define ART_BACK0				"menu/art/back_0"
 #define ART_BACK1				"menu/art/back_1"
@@ -96,7 +96,12 @@
 #define GAMES_TEAMPLAY		2
 #define GAMES_TOURNEY		3
 #define GAMES_CTF			4
+#define GAMES_ELIMINATION		5
+#define GAMES_CTF_ELIMINATION		6
+#define GAMES_LMS			7
+#define GAMES_DOUBLE_D			8
 
+
 static const char *master_items[] = {
 	"Local",
 	"Internet",
@@ -110,6 +115,10 @@
 	"Team Deathmatch",
 	"Tournament",
 	"Capture the Flag",
+	"Elimination",
+	"CTF Elimination",
+	"Last Man Standing",
+	"Double Domination",
 	NULL
 };
 
@@ -135,6 +144,10 @@
 	"Q3F",						// Q3F
 	"Urban Terror",		// Urban Terror
 	"OSP",						// Orange Smoothie Productions
+	"Elimination",
+	"CTF Elimination",
+	"Last Man Standing",
+	"Double Domination",
 	"???",			// unknown
 	NULL
 };
@@ -142,10 +155,11 @@
 static char* netnames[] = {
 	"???",
 	"UDP",
+	"IPX",
 	NULL
 };
 
-static char quake3worldMessage[] = "Visit www.quake3world.com - News, Community, Events, Files";
+static char quake3worldMessage[] = "Visit www.openarena.ws - News, Community, Events, Files";
 
 const char* punkbuster_items[] = {
 	"Disabled",
@@ -510,6 +524,30 @@
 				continue;
 			}
 			break;
+
+		case GAMES_ELIMINATION:
+			if( servernodeptr->gametype != GT_ELIMINATION ) {
+				continue;
+			}
+			break;
+		
+		case GAMES_CTF_ELIMINATION:
+			if( servernodeptr->gametype != GT_CTF_ELIMINATION ) {
+				continue;
+			}
+			break;
+
+		case GAMES_LMS:
+			if( servernodeptr->gametype != GT_LMS ) {
+				continue;
+			}
+			break;
+
+		case GAMES_DOUBLE_D:
+			if( servernodeptr->gametype != GT_DOUBLE_D ) {
+				continue;
+			}
+			break;
 		}
 
 		if( servernodeptr->pingtime < servernodeptr->minPing ) {
@@ -567,37 +605,34 @@
 
 	// find address in master list
 	for (i=0; i<g_arenaservers.numfavoriteaddresses; i++)
+		if (!Q_stricmp(g_arenaservers.favoriteaddresses[i],servernodeptr->adrstr))
+				break;
+
+	// delete address from master list
+	if (i <= g_arenaservers.numfavoriteaddresses-1)
 	{
-		if (!Q_stricmp(g_arenaservers.favoriteaddresses[i],servernodeptr->adrstr))
+		if (i < g_arenaservers.numfavoriteaddresses-1)
 		{
-			// delete address from master list
-			if (i < g_arenaservers.numfavoriteaddresses-1)
-			{
-				// shift items up
-				memcpy( &g_arenaservers.favoriteaddresses[i], &g_arenaservers.favoriteaddresses[i+1], (g_arenaservers.numfavoriteaddresses - i - 1)* MAX_ADDRESSLENGTH );
-			}
-			g_arenaservers.numfavoriteaddresses--;
-			memset( &g_arenaservers.favoriteaddresses[g_arenaservers.numfavoriteaddresses], 0, MAX_ADDRESSLENGTH );
-			break;
+			// shift items up
+			memcpy( &g_arenaservers.favoriteaddresses[i], &g_arenaservers.favoriteaddresses[i+1], (g_arenaservers.numfavoriteaddresses - i - 1)*MAX_ADDRESSLENGTH);
 		}
+		g_arenaservers.numfavoriteaddresses--;
 	}	
 
 	// find address in server list
 	for (i=0; i<g_numfavoriteservers; i++)
+		if (&g_favoriteserverlist[i] == servernodeptr)
+				break;
+
+	// delete address from server list
+	if (i <= g_numfavoriteservers-1)
 	{
-		if (&g_favoriteserverlist[i] == servernodeptr)
+		if (i < g_numfavoriteservers-1)
 		{
-
-			// delete address from server list
-			if (i < g_numfavoriteservers-1)
-			{
-				// shift items up
-				memcpy( &g_favoriteserverlist[i], &g_favoriteserverlist[i+1], (g_numfavoriteservers - i - 1)*sizeof(servernode_t));
-			}
-			g_numfavoriteservers--;
-			memset( &g_favoriteserverlist[ g_numfavoriteservers ], 0, sizeof(servernode_t));
-			break;
+			// shift items up
+			memcpy( &g_favoriteserverlist[i], &g_favoriteserverlist[i+1], (g_numfavoriteservers - i - 1)*sizeof(servernode_t));
 		}
+		g_numfavoriteservers--;
 	}	
 
 	g_arenaservers.numqueriedservers = g_arenaservers.numfavoriteaddresses;
@@ -1040,6 +1075,22 @@
 		case GAMES_CTF:
 			strcpy( myargs, " ctf" );
 			break;
+
+		case GAMES_ELIMINATION:
+			strcpy( myargs, " elimination" );
+			break;
+
+		case GAMES_CTF_ELIMINATION:
+			strcpy( myargs, " ctfelimination" );
+			break;
+
+		case GAMES_LMS:
+			strcpy( myargs, " lms" );
+			break;
+		
+		case GAMES_DOUBLE_D:
+			strcpy( myargs, " dd" );
+			break;
 		}
 
 
@@ -1584,7 +1635,7 @@
 		value--;
 	g_arenaservers.master.curvalue = value;
 
-	g_gametype = Com_Clamp( 0, 4, ui_browserGameType.integer );
+	g_gametype = Com_Clamp( 0, 5, ui_browserGameType.integer );
 	g_arenaservers.gametype.curvalue = g_gametype;
 
 	g_sortkey = Com_Clamp( 0, 4, ui_browserSortKey.integer );
Index: code/q3_ui/ui_serverinfo.c
===================================================================
--- code/q3_ui/ui_serverinfo.c	(revision 1145)
+++ code/q3_ui/ui_serverinfo.c	(working copy)
@@ -128,11 +128,11 @@
 	const char		*s;
 	char			key[MAX_INFO_KEY];
 	char			value[MAX_INFO_VALUE];
-	int				i = 0, y;
+	int				y;
 
 	y = SCREEN_HEIGHT/2 - s_serverinfo.numlines*(SMALLCHAR_HEIGHT)/2 - 20;
 	s = s_serverinfo.info;
-	while ( s && i < s_serverinfo.numlines ) {
+	while ( s ) {
 		Info_NextPair( &s, key, value );
 		if ( !key[0] ) {
 			break;
@@ -144,7 +144,6 @@
 		UI_DrawString(SCREEN_WIDTH*0.50 + 8,y,value,UI_LEFT|UI_SMALLFONT,text_color_normal);
 
 		y += SMALLCHAR_HEIGHT;
-		i++;
 	}
 
 	Menu_Draw( &s_serverinfo.menu );
Index: code/q3_ui/ui_main.c
===================================================================
--- code/q3_ui/ui_main.c	(revision 1145)
+++ code/q3_ui/ui_main.c	(working copy)
@@ -113,6 +113,17 @@
 vmCvar_t	ui_ctf_timelimit;
 vmCvar_t	ui_ctf_friendly;
 
+vmCvar_t	ui_elimination_capturelimit;
+vmCvar_t	ui_elimination_timelimit;
+vmCvar_t	ui_elimination_friendly;
+
+vmCvar_t	ui_ctf_elimination_capturelimit;
+vmCvar_t	ui_ctf_elimination_timelimit;
+vmCvar_t	ui_ctf_elimination_friendly;
+
+vmCvar_t	ui_lms_fraglimit;
+vmCvar_t	ui_lms_timelimit;
+
 vmCvar_t	ui_arenasFile;
 vmCvar_t	ui_botsFile;
 vmCvar_t	ui_spScores1;
@@ -172,6 +183,17 @@
 	{ &ui_ctf_timelimit, "ui_ctf_timelimit", "30", CVAR_ARCHIVE },
 	{ &ui_ctf_friendly, "ui_ctf_friendly",  "0", CVAR_ARCHIVE },
 
+	{ &ui_team_fraglimit, "ui_elimination_capturelimit", "0", CVAR_ARCHIVE },
+	{ &ui_team_timelimit, "ui_elimination_timelimit", "20", CVAR_ARCHIVE },
+	{ &ui_team_friendly, "ui_elimination_friendly",  "1", CVAR_ARCHIVE },
+
+	{ &ui_ctf_capturelimit, "ui_ctf_elimination_capturelimit", "8", CVAR_ARCHIVE },
+	{ &ui_ctf_timelimit, "ui_ctf_elimination_timelimit", "30", CVAR_ARCHIVE },
+	{ &ui_ctf_friendly, "ui_ctf_elimination_friendly",  "0", CVAR_ARCHIVE },
+
+	{ &ui_ffa_fraglimit, "ui_lms_fraglimit", "20", CVAR_ARCHIVE },
+	{ &ui_ffa_timelimit, "ui_lms_timelimit", "0", CVAR_ARCHIVE },
+
 	{ &ui_arenasFile, "g_arenasFile", "", CVAR_INIT|CVAR_ROM },
 	{ &ui_botsFile, "g_botsFile", "", CVAR_INIT|CVAR_ROM },
 	{ &ui_spScores1, "g_spScores1", "", CVAR_ARCHIVE | CVAR_ROM },
Index: code/q3_ui/ui_startserver.c
===================================================================
--- code/q3_ui/ui_startserver.c	(revision 1145)
+++ code/q3_ui/ui_startserver.c	(working copy)
@@ -98,12 +98,37 @@
 	"Team Deathmatch",
 	"Tournament",
 	"Capture the Flag",
+	"Elimination",
+	"CTF Elimination",
+	"Last Man Standing",
+	"Double Domination",
 	NULL
 };
 
-static int gametype_remap[] = {GT_FFA, GT_TEAM, GT_TOURNAMENT, GT_CTF};
-static int gametype_remap2[] = {0, 2, 0, 1, 3};
+static int gametype_remap[] = {
+		GT_FFA,			
+		GT_TEAM, 		
+		GT_TOURNAMENT, 		
+		GT_CTF, 		
+		GT_ELIMINATION, 	
+		GT_CTF_ELIMINATION, 	
+		GT_LMS, 		
+		GT_DOUBLE_D };		
 
+static int gametype_remap2[] = {
+		0, 
+		2, 
+		0, 
+		1, 
+		3, 
+		3,
+		3,
+		3,
+		4, 
+		5, 
+		6, 
+		7 };		//this works and should increment for more gametypes
+
 // use ui_servers2.c definition
 extern const char* punkbuster_items[];
 
@@ -112,7 +137,7 @@
 
 /*
 =================
-GametypeBits
+GametypeBits from arenas.txt + .arena files
 =================
 */
 static int GametypeBits( char *string ) {
@@ -152,8 +177,26 @@
 			bits |= 1 << GT_CTF;
 			continue;
 		}
-	}
 
+		if( Q_stricmp( token, "elimination" ) == 0 ) {
+			bits |= 1 << GT_ELIMINATION;
+			continue;
+		}
+
+		if( Q_stricmp( token, "ctfelimination" ) == 0 ) {
+			bits |= 1 << GT_CTF_ELIMINATION;
+			continue;
+		}
+
+		if( Q_stricmp( token, "lms" ) == 0 ) {
+			bits |= 1 << GT_LMS;
+			continue;
+		}
+		if( Q_stricmp( token, "dd" ) == 0 ) {
+			bits |= 1 << GT_DOUBLE_D;
+			continue;
+		}
+}
 	return bits;
 }
 
@@ -257,7 +300,7 @@
 	count = UI_GetNumArenas();
 	s_startserver.nummaps = 0;
 	matchbits = 1 << gametype_remap[s_startserver.gametype.curvalue];
-	if( gametype_remap[s_startserver.gametype.curvalue] == GT_FFA ) {
+	if( gametype_remap[s_startserver.gametype.curvalue] == GT_FFA || gametype_remap[s_startserver.gametype.curvalue] == GT_LMS ) {
 		matchbits |= ( 1 << GT_SINGLE_PLAYER );
 	}
 	for( i = 0; i < count; i++ ) {
@@ -703,7 +746,7 @@
 		if( s_serveroptions.playerType[n].curvalue != 1 ) {
 			continue;
 		}
-		if( (s_serveroptions.gametype >= GT_TEAM) &&
+		if( (s_serveroptions.gametype >= GT_TEAM) && s_serveroptions.gametype != GT_LMS &&
 			(s_serveroptions.playerTeam[n].curvalue != s_serveroptions.playerTeam[s_serveroptions.newBotIndex].curvalue ) ) {
 			continue;
 		}
@@ -776,6 +819,29 @@
 		trap_Cvar_SetValue( "ui_ctf_timelimit", timelimit );
 		trap_Cvar_SetValue( "ui_ctf_friendlt", friendlyfire );
 		break;
+
+	case GT_ELIMINATION:
+		trap_Cvar_SetValue( "ui_elimination_fraglimit", fraglimit );
+		trap_Cvar_SetValue( "ui_elimination_timelimit", timelimit );
+		trap_Cvar_SetValue( "ui_elimination_friendlt", friendlyfire );
+		break;
+
+	case GT_CTF_ELIMINATION:
+		trap_Cvar_SetValue( "ui_ctf_elimination_fraglimit", fraglimit );
+		trap_Cvar_SetValue( "ui_ctf_elimination_timelimit", timelimit );
+		trap_Cvar_SetValue( "ui_ctf_elimination_friendlt", friendlyfire );
+		break;
+
+	case GT_LMS:
+		trap_Cvar_SetValue( "ui_lms_fraglimit", fraglimit );
+		trap_Cvar_SetValue( "ui_lms_timelimit", timelimit );
+		break;
+
+	case GT_DOUBLE_D:
+		trap_Cvar_SetValue( "ui_ctf_fraglimit", fraglimit );
+		trap_Cvar_SetValue( "ui_ctf_timelimit", timelimit );
+		trap_Cvar_SetValue( "ui_ctf_friendlt", friendlyfire );
+		break;
 	}
 
 	trap_Cvar_SetValue( "sv_maxclients", Com_Clamp( 0, 12, maxclients ) );
@@ -804,7 +870,7 @@
 		if( s_serveroptions.playerNameBuffers[n][0] == '-' ) {
 			continue;
 		}
-		if( s_serveroptions.gametype >= GT_TEAM ) {
+		if( s_serveroptions.gametype >= GT_TEAM && s_serveroptions.gametype != GT_LMS ) {
 			Com_sprintf( buf, sizeof(buf), "addbot %s %i %s\n", s_serveroptions.playerNameBuffers[n], skill,
 				playerTeam_list[s_serveroptions.playerTeam[n].curvalue] );
 		}
@@ -815,7 +881,7 @@
 	}
 
 	// set player's team
-	if( dedicated == 0 && s_serveroptions.gametype >= GT_TEAM ) {
+	if( dedicated == 0 && s_serveroptions.gametype >= GT_TEAM && s_serveroptions.gametype != GT_LMS ) {
 		trap_Cmd_ExecuteText( EXEC_APPEND, va( "wait 5; team %s\n", playerTeam_list[s_serveroptions.playerTeam[0].curvalue] ) );
 	}
 }
@@ -842,7 +908,7 @@
 		s_serveroptions.playerType[n].curvalue = v;
 	}
 
-	if( s_serveroptions.multiplayer && (s_serveroptions.gametype < GT_TEAM) ) {
+	if( s_serveroptions.multiplayer && (s_serveroptions.gametype < GT_TEAM || s_serveroptions.gametype == GT_LMS ) ) {
 		for( n = 8; n < PLAYER_SLOTS; n++ ) {
 			s_serveroptions.playerType[n].curvalue = 2;
 		}
@@ -858,7 +924,7 @@
 	}
 
 	// init teams
-	if( s_serveroptions.gametype >= GT_TEAM ) {
+	if( s_serveroptions.gametype >= GT_TEAM && s_serveroptions.gametype != GT_LMS ) {
 		for( n = 0; n < (PLAYER_SLOTS / 2); n++ ) {
 			s_serveroptions.playerTeam[n].curvalue = 0;
 		}
@@ -911,7 +977,7 @@
 	}
 
 	// teams
-	if( s_serveroptions.gametype < GT_TEAM ) {
+	if( s_serveroptions.gametype < GT_TEAM || s_serveroptions.gametype == GT_LMS ) {
 		return;
 	}
 	for( n = start; n < PLAYER_SLOTS; n++ ) {
@@ -1037,11 +1103,12 @@
 	char		*bot;
 	char		bots[MAX_INFO_STRING];
 
-	if( s_serveroptions.gametype >= GT_TEAM ) {
-		Q_strncpyz( s_serveroptions.playerNameBuffers[1], "grunt", 16 );
-		Q_strncpyz( s_serveroptions.playerNameBuffers[2], "major", 16 );
+	//this SHOULD work
+	if( s_serveroptions.gametype >= GT_TEAM && s_serveroptions.gametype != GT_LMS ) {
+		Q_strncpyz( s_serveroptions.playerNameBuffers[1], "gargoyle", 16 );
+		Q_strncpyz( s_serveroptions.playerNameBuffers[2], "rai", 16 );
 		if( s_serveroptions.gametype == GT_TEAM ) {
-			Q_strncpyz( s_serveroptions.playerNameBuffers[3], "visor", 16 );
+			Q_strncpyz( s_serveroptions.playerNameBuffers[3], "grism", 16 );
 		}
 		else {
 			s_serveroptions.playerType[3].curvalue = 2;
@@ -1049,11 +1116,11 @@
 		s_serveroptions.playerType[4].curvalue = 2;
 		s_serveroptions.playerType[5].curvalue = 2;
 
-		Q_strncpyz( s_serveroptions.playerNameBuffers[6], "sarge", 16 );
-		Q_strncpyz( s_serveroptions.playerNameBuffers[7], "grunt", 16 );
-		Q_strncpyz( s_serveroptions.playerNameBuffers[8], "major", 16 );
+		Q_strncpyz( s_serveroptions.playerNameBuffers[6], "arachna", 16 );
+		Q_strncpyz( s_serveroptions.playerNameBuffers[7], "jenna", 16 );
+		Q_strncpyz( s_serveroptions.playerNameBuffers[8], "grunt", 16 );
 		if( s_serveroptions.gametype == GT_TEAM ) {
-			Q_strncpyz( s_serveroptions.playerNameBuffers[9], "visor", 16 );
+			Q_strncpyz( s_serveroptions.playerNameBuffers[9], "merman", 16 );
 		}
 		else {
 			s_serveroptions.playerType[9].curvalue = 2;
@@ -1149,6 +1216,30 @@
 		Com_sprintf( s_serveroptions.timelimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 999, trap_Cvar_VariableValue( "ui_ctf_timelimit" ) ) );
 		s_serveroptions.friendlyfire.curvalue = (int)Com_Clamp( 0, 1, trap_Cvar_VariableValue( "ui_ctf_friendly" ) );
 		break;
+
+	case GT_ELIMINATION:
+		Com_sprintf( s_serveroptions.flaglimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 999, trap_Cvar_VariableValue( "ui_elimination_capturelimit" ) ) );
+		Com_sprintf( s_serveroptions.timelimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 999, trap_Cvar_VariableValue( "ui_elimination_timelimit" ) ) );
+		s_serveroptions.friendlyfire.curvalue = (int)Com_Clamp( 0, 1, trap_Cvar_VariableValue( "ui_elimination_friendly" ) );
+		break;
+
+	case GT_CTF_ELIMINATION:
+		Com_sprintf( s_serveroptions.flaglimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 999, trap_Cvar_VariableValue( "ui_ctf_elimination_capturelimit" ) ) );
+		Com_sprintf( s_serveroptions.timelimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 999, trap_Cvar_VariableValue( "ui_ctf_elimination_timelimit" ) ) );
+		s_serveroptions.friendlyfire.curvalue = (int)Com_Clamp( 0, 1, trap_Cvar_VariableValue( "ui_ctf_elimination_friendly" ) );
+		break;
+
+	case GT_LMS:
+		Com_sprintf( s_serveroptions.fraglimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 999, trap_Cvar_VariableValue( "ui_lms_fraglimit" ) ) );
+		Com_sprintf( s_serveroptions.timelimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 999, trap_Cvar_VariableValue( "ui_lms_timelimit" ) ) );
+		break;
+
+	case GT_DOUBLE_D:
+		Com_sprintf( s_serveroptions.flaglimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 100, trap_Cvar_VariableValue( "ui_ctf_capturelimit" ) ) );
+		Com_sprintf( s_serveroptions.timelimit.field.buffer, 4, "%i", (int)Com_Clamp( 0, 999, trap_Cvar_VariableValue( "ui_ctf_timelimit" ) ) );
+		s_serveroptions.friendlyfire.curvalue = (int)Com_Clamp( 0, 1, trap_Cvar_VariableValue( "ui_ctf_friendly" ) );
+		break;
+
 	}
 
 	Q_strncpyz( s_serveroptions.hostname.field.buffer, UI_Cvar_VariableString( "sv_hostname" ), sizeof( s_serveroptions.hostname.field.buffer ) );
@@ -1231,7 +1322,8 @@
 
 	memset( &s_serveroptions, 0 ,sizeof(serveroptions_t) );
 	s_serveroptions.multiplayer = multiplayer;
-	s_serveroptions.gametype = (int)Com_Clamp( 0, 5, trap_Cvar_VariableValue( "g_gameType" ) );
+	// so the new gametypes work
+	s_serveroptions.gametype = (int)Com_Clamp( 0, GT_MAX_GAME_TYPE - 1, trap_Cvar_VariableValue( "g_gameType" ) );
 	s_serveroptions.punkbuster.curvalue = Com_Clamp( 0, 1, trap_Cvar_VariableValue( "sv_punkbuster" ) );
 
 	ServerOptions_Cache();
@@ -1264,7 +1356,7 @@
 	s_serveroptions.picframe.focuspic			= GAMESERVER_SELECT;
 
 	y = 272;
-	if( s_serveroptions.gametype != GT_CTF ) {
+	if( s_serveroptions.gametype < GT_CTF ) {
 		s_serveroptions.fraglimit.generic.type       = MTYPE_FIELD;
 		s_serveroptions.fraglimit.generic.name       = "Frag Limit:";
 		s_serveroptions.fraglimit.generic.flags      = QMF_NUMBERSONLY|QMF_PULSEIFFOCUS|QMF_SMALLFONT;
@@ -1295,7 +1387,7 @@
 	s_serveroptions.timelimit.field.widthInChars = 3;
 	s_serveroptions.timelimit.field.maxchars     = 3;
 
-	if( s_serveroptions.gametype >= GT_TEAM ) {
+	if( s_serveroptions.gametype >= GT_TEAM && s_serveroptions.gametype != GT_LMS) {
 		y += BIGCHAR_HEIGHT+2;
 		s_serveroptions.friendlyfire.generic.type     = MTYPE_RADIOBUTTON;
 		s_serveroptions.friendlyfire.generic.flags    = QMF_PULSEIFFOCUS|QMF_SMALLFONT;
@@ -1439,19 +1531,19 @@
 			Menu_AddItem( &s_serveroptions.menu, &s_serveroptions.playerType[n] );
 		}
 		Menu_AddItem( &s_serveroptions.menu, &s_serveroptions.playerName[n] );
-		if( s_serveroptions.gametype >= GT_TEAM ) {
+		if( s_serveroptions.gametype >= GT_TEAM && s_serveroptions.gametype != GT_LMS ) {
 			Menu_AddItem( &s_serveroptions.menu, &s_serveroptions.playerTeam[n] );
 		}
 	}
 
-	if( s_serveroptions.gametype != GT_CTF ) {
+	if( s_serveroptions.gametype < GT_CTF ) {
 		Menu_AddItem( &s_serveroptions.menu, &s_serveroptions.fraglimit );
 	}
 	else {
 		Menu_AddItem( &s_serveroptions.menu, &s_serveroptions.flaglimit );
 	}
 	Menu_AddItem( &s_serveroptions.menu, &s_serveroptions.timelimit );
-	if( s_serveroptions.gametype >= GT_TEAM ) {
+	if( s_serveroptions.gametype >= GT_TEAM && s_serveroptions.gametype != GT_LMS ) {
 		Menu_AddItem( &s_serveroptions.menu, &s_serveroptions.friendlyfire );
 	}
 	Menu_AddItem( &s_serveroptions.menu, &s_serveroptions.pure );
Index: code/q3_ui/ui_local.h
===================================================================
--- code/q3_ui/ui_local.h	(revision 1145)
+++ code/q3_ui/ui_local.h	(working copy)
@@ -49,6 +49,17 @@
 extern vmCvar_t	ui_ctf_timelimit;
 extern vmCvar_t	ui_ctf_friendly;
 
+extern vmCvar_t	ui_elimination_capturelimit;
+extern vmCvar_t	ui_elimination_timelimit;
+extern vmCvar_t	ui_elimination_friendly;
+
+extern vmCvar_t	ui_ctf_elimination_capturelimit;
+extern vmCvar_t	ui_ctf_elimination_timelimit;
+extern vmCvar_t	ui_ctf_elimination_friendly;
+
+extern vmCvar_t	ui_lms_fraglimit;
+extern vmCvar_t	ui_lms_timelimit;
+
 extern vmCvar_t	ui_arenasFile;
 extern vmCvar_t	ui_botsFile;
 extern vmCvar_t	ui_spScores1;
@@ -141,6 +152,10 @@
 #define QMF_UPPERCASE			0x00080000	// edit field is all upper case
 #define QMF_SILENT				0x00100000
 
+//for cgs.ffa_gt and g_ffa kinda leary about this...
+//#define FREEFORALL			(s_serveroptions.gametype==GT_LMS)
+//#define TRAP_FREEFORALL			(trap_Cvar_VariableValue( "g_gametype" ) == GT_LMS)
+
 // callback notifications
 #define QM_GOTFOCUS				1
 #define QM_LOSTFOCUS			2
Index: code/q3_ui/ui_teamorders.c
===================================================================
--- code/q3_ui/ui_teamorders.c	(revision 1145)
+++ code/q3_ui/ui_teamorders.c	(working copy)
@@ -39,6 +39,7 @@
 #define ID_LIST_BOTS		10
 #define ID_LIST_CTF_ORDERS	11
 #define ID_LIST_TEAM_ORDERS	12
+#define ID_LIST_DD_ORDERS	13
 
 
 typedef struct {
@@ -75,7 +76,7 @@
 	"i am the leader",
 	"%s defend the base",
 	"%s follow me",
-	"%s get enemy flag",
+	"%s get the enemy flag",
 	"%s camp here",
 	"%s report",
 	"i stop being the leader",
@@ -102,6 +103,29 @@
 	NULL
 };
 
+#define NUM_DD_ORDERS		8
+static const char *ddOrders[] = {
+	"I Am the Leader",
+	"Follow Me",
+	"Roam",
+	"Dominate Point A",
+	"Dominate Point B",
+	"Camp Here",
+	"Report",
+	"I Relinquish Command",
+	NULL
+};
+static const char *ddMessages[] = {
+	"i am the leader",
+	"%s follow me",
+	"%s roam",
+	"%s dominate point A",
+	"%s dominate point B",
+	"%s camp here",
+	"%s report",
+	"i stop being the leader",
+	NULL
+};
 
 /*
 ===============
@@ -141,6 +165,12 @@
 		teamOrdersMenuInfo.list.numitems = NUM_TEAM_ORDERS;
 		teamOrdersMenuInfo.list.itemnames = teamOrders;
 		break;
+
+	case ID_LIST_DD_ORDERS:
+		teamOrdersMenuInfo.list.generic.id = id;
+		teamOrdersMenuInfo.list.numitems = NUM_DD_ORDERS;
+		teamOrdersMenuInfo.list.itemnames = ddOrders;
+		break;
 	}
 
 	teamOrdersMenuInfo.list.generic.bottom = teamOrdersMenuInfo.list.generic.top + teamOrdersMenuInfo.list.numitems * PROP_HEIGHT;
@@ -264,21 +294,28 @@
 
 	if( id == ID_LIST_BOTS ) {
 		teamOrdersMenuInfo.selectedBot = selection;
-		if( teamOrdersMenuInfo.gametype == GT_CTF ) {
+		if( teamOrdersMenuInfo.gametype == GT_CTF || teamOrdersMenuInfo.gametype == GT_CTF_ELIMINATION ) {
 			UI_TeamOrdersMenu_SetList( ID_LIST_CTF_ORDERS );
 		}
-		else {
+		if( teamOrdersMenuInfo.gametype == GT_TEAM || teamOrdersMenuInfo.gametype == GT_ELIMINATION ) {
 			UI_TeamOrdersMenu_SetList( ID_LIST_TEAM_ORDERS );
 		}
+		if( teamOrdersMenuInfo.gametype == GT_DOUBLE_D ) {
+			UI_TeamOrdersMenu_SetList( ID_LIST_DD_ORDERS );
+		}
+
 		return;
 	}
 
 	if( id == ID_LIST_CTF_ORDERS ) {
 		Com_sprintf( message, sizeof(message), ctfMessages[selection], teamOrdersMenuInfo.botNames[teamOrdersMenuInfo.selectedBot] );
 	}
-	else {
+	if( id == ID_LIST_TEAM_ORDERS ) {
 		Com_sprintf( message, sizeof(message), teamMessages[selection], teamOrdersMenuInfo.botNames[teamOrdersMenuInfo.selectedBot] );
 	}
+	if( id == ID_LIST_DD_ORDERS ) {
+		Com_sprintf( message, sizeof(message), ddMessages[selection], teamOrdersMenuInfo.botNames[teamOrdersMenuInfo.selectedBot] );
+	}
 
 	trap_Cmd_ExecuteText( EXEC_APPEND, va( "say_team \"%s\"\n", message ) );
 	UI_PopMenu();
@@ -431,7 +468,7 @@
 	// make sure it's a team game
 	trap_GetConfigString( CS_SERVERINFO, info, sizeof(info) );
 	teamOrdersMenuInfo.gametype = atoi( Info_ValueForKey( info, "g_gametype" ) );
-	if( teamOrdersMenuInfo.gametype < GT_TEAM ) {
+	if( teamOrdersMenuInfo.gametype < GT_TEAM || teamOrdersMenuInfo.gametype!=GT_LMS) {
 		return;
 	}
 
Index: code/q3_ui/ui_addbots.c
===================================================================
--- code/q3_ui/ui_addbots.c	(revision 1145)
+++ code/q3_ui/ui_addbots.c	(working copy)
@@ -333,7 +333,7 @@
 	addBotsMenuInfo.team.generic.y			= y;
 	addBotsMenuInfo.team.generic.name		= "Team: ";
 	addBotsMenuInfo.team.generic.id			= ID_TEAM;
-	if( gametype >= GT_TEAM ) {
+	if( gametype >= GT_TEAM && gametype!=GT_LMS) {
 		addBotsMenuInfo.team.itemnames		= teamNames2;
 	}
 	else {
Index: code/q3_ui/ui_team.c
===================================================================
--- code/q3_ui/ui_team.c	(revision 1145)
+++ code/q3_ui/ui_team.c	(working copy)
@@ -169,6 +169,7 @@
 	switch( gametype ) {
 	case GT_SINGLE_PLAYER:
 	case GT_FFA:
+	case GT_LMS:
 	case GT_TOURNAMENT:
 		s_teammain.joinred.generic.flags  |= QMF_GRAYED;
 		s_teammain.joinblue.generic.flags |= QMF_GRAYED;
@@ -177,7 +178,10 @@
 	default:
 	case GT_TEAM:
 	case GT_CTF:
+	case GT_ELIMINATION:
+	case GT_CTF_ELIMINATION:
 		s_teammain.joingame.generic.flags |= QMF_GRAYED;
+	
 		break;
 	}
 
Index: code/q3_ui/ui_credits.c
===================================================================
--- code/q3_ui/ui_credits.c	(revision 1145)
+++ code/q3_ui/ui_credits.c	(working copy)
@@ -63,54 +63,12 @@
 	int		y;
 
 	y = 12;
-	UI_DrawProportionalString( 320, y, "id Software is:", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.42 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Programming", UI_CENTER|UI_SMALLFONT, color_white );
+	UI_DrawProportionalString( 320, y, "Thank you for playing", UI_CENTER|UI_SMALLFONT, color_white );
 	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "John Carmack, Robert A. Duffy, Jim Dose'", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.42 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Art", UI_CENTER|UI_SMALLFONT, color_white );
-	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Adrian Carmack, Kevin Cloud,", UI_CENTER|UI_SMALLFONT, color_white );
-	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Kenneth Scott, Seneca Menard, Fred Nilsson", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.42 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Game Designer", UI_CENTER|UI_SMALLFONT, color_white );
-	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Graeme Devine", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.42 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Level Design", UI_CENTER|UI_SMALLFONT, color_white );
-	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Tim Willits, Christian Antkow, Paul Jaquays", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.42 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "CEO", UI_CENTER|UI_SMALLFONT, color_white );
-	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Todd Hollenshead", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.42 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Director of Business Development", UI_CENTER|UI_SMALLFONT, color_white );
-	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Marty Stratton", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.42 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Biz Assist and id Mom", UI_CENTER|UI_SMALLFONT, color_white );
-	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Donna Jackson", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.42 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Development Assistance", UI_CENTER|UI_SMALLFONT, color_white );
-	y += PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawProportionalString( 320, y, "Eric Webb", UI_CENTER|UI_SMALLFONT, color_white );
-
-	y += 1.35 * PROP_HEIGHT * PROP_SMALL_SIZE_SCALE;
-	UI_DrawString( 320, y, "To order: 1-800-idgames     www.quake3arena.com     www.idsoftware.com", UI_CENTER|UI_SMALLFONT, color_red );
-	y += SMALLCHAR_HEIGHT;
-	UI_DrawString( 320, y, "Quake III Arena(c) 1999-2000, Id Software, Inc.  All Rights Reserved", UI_CENTER|UI_SMALLFONT, color_red );
+	UI_DrawProportionalString( 320, y, "OpenArena Expanded", UI_CENTER|UI_SMALLFONT, color_white );
+	
+	y += 28;
+	UI_DrawString( 320, y, "Click or press any key to quit", UI_CENTER|UI_SMALLFONT, color_red );
 }
 
 
Index: code/q3_ui/ui_ingame.c
===================================================================
--- code/q3_ui/ui_ingame.c	(revision 1145)
+++ code/q3_ui/ui_ingame.c	(working copy)
@@ -226,7 +226,7 @@
 	s_ingame.teamorders.string				= "TEAM ORDERS";
 	s_ingame.teamorders.color				= color_red;
 	s_ingame.teamorders.style				= UI_CENTER|UI_SMALLFONT;
-	if( !(trap_Cvar_VariableValue( "g_gametype" ) >= GT_TEAM) ) {
+	if( !(trap_Cvar_VariableValue( "g_gametype" ) >= GT_TEAM) || (trap_Cvar_VariableValue( "g_gametype" ) == GT_LMS ) ) {
 		s_ingame.teamorders.generic.flags |= QMF_GRAYED;
 	}
 	else {
Index: code/unix/unix_shared.c
===================================================================
--- code/unix/unix_shared.c	(revision 1145)
+++ code/unix/unix_shared.c	(working copy)
@@ -407,9 +407,9 @@
 	if ((p = getenv("HOME")) != NULL) {
 		Q_strncpyz(homePath, p, sizeof(homePath));
 #ifdef MACOS_X
-		Q_strcat(homePath, sizeof(homePath), "/Library/Application Support/Quake3");
+		Q_strcat(homePath, sizeof(homePath), "/Library/Application Support/OpenArena");
 #else
-		Q_strcat(homePath, sizeof(homePath), "/.q3a");
+		Q_strcat(homePath, sizeof(homePath), "/.openarena");
 #endif
 		if (mkdir(homePath, 0777)) {
 			if (errno != EEXIST) 
Index: code/win32/win_shared.c
===================================================================
--- code/win32/win_shared.c	(revision 1145)
+++ code/win32/win_shared.c	(working copy)
@@ -330,7 +330,7 @@
 		return NULL;
 	}
 	Q_strncpyz( path, szPath, sizeof(path) );
-	Q_strcat( path, sizeof(path), "\\Quake3" );
+	Q_strcat( path, sizeof(path), "\\OpenArena" );
 	FreeLibrary(shfolder);
 	if( !CreateDirectory( path, NULL ) )
 	{
Index: code/renderer/tr_local.h
===================================================================
--- code/renderer/tr_local.h	(revision 1145)
+++ code/renderer/tr_local.h	(working copy)
@@ -866,6 +866,8 @@
 	qboolean	projection2D;	// if qtrue, drawstretchpic doesn't need to change modes
 	byte		color2D[4];
 	qboolean	vertexes2D;		// shader needs to be finished
+	qboolean	doneBloom;		// done bloom this frame
+	qboolean	doneSurfaces;   // done any 3d surfaces already
 	trRefEntity_t	entity2D;	// currentEntity will point at this when doing 2D rendering
 } backEndState_t;
 
@@ -1317,6 +1319,7 @@
 
 extern	shaderCommands_t	tess;
 
+void RB_SetGL2D (void);
 void RB_BeginSurface(shader_t *shader, int fogNum );
 void RB_EndSurface(void);
 void RB_CheckOverflow( int verts, int indexes );
@@ -1669,5 +1672,8 @@
 void R_DoneFreeType( void );
 void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
 
+//Bloom Stuff
+void R_BloomInit( void );
+void R_BloomScreen( void );
 
 #endif //TR_LOCAL_H
Index: code/renderer/tr_init.c
===================================================================
--- code/renderer/tr_init.c	(revision 1145)
+++ code/renderer/tr_init.c	(working copy)
@@ -1122,6 +1122,8 @@
 
 	R_Register();
 
+	R_BloomInit();
+
 	max_polys = r_maxpolys->integer;
 	if (max_polys < MAX_POLYS)
 		max_polys = MAX_POLYS;
Index: code/renderer/tr_bloom.c
===================================================================
--- code/renderer/tr_bloom.c	(revision 0)
+++ code/renderer/tr_bloom.c	(revision 0)
@@ -0,0 +1,446 @@
+/*
+Copyright (C) 1997-2001 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+// tr_bloom.c: 2D lighting post process effect
+
+#include "tr_local.h"
+
+
+static cvar_t *r_bloom;
+static cvar_t *r_bloom_sample_size;
+static cvar_t *r_bloom_fast_sample;
+static cvar_t *r_bloom_alpha;
+static cvar_t *r_bloom_darken;
+static cvar_t *r_bloom_intensity;
+static cvar_t *r_bloom_diamond_size;
+
+/* 
+============================================================================== 
+ 
+						LIGHT BLOOMS
+ 
+============================================================================== 
+*/ 
+
+static float Diamond8x[8][8] =
+{ 
+	{ 0.0f, 0.0f, 0.0f, 0.1f, 0.1f, 0.0f, 0.0f, 0.0f, },
+	{ 0.0f, 0.0f, 0.2f, 0.3f, 0.3f, 0.2f, 0.0f, 0.0f, },
+	{ 0.0f, 0.2f, 0.4f, 0.6f, 0.6f, 0.4f, 0.2f, 0.0f, },
+	{ 0.1f, 0.3f, 0.6f, 0.9f, 0.9f, 0.6f, 0.3f, 0.1f, },
+	{ 0.1f, 0.3f, 0.6f, 0.9f, 0.9f, 0.6f, 0.3f, 0.1f, },
+	{ 0.0f, 0.2f, 0.4f, 0.6f, 0.6f, 0.4f, 0.2f, 0.0f, },
+	{ 0.0f, 0.0f, 0.2f, 0.3f, 0.3f, 0.2f, 0.0f, 0.0f, },
+	{ 0.0f, 0.0f, 0.0f, 0.1f, 0.1f, 0.0f, 0.0f, 0.0f  }
+};
+
+static float Diamond6x[6][6] =
+{ 
+	{ 0.0f, 0.0f, 0.1f, 0.1f, 0.0f, 0.0f, },
+	{ 0.0f, 0.3f, 0.5f, 0.5f, 0.3f, 0.0f, }, 
+	{ 0.1f, 0.5f, 0.9f, 0.9f, 0.5f, 0.1f, },
+	{ 0.1f, 0.5f, 0.9f, 0.9f, 0.5f, 0.1f, },
+	{ 0.0f, 0.3f, 0.5f, 0.5f, 0.3f, 0.0f, },
+	{ 0.0f, 0.0f, 0.1f, 0.1f, 0.0f, 0.0f  }
+};
+
+static float Diamond4x[4][4] =
+{  
+	{ 0.3f, 0.4f, 0.4f, 0.3f, },
+	{ 0.4f, 0.9f, 0.9f, 0.4f, },
+	{ 0.4f, 0.9f, 0.9f, 0.4f, },
+	{ 0.3f, 0.4f, 0.4f, 0.3f  }
+};
+
+static struct {
+	struct {
+		image_t	*texture;
+		int		width, height;
+		float	readW, readH;
+	} effect;
+	struct {
+		image_t	*texture;
+		int		width, height;
+		float	readW, readH;
+	} screen;
+	struct {
+		int		width, height;
+	} work;
+	qboolean started;
+} bloom;
+
+
+static void ID_INLINE R_Bloom_Quad( int width, int height, float texX, float texY, float texWidth, float texHeight ) {
+	int x = 0;
+	int y = 0;
+	x = 0;
+	y += glConfig.vidHeight - height;
+	width += x;
+	height += y;
+	
+	texWidth += texX;
+	texHeight += texY;
+
+	qglBegin( GL_QUADS );							
+	qglTexCoord2f(	texX,						texHeight	);	
+	qglVertex2f(	x,							y	);
+
+	qglTexCoord2f(	texX,						texY	);				
+	qglVertex2f(	x,							height	);	
+
+	qglTexCoord2f(	texWidth,					texY	);				
+	qglVertex2f(	width,						height	);	
+
+	qglTexCoord2f(	texWidth,					texHeight	);	
+	qglVertex2f(	width,						y	);				
+	qglEnd ();
+}
+
+
+/*
+=================
+R_Bloom_InitTextures
+=================
+*/
+static void R_Bloom_InitTextures( void )
+{
+	byte	*data;
+
+	// find closer power of 2 to screen size 
+	for (bloom.screen.width = 1;bloom.screen.width< glConfig.vidWidth;bloom.screen.width *= 2);
+	for (bloom.screen.height = 1;bloom.screen.height < glConfig.vidHeight;bloom.screen.height *= 2);
+
+	bloom.screen.readW = glConfig.vidWidth / (float)bloom.screen.width;
+	bloom.screen.readH = glConfig.vidHeight / (float)bloom.screen.height;
+
+	// find closer power of 2 to effect size 
+	bloom.work.width = r_bloom_sample_size->integer;
+	bloom.work.height = bloom.work.width * ( glConfig.vidWidth / glConfig.vidHeight );
+
+	for (bloom.effect.width = 1;bloom.effect.width < bloom.work.width;bloom.effect.width *= 2);
+	for (bloom.effect.height = 1;bloom.effect.height < bloom.work.height;bloom.effect.height *= 2);
+
+	bloom.effect.readW = bloom.work.width / (float)bloom.effect.width;
+	bloom.effect.readH = bloom.work.height / (float)bloom.effect.height;
+
+
+	// disable blooms if we can't handle a texture of that size
+	if( bloom.screen.width > glConfig.maxTextureSize ||
+		bloom.screen.height > glConfig.maxTextureSize ||
+		bloom.effect.width > glConfig.maxTextureSize ||
+		bloom.effect.height > glConfig.maxTextureSize ||
+		bloom.work.width > glConfig.vidWidth ||
+		bloom.work.height > glConfig.vidHeight
+	) {
+		ri.Cvar_Set( "r_bloom", "0" );
+		Com_Printf( S_COLOR_YELLOW"WARNING: 'R_InitBloomTextures' too high resolution for light bloom, effect disabled\n" );
+		return;
+	}
+
+	data = ri.Hunk_AllocateTempMemory( bloom.screen.width * bloom.screen.height * 4 );
+	Com_Memset( data, 0, bloom.screen.width * bloom.screen.height * 4 );
+	bloom.screen.texture = R_CreateImage( "***bloom screen texture***", data, bloom.screen.width, bloom.screen.height, qfalse, qfalse, qfalse );
+	ri.Hunk_FreeTempMemory( data );
+
+	data = ri.Hunk_AllocateTempMemory( bloom.effect.width * bloom.effect.height * 4 );
+	Com_Memset( data, 0, bloom.effect.width * bloom.effect.height * 4 );
+	bloom.effect.texture = R_CreateImage( "***bloom effect texture***", data, bloom.effect.width, bloom.effect.height, qfalse, qfalse, qfalse );
+	ri.Hunk_FreeTempMemory( data );
+	bloom.started = qtrue;
+}
+
+/*
+=================
+R_InitBloomTextures
+=================
+*/
+void R_InitBloomTextures( void )
+{
+	if( !r_bloom->integer )
+		return;
+	memset( &bloom, 0, sizeof( bloom ));
+	R_Bloom_InitTextures ();
+}
+
+/*
+=================
+R_Bloom_DrawEffect
+=================
+*/
+static void R_Bloom_DrawEffect( void )
+{
+	GL_Bind( bloom.effect.texture );
+	GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
+	qglColor4f( r_bloom_alpha->value, r_bloom_alpha->value, r_bloom_alpha->value, 1.0f );
+	R_Bloom_Quad( glConfig.vidWidth, glConfig.vidHeight, 0, 0, bloom.effect.readW, bloom.effect.readW );
+}
+
+
+/*
+=================
+R_Bloom_GeneratexDiamonds
+=================
+*/
+static void R_Bloom_WarsowEffect( void )
+{
+	int		i, j, k;
+	float	intensity, scale, *diamond;
+
+
+	qglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );
+	//Take the backup texture and downscale it
+	GL_Bind( bloom.screen.texture );
+	GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
+	R_Bloom_Quad( bloom.work.width, bloom.work.height, 0, 0, bloom.screen.readW, bloom.screen.readH );
+	//Copy downscaled framebuffer into a texture
+	GL_Bind( bloom.effect.texture );
+	qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, bloom.work.width, bloom.work.height );
+	// darkening passes with repeated filter
+	if( r_bloom_darken->integer ) {
+		int i;
+		GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO );
+
+		for( i = 0; i < r_bloom_darken->integer; i++ ) {
+			R_Bloom_Quad( bloom.work.width, bloom.work.height, 
+				0, 0, 
+				bloom.effect.readW, bloom.effect.readH );
+		}
+		qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, bloom.work.width, bloom.work.height );
+	}
+	/* Copy the result to the effect texture */
+	GL_Bind( bloom.effect.texture );
+	qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, bloom.work.width, bloom.work.height );
+
+	// bluring passes, warsow uses a repeated semi blend on a selectable diamond grid
+	qglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );
+	GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE_MINUS_SRC_COLOR );
+	if( r_bloom_diamond_size->integer > 7 || r_bloom_diamond_size->integer <= 3 ) {
+		if( r_bloom_diamond_size->integer != 8 )
+			ri.Cvar_Set( "r_bloom_diamond_size", "8" );
+	} else if( r_bloom_diamond_size->integer > 5 ) {
+		if( r_bloom_diamond_size->integer != 6 )
+			ri.Cvar_Set( "r_bloom_diamond_size", "6" );
+	} else if( r_bloom_diamond_size->integer > 3 ) {
+		if( r_bloom_diamond_size->integer != 4 )
+			ri.Cvar_Set( "r_bloom_diamond_size", "4" );
+	}
+
+	switch( r_bloom_diamond_size->integer ) {
+		case 4:
+			k = 2;
+			diamond = &Diamond4x[0][0];
+			scale = r_bloom_intensity->value * 0.8f;
+			break;
+		case 6:
+			k = 3;
+			diamond = &Diamond6x[0][0];
+			scale = r_bloom_intensity->value * 0.5f;
+			break;
+		default:
+//		case 8:
+			k = 4;
+			diamond = &Diamond8x[0][0];
+			scale = r_bloom_intensity->value * 0.3f;
+			break;
+	}
+
+	for( i = 0; i < r_bloom_diamond_size->integer; i++ ) {
+		for( j = 0; j < r_bloom_diamond_size->integer; j++, diamond++ ) {
+			float x, y;
+			intensity =  *diamond * scale;
+			if( intensity < 0.01f )
+				continue;
+			qglColor4f( intensity, intensity, intensity, 1.0 );
+			x = (i - k) * ( 2 / 640.0f ) * bloom.effect.readW;
+			y = (j - k) * ( 2 / 480.0f ) * bloom.effect.readH;
+
+			R_Bloom_Quad( bloom.work.width, bloom.work.height, x, y, bloom.effect.readW, bloom.effect.readH );
+		}
+	}
+	qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, bloom.work.width, bloom.work.height );
+}											
+
+/*
+=================
+R_Bloom_BackupScreen
+Backup the full original screen to a texture for downscaling and later restoration
+=================
+*/
+static void R_Bloom_BackupScreen( void ) {
+	GL_Bind( bloom.screen.texture );
+	qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, glConfig.vidWidth, glConfig.vidHeight );
+}
+/*
+=================
+R_Bloom_RestoreScreen
+Restore the temporary framebuffer section we used with the backup texture
+=================
+*/
+static void R_Bloom_RestoreScreen( void ) {
+	GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
+	GL_Bind( bloom.screen.texture );
+	qglColor4f( 1, 1, 1, 1 );
+	R_Bloom_Quad( bloom.work.width, bloom.work.height, 0, 0,
+		bloom.work.width / (float)bloom.screen.width,
+		bloom.work.height / (float)bloom.screen.height );
+}
+ 
+
+/*
+=================
+R_Bloom_DownsampleView
+Scale the copied screen back to the sample size used for subsequent passes
+=================
+*/
+static void R_Bloom_DownsampleView( void )
+{
+	/* TODO, Provide option to control the color strength here */
+//	qglColor4f( r_bloom_darken->value, r_bloom_darken->value, r_bloom_darken->value, 1.0f );
+	qglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );
+	GL_Bind( bloom.screen.texture );
+	GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
+	//Downscale it
+	R_Bloom_Quad( bloom.work.width, bloom.work.height, 0, 0, bloom.screen.readW, bloom.screen.readH );
+#if 1
+	GL_Bind( bloom.effect.texture );
+	qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, bloom.work.width, bloom.work.height );
+	// darkening passes
+	if( r_bloom_darken->integer ) {
+		int i;
+		GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO );
+
+		for( i = 0; i < r_bloom_darken->integer; i++ ) {
+			R_Bloom_Quad( bloom.work.width, bloom.work.height, 
+				0, 0, 
+				bloom.effect.readW, bloom.effect.readH );
+		}
+		qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, bloom.work.width, bloom.work.height );
+	}
+#endif
+	/* Copy the result to the effect texture */
+	GL_Bind( bloom.effect.texture );
+	qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, bloom.work.width, bloom.work.height );
+}
+
+static void R_Bloom_CreateEffect( void ) {
+	int dir, x;
+	int range;
+
+	//First step will zero dst, rest will one add
+	GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
+//	GL_Bind( bloom.screen.texture );
+	GL_Bind( bloom.effect.texture );
+	range = 4;
+	for (dir = 0;dir < 2;dir++)
+	{
+		// blend on at multiple vertical offsets to achieve a vertical blur
+		// TODO: do offset blends using GLSL
+		for (x = -range;x <= range;x++)
+		{
+			float xoffset, yoffset, r;
+			if (!dir){
+				xoffset = 0;
+				yoffset = x*1.5;
+			} else {
+				xoffset = x*1.5;
+				yoffset = 0;
+			}
+			xoffset /= bloom.work.width;
+			yoffset /= bloom.work.height;
+			// this r value looks like a 'dot' particle, fading sharply to
+			// black at the edges
+			// (probably not realistic but looks good enough)
+			//r = ((range*range+1)/((float)(x*x+1)))/(range*2+1);
+			//r = (dir ? 1.0f : brighten)/(range*2+1);
+			r = 2.0f /(range*2+1)*(1 - x*x/(float)(range*range));
+//			r *= r_bloom_darken->value;
+			qglColor4f(r, r, r, 1);
+			R_Bloom_Quad( bloom.work.width, bloom.work.height, 
+				xoffset, yoffset, 
+				bloom.effect.readW, bloom.effect.readH );
+//				bloom.screen.readW, bloom.screen.readH );
+			GL_State( GLS_DEPTHTEST_DISABLE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
+		}
+	}
+	GL_Bind( bloom.effect.texture );
+	qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, 0, 0, bloom.work.width, bloom.work.height );
+}
+
+/*
+=================
+R_BloomScreen
+=================
+*/
+void R_BloomScreen( void )
+{
+	if( !r_bloom->integer )
+		return;
+	if ( backEnd.doneBloom )
+		return;
+	if ( !backEnd.doneSurfaces )
+		return;
+	backEnd.doneBloom = qtrue;
+	if( !bloom.started ) {
+		R_Bloom_InitTextures();
+		if( !bloom.started )
+			return;
+	}
+
+	if ( !backEnd.projection2D )
+		RB_SetGL2D();
+#if 0
+	// set up full screen workspace
+	GL_TexEnv( GL_MODULATE );
+	qglScissor( 0, 0, glConfig.vidWidth, glConfig.vidHeight );
+	qglViewport( 0, 0, glConfig.vidWidth, glConfig.vidHeight );
+	qglMatrixMode( GL_PROJECTION );
+    qglLoadIdentity ();
+	qglOrtho( 0, glConfig.vidWidth, glConfig.vidHeight, 0, 0, 1 );
+	qglMatrixMode( GL_MODELVIEW );
+    qglLoadIdentity ();
+
+	GL_Cull( CT_TWO_SIDED );
+#endif
+
+	qglColor4f( 1, 1, 1, 1 );
+
+	//Backup the old screen in a texture
+	R_Bloom_BackupScreen();
+	// create the bloom texture using one of a few methods
+	R_Bloom_WarsowEffect ();
+//	R_Bloom_CreateEffect();
+	// restore the screen-backup to the screen
+	R_Bloom_RestoreScreen();
+	// Do the final pass using the bloom texture for the final effect
+	R_Bloom_DrawEffect ();
+}
+
+
+void R_BloomInit( void ) {
+	memset( &bloom, 0, sizeof( bloom ));
+
+	r_bloom = ri.Cvar_Get( "r_bloom", "0", CVAR_ARCHIVE );
+	r_bloom_alpha = ri.Cvar_Get( "r_bloom_alpha", "0.3", CVAR_ARCHIVE );
+	r_bloom_diamond_size = ri.Cvar_Get( "r_bloom_diamond_size", "8", CVAR_ARCHIVE );
+	r_bloom_intensity = ri.Cvar_Get( "r_bloom_intensity", "1.3", CVAR_ARCHIVE );
+	r_bloom_darken = ri.Cvar_Get( "r_bloom_darken", "4", CVAR_ARCHIVE );
+	r_bloom_sample_size = ri.Cvar_Get( "r_bloom_sample_size", "128", CVAR_ARCHIVE|CVAR_LATCH );
+	r_bloom_fast_sample = ri.Cvar_Get( "r_bloom_fast_sample", "0", CVAR_ARCHIVE|CVAR_LATCH );
+}
+
Index: code/renderer/tr_shadows.c
===================================================================
--- code/renderer/tr_shadows.c	(revision 1145)
+++ code/renderer/tr_shadows.c	(working copy)
@@ -39,7 +39,7 @@
 	int		facing;
 } edgeDef_t;
 
-#define	MAX_EDGE_DEFS	32
+#define	MAX_EDGE_DEFS	64
 
 static	edgeDef_t	edgeDefs[SHADER_MAX_VERTEXES][MAX_EDGE_DEFS];
 static	int			numEdgeDefs[SHADER_MAX_VERTEXES];
Index: code/renderer/tr_flares.c
===================================================================
--- code/renderer/tr_flares.c	(revision 1145)
+++ code/renderer/tr_flares.c	(working copy)
@@ -79,7 +79,7 @@
 	vec3_t		color;
 } flare_t;
 
-#define		MAX_FLARES		128
+#define		MAX_FLARES		256
 
 flare_t		r_flareStructs[MAX_FLARES];
 flare_t		*r_activeFlares, *r_inactiveFlares;
Index: code/renderer/tr_animation.c
===================================================================
--- code/renderer/tr_animation.c	(revision 1145)
+++ code/renderer/tr_animation.c	(working copy)
@@ -431,7 +431,8 @@
 		{
 			R_AddDrawSurf( (void *)surface, tr.projectionShadowShader, 0, qfalse );
 		}
-
+		
+		
 		if (!personalModel)
 			R_AddDrawSurf( (void *)surface, shader, fogNum, qfalse );
 
Index: code/renderer/tr_backend.c
===================================================================
--- code/renderer/tr_backend.c	(revision 1145)
+++ code/renderer/tr_backend.c	(working copy)
@@ -899,7 +899,8 @@
 
 	backEnd.refdef = cmd->refdef;
 	backEnd.viewParms = cmd->viewParms;
-
+	//TODO Maybe check for rdf_noworld stuff but q3mme has full 3d ui
+	backEnd.doneSurfaces = qtrue;
 	RB_RenderDrawSurfList( cmd->drawSurfs, cmd->numDrawSurfs );
 
 	return (const void *)(cmd + 1);
@@ -1038,7 +1039,8 @@
 	GLimp_EndFrame();
 
 	backEnd.projection2D = qfalse;
-
+	backEnd.doneBloom = qfalse;
+	backEnd.doneSurfaces = qfalse;
 	return (const void *)(cmd + 1);
 }
 
@@ -1067,6 +1069,8 @@
 			data = RB_SetColor( data );
 			break;
 		case RC_STRETCH_PIC:
+			//Check if it's time for BLOOM!
+			R_BloomScreen();
 			data = RB_StretchPic( data );
 			break;
 		case RC_DRAW_SURFS:
@@ -1076,6 +1080,8 @@
 			data = RB_DrawBuffer( data );
 			break;
 		case RC_SWAP_BUFFERS:
+			//Check if it's time for BLOOM!
+			R_BloomScreen();
 			data = RB_SwapBuffers( data );
 			break;
 		case RC_SCREENSHOT:
Index: code/server/sv_ccmds.c
===================================================================
--- code/server/sv_ccmds.c	(revision 1145)
+++ code/server/sv_ccmds.c	(working copy)
@@ -430,6 +430,12 @@
 		return;
 	}
 
+	if(strlen(AUTHORIZE_SERVER_NAME) < 1)
+	{
+		Com_Printf("Ban function disabled due to lack of authorizing server.\n");
+		return;
+	}
+
 	// look up the authorize server's IP
 	if ( !svs.authorizeAddress.ip[0] && svs.authorizeAddress.type != NA_BAD ) {
 		Com_Printf( "Resolving %s\n", AUTHORIZE_SERVER_NAME );
@@ -484,6 +490,14 @@
 		return;
 	}
 
+	if(strlen(AUTHORIZE_SERVER_NAME) < 1)
+	{
+		Com_Printf("Ban function disabled due to lack of authorizing server.\n");
+		return;
+	}
+
+
+
 	// look up the authorize server's IP
 	if ( !svs.authorizeAddress.ip[0] && svs.authorizeAddress.type != NA_BAD ) {
 		Com_Printf( "Resolving %s\n", AUTHORIZE_SERVER_NAME );
Index: code/server/sv_client.c
===================================================================
--- code/server/sv_client.c	(revision 1145)
+++ code/server/sv_client.c	(working copy)
@@ -87,7 +87,17 @@
 		NET_OutOfBandPrint( NS_SERVER, from, "challengeResponse %i", challenge->challenge );
 		return;
 	}
+	
+	// if there's no authorize server defined, just let them in
+	if(strlen(AUTHORIZE_SERVER_NAME) < 1)
+	{
+		Com_Printf("Not authorizing client due to lack of auth server\n");
+		challenge->pingTime = svs.time;
+		NET_OutOfBandPrint( NS_SERVER, from, "challengeResponse %i", challenge->challenge );
+		return;
+	}
 
+
 	// look up the authorize server's IP
 	if ( !svs.authorizeAddress.ip[0] && svs.authorizeAddress.type != NA_BAD ) {
 		Com_Printf( "Resolving %s\n", AUTHORIZE_SERVER_NAME );
Index: code/game/g_spawn.c
===================================================================
--- code/game/g_spawn.c	(revision 1145)
+++ code/game/g_spawn.c	(working copy)
@@ -129,6 +129,8 @@
 void SP_info_player_start (gentity_t *ent);
 void SP_info_player_deathmatch (gentity_t *ent);
 void SP_info_player_intermission (gentity_t *ent);
+//For Double Domination:
+void SP_info_player_dd (gentity_t *ent);
 void SP_info_firstplace(gentity_t *ent);
 void SP_info_secondplace(gentity_t *ent);
 void SP_info_thirdplace(gentity_t *ent);
@@ -199,6 +201,7 @@
 	{"info_player_start", SP_info_player_start},
 	{"info_player_deathmatch", SP_info_player_deathmatch},
 	{"info_player_intermission", SP_info_player_intermission},
+	{"info_player_dd", SP_info_player_dd},
 	{"info_null", SP_info_null},
 	{"info_notnull", SP_info_notnull},		// use target_position instead
 	{"info_camp", SP_info_camp},
Index: code/game/g_team.h
===================================================================
--- code/game/g_team.h	(revision 1145)
+++ code/game/g_team.h	(working copy)
@@ -53,6 +53,32 @@
 
 #endif
 
+#ifdef MISSIONPACK
+
+//For Double Domination:
+#define DD_POINT_DEFENCE_BONUS			10	//Score for fragging someone while either you or target are near a Domination Point
+#define DD_POINT_DEFENCE_CLOSE_BONUS		25	//Score for fragging someone while either you or target are near a Domination Point and have almost scored
+//Following is added togehter:
+#define DD_POINT_CAPTURE			5	//Score for taking a point
+#define DD_POINT_CAPTURE_BREAK			10	//If the enemy was dominating
+#define DD_POINT_CAPTURE_CLOSE			15	//Extra score if the enemy was about to score
+#define DD_AT_POINT_AT_CAPTURE			30	//You was close to a point as capture succeded.	
+
+#else
+
+//For Double Domination:
+#define DD_POINT_DEFENCE_BONUS			1	//Score for fragging someone while either you or target are near a Domination Point
+#define DD_POINT_DEFENCE_CLOSE_BONUS		2	//Score for fragging someone while either you or target are near a Domination Point and have almost scored
+//Following is added togehter:
+#define DD_POINT_CAPTURE			1	//Score for taking a point
+#define DD_POINT_CAPTURE_BREAK			1	//If the enemy was dominating
+#define DD_POINT_CAPTURE_CLOSE			1	//Extra score if the enemy was about to score
+#define DD_AT_POINT_AT_CAPTURE			1	//You was close to a point as capture succeded.	
+
+#endif
+
+#define DD_CLOSE				3	//How many seconds to score is close		
+
 #define CTF_TARGET_PROTECT_RADIUS			1000	// the radius around an object being defended where a target will be worth extra frags
 #define CTF_ATTACKER_PROTECT_RADIUS			1000	// the radius around an object being defended where an attacker will get extra frags when making kills
 
@@ -80,9 +106,19 @@
 void Team_ReturnFlag(int team);
 void Team_FreeEntity(gentity_t *ent);
 gentity_t *SelectCTFSpawnPoint ( team_t team, int teamstate, vec3_t origin, vec3_t angles );
+//For Double_D
+gentity_t *SelectDoubleDominationSpawnPoint ( vec3_t origin, vec3_t angles );
 gentity_t *Team_GetLocation(gentity_t *ent);
 qboolean Team_GetLocationMsg(gentity_t *ent, char *loc, int loclen);
 void TeamplayInfoMessage( gentity_t *ent );
 void CheckTeamStatus(void);
 
 int Pickup_Team( gentity_t *ent, gentity_t *other );
+
+//Double Domination:
+int Team_SpawnDoubleDominationPoints ( void );
+int Team_RemoveDoubleDominationPoints ( void );
+void Team_DD_bonusAtPoints(int team);
+
+//Added to make gcc happy (and because I use it in main)
+void Team_ForceGesture(int team);
Index: code/game/ai_main.h
===================================================================
--- code/game/ai_main.h	(revision 1145)
+++ code/game/ai_main.h	(working copy)
@@ -58,6 +58,9 @@
 #define LTG_ATTACKENEMYBASE			13	//attack the enemy base
 #define LTG_MAKELOVE_UNDER			14
 #define LTG_MAKELOVE_ONTOP			15
+//Long term DD goals
+#define LTG_POINTA				16	//Take/Defend point A
+#define LTG_POINTB				17	//Take/Defend point B
 //some goal dedication times
 #define TEAM_HELP_TIME				60	//1 minute teamplay help time
 #define TEAM_ACCOMPANY_TIME			600	//10 minutes teamplay accompany time
@@ -73,6 +76,9 @@
 #define CTF_RUSHBASE_TIME			120	//2 minutes ctf rush base time
 #define CTF_RETURNFLAG_TIME			180	//3 minutes to return the flag
 #define CTF_ROAM_TIME				60	//1 minute ctf roam time
+//Time for Double Domination tasks
+#define DD_POINTA				600
+#define DD_POINTB				600
 //patrol flags
 #define PATROL_LOOP					1
 #define PATROL_REVERSE				2
Index: code/game/bg_misc.c
===================================================================
--- code/game/bg_misc.c	(revision 1145)
+++ code/game/bg_misc.c	(working copy)
@@ -916,6 +916,108 @@
 	},
 #endif
 
+/*QUAKED team_DD_point
+Only in DD games
+*/
+	{
+		"team_DD_pointAblue",
+		NULL,
+        { "models/dpoints/a_blue.md3",
+		NULL, NULL, NULL },
+/* icon */		"icons/icona_blu",
+/* pickup */	"Point A (Blue)",
+		0,
+		IT_TEAM,
+		DD_POINTABLUE,
+/* precache */ "",
+/* sounds */ ""
+	},
+
+/*QUAKED team_DD_point
+Only in DD games
+*/
+	{
+		"team_DD_pointBblue",
+		NULL,
+        { "models/dpoints/b_blue.md3",
+		NULL, NULL, NULL },
+/* icon */		"icons/iconb_blu",
+/* pickup */	"Point B (Blue)",
+		0,
+		IT_TEAM,
+		DD_POINTBBLUE,
+/* precache */ "",
+/* sounds */ ""
+	},
+
+/*QUAKED team_DD_point
+Only in DD games
+*/
+	{
+		"team_DD_pointAred",
+		NULL,
+        { "models/dpoints/a_red.md3",
+		NULL, NULL, NULL },
+/* icon */		"icons/icona_red",
+/* pickup */	"Point A (Red)",
+		0,
+		IT_TEAM,
+		DD_POINTARED,
+/* precache */ "",
+/* sounds */ ""
+	},
+
+/*QUAKED team_DD_point
+Only in DD games
+*/
+	{
+		"team_DD_pointBred",
+		NULL,
+        { "models/dpoints/b_red.md3",
+		NULL, NULL, NULL },
+/* icon */		"icons/iconb_red",
+/* pickup */	"Point B (Red)",
+		0,
+		IT_TEAM,
+		DD_POINTBRED,
+/* precache */ "",
+/* sounds */ ""
+	},
+
+/*QUAKED team_DD_point
+Only in DD games
+*/
+	{
+		"team_DD_pointAwhite",
+		NULL,
+        { "models/dpoints/a_white.md3",
+		NULL, NULL, NULL },
+/* icon */		"icons/icona_white",
+/* pickup */	"Point A (White)",
+		0,
+		IT_TEAM,
+		DD_POINTAWHITE,
+/* precache */ "",
+/* sounds */ ""
+	},
+
+/*QUAKED team_DD_point
+Only in DD games
+*/
+	{
+		"team_DD_pointBwhite",
+		NULL,
+        { "models/dpoints/b_white.md3",
+		NULL, NULL, NULL },
+/* icon */		"icons/iconb_white",
+/* pickup */	"Point B (White)",
+		0,
+		IT_TEAM,
+		DD_POINTBWHITE,
+/* precache */ "",
+/* sounds */ ""
+	},
+
 	// end of list marker
 	{NULL}
 };
@@ -1108,6 +1210,11 @@
 
 #ifdef MISSIONPACK
 	case IT_PERSISTANT_POWERUP:
+
+		//In Double D we don't want persistant Powerups (or maybe, can be discussed)
+		if(gametype == GT_DOUBLE_D)
+			return qfalse;
+
 		// can only hold one item at a time
 		if ( ps->stats[STAT_PERSISTANT_POWERUP] ) {
 			return qfalse;
@@ -1142,7 +1249,7 @@
 			}
 		}
 #endif
-		if( gametype == GT_CTF ) {
+		if( gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 			// ent->modelindex2 is non-zero on items if they are dropped
 			// we need to know this because we can pick up our dropped flag (and return it)
 			// but we can't pick up our flag at base
@@ -1159,6 +1266,12 @@
 			}
 		}
 
+		if( gametype == GT_DOUBLE_D) {
+			//We can touch both flags
+			if(item->giTag == PW_BLUEFLAG || item->giTag == PW_REDFLAG)
+				return qtrue;
+		}
+
 #ifdef MISSIONPACK
 		if( gametype == GT_HARVESTER ) {
 			return qtrue;
Index: code/game/g_local.h
===================================================================
--- code/game/g_local.h	(revision 1145)
+++ code/game/g_local.h	(working copy)
@@ -252,6 +252,9 @@
 	int			voteCount;			// to prevent people from constantly calling votes
 	int			teamVoteCount;		// to prevent people from constantly calling votes
 	qboolean	teamInfo;			// send team overlay updates?
+	//elimination:
+	int		roundReached;			//Only spawn if we are new to this round
+	int		livesLeft;			//lives in LMS
 } clientPersistant_t;
 
 
@@ -323,6 +326,8 @@
 #endif
 
 	char		*areabits;
+
+	qboolean	isEliminated;			//Has been killed in this round
 };
 
 
@@ -413,6 +418,21 @@
 #ifdef MISSIONPACK
 	int			portalSequence;
 #endif
+	//Added for elimination:
+	int roundStartTime;		//time the current round was started
+	int roundNumber;			//The round number we have reached
+	int roundNumberStarted;			//1 less than roundNumber if we are allowed to spawn
+	int roundRedPlayers;			//How many players was there at start of round
+	int roundBluePlayers;			//used to find winners in a draw.
+	qboolean roundRespawned;		//We have respawned for this round!
+	int eliminationSides;			//Random, change red/blue bases
+
+	//Added for Double Domination
+	//Points get status: TEAM_FREE for not taking, TEAM_RED/TEAM_BLUE for taken and TEAM_NONE for not spawned yet
+	int pointStatusA;			//Status of the RED (A) domination point
+	int pointStatusB;			//Status of the BLUE (B) doimination point
+	int timeTaken;				//Time team started having both points
+	//use roundStartTime for telling, then the points respawn
 } level_locals_t;
 
 
@@ -569,6 +589,15 @@
 // g_client.c
 //
 team_t TeamCount( int ignoreClientNum, int team );
+team_t TeamLivingCount( int ignoreClientNum, int team ); //Elimination
+team_t TeamHealthCount( int ignoreClientNum, int team ); //Elimination
+void RespawnAll(void); //For round elimination
+void RespawnDead(void);
+void EnableWeapons(void);
+void DisableWeapons(void);
+void EndEliminationRound(void);
+void LMSpoint(void);
+//void wins2score(void);
 int TeamLeader( int team );
 team_t PickTeam( int ignoreClientNum );
 void SetClientViewAngle( gentity_t *ent, vec3_t angle );
@@ -605,12 +634,16 @@
 //
 void MoveClientToIntermission (gentity_t *client);
 void G_SetStats (gentity_t *ent);
-void DeathmatchScoreboardMessage (gentity_t *client);
 
 //
 // g_cmds.c
-//
+// Also another place /Sago
 
+void DoubleDominationScoreTimeMessage( gentity_t *ent );
+void AttackingTeamMessage( gentity_t *ent );
+void DeathmatchScoreboardMessage (gentity_t *client);
+void EliminationMessage (gentity_t *client);
+
 //
 // g_pweapon.c
 //
@@ -625,6 +658,8 @@
 void G_RunThink (gentity_t *ent);
 void QDECL G_LogPrintf( const char *fmt, ... );
 void SendScoreboardMessageToAllClients( void );
+void SendEliminationMessageToAllClients( void );
+void SendDDtimetakenMessageToAllClients( void );
 void QDECL G_Printf( const char *fmt, ... );
 void QDECL G_Error( const char *fmt, ... );
 
@@ -712,7 +747,7 @@
 extern	level_locals_t	level;
 extern	gentity_t		g_entities[MAX_GENTITIES];
 
-#define	FOFS(x) ((size_t)&(((gentity_t *)0)->x))
+#define	FOFS(x) ((int)&(((gentity_t *)0)->x))
 
 extern	vmCvar_t	g_gametype;
 extern	vmCvar_t	g_dedicated;
@@ -765,6 +800,46 @@
 extern	vmCvar_t	g_singlePlayer;
 extern	vmCvar_t	g_proxMineTimeout;
 
+//elimination:
+extern	vmCvar_t	g_elimination_selfdamage;
+extern	vmCvar_t	g_elimination_startHealth;
+extern	vmCvar_t	g_elimination_startArmor;
+extern	vmCvar_t	g_elimination_bfg;
+extern	vmCvar_t	g_elimination_roundtime;
+extern	vmCvar_t	g_elimination_warmup;
+extern	vmCvar_t	g_elimination_activewarmup;
+//more weapons in beta 9:
+extern	vmCvar_t	g_elimination_machinegun;
+extern	vmCvar_t	g_elimination_shotgun;
+extern	vmCvar_t	g_elimination_grenade;
+extern	vmCvar_t	g_elimination_rocket;
+extern	vmCvar_t	g_elimination_railgun;
+extern	vmCvar_t	g_elimination_lightning;
+extern	vmCvar_t	g_elimination_plasmagun;
+#ifdef MISSIONPACK
+extern	vmCvar_t	g_elimination_chain;
+extern	vmCvar_t	g_elimination_mine;
+extern	vmCvar_t	g_elimination_nail;
+#endif
+
+//new in elimination Beta2
+extern vmCvar_t		g_instantgib;
+extern vmCvar_t		g_vampire;
+extern vmCvar_t		g_vampireMaxHealth;
+//new in elimination Beta3
+extern vmCvar_t		g_regen;
+//Free for all gametype
+extern int		g_ffa_gt; //0 = TEAM GAME, 1 = FFA, 2 = TEAM GAME without bases
+
+//beta 5
+extern vmCvar_t		g_lms_lives;
+
+//beta 8
+extern vmCvar_t		g_lms_mode; //How do we score: 0 = One Survivor get a point, 1 = same but without overtime, 2 = one point for each player killed (+overtime), 3 = same without overtime
+
+//beta 10
+extern vmCvar_t		g_elimination_ctf_oneway;	//Only attack in one direction (level.eliminationSides+level.roundNumber)%2 == 0 red attacks
+
 void	trap_Printf( const char *fmt );
 void	trap_Error( const char *fmt );
 int		trap_Milliseconds( void );
Index: code/game/g_combat.c
===================================================================
--- code/game/g_combat.c	(revision 1145)
+++ code/game/g_combat.c	(working copy)
@@ -83,6 +83,10 @@
 	// drop the weapon if not a gauntlet or machinegun
 	weapon = self->s.weapon;
 
+	//Never drop in elimination or last man standing mode!
+	if( g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_LMS)
+		return;
+
 	// make a special check to see if they are changing to a new
 	// weapon that isn't the mg or gauntlet.  Without this, a client
 	// can pick up a weapon, be killed, and not drop the weapon because
@@ -96,6 +100,10 @@
 		}
 	}
 
+	if (g_instantgib.integer || g_gametype.integer == GT_CTF_ELIMINATION){
+	//Nothing!	
+	}
+	else
 	if ( weapon > WP_MACHINEGUN && weapon != WP_GRAPPLING_HOOK && 
 		self->client->ps.ammo[ weapon ] ) {
 		// find the item type for this weapon
@@ -363,7 +371,7 @@
 		self->client->ps.powerups[PW_BLUEFLAG] ||
 		self->client->ps.powerups[PW_NEUTRALFLAG] ) {
 		// get the goal flag this player should have been going for
-		if ( g_gametype.integer == GT_CTF ) {
+		if ( g_gametype.integer == GT_CTF || g_gametype.integer == GT_CTF_ELIMINATION) {
 			if ( self->client->sess.sessionTeam == TEAM_BLUE ) {
 				classname = "team_CTF_blueflag";
 			}
@@ -511,9 +519,11 @@
 		attacker->client->lastkilled_client = self->s.number;
 
 		if ( attacker == self || OnSameTeam (self, attacker ) ) {
-			AddScore( attacker, self->r.currentOrigin, -1 );
+			if(g_gametype.integer!=GT_LMS && !((g_gametype.integer==GT_ELIMINATION || g_gametype.integer==GT_CTF_ELIMINATION) && level.time < level.roundStartTime))
+				AddScore( attacker, self->r.currentOrigin, -1 );
 		} else {
-			AddScore( attacker, self->r.currentOrigin, 1 );
+			if(g_gametype.integer!=GT_LMS)
+				AddScore( attacker, self->r.currentOrigin, 1 );
 
 			if( meansOfDeath == MOD_GAUNTLET ) {
 				
@@ -544,7 +554,8 @@
 
 		}
 	} else {
-		AddScore( self, self->r.currentOrigin, -1 );
+		if(g_gametype.integer!=GT_LMS && !((g_gametype.integer==GT_ELIMINATION || g_gametype.integer==GT_CTF_ELIMINATION) && level.time < level.roundStartTime))
+			AddScore( self, self->r.currentOrigin, -1 );
 	}
 
 	// Add team bonuses
@@ -626,6 +637,11 @@
 	// don't allow respawn until the death anim is done
 	// g_forcerespawn may force spawning at some later time
 	self->client->respawnTime = level.time + 1700;
+	//However during warm up, we should respawn quicker!
+	if(g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_LMS)
+		if(level.time<=level.roundStartTime && level.time>level.roundStartTime-1000*g_elimination_activewarmup.integer)
+			self->client->respawnTime = level.time + rand()%800;
+		
 
 	// remove powerups
 	memset( self->client->ps.powerups, 0, sizeof(self->client->ps.powerups) );
@@ -942,7 +958,7 @@
 #else	
 		if ( targ != attacker && OnSameTeam (targ, attacker)  ) {
 #endif
-			if ( !g_friendlyFire.integer ) {
+			if ( ( !g_friendlyFire.integer && g_gametype.integer != GT_ELIMINATION && g_gametype.integer != GT_CTF_ELIMINATION ) || ( g_elimination_selfdamage.integer<2 &&	(g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION) ) ) {
 				return;
 			}
 		}
@@ -994,6 +1010,19 @@
 	if ( damage < 1 ) {
 		damage = 1;
 	}
+
+	if ((g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_LMS) 
+				&& g_elimination_selfdamage.integer<1 && ( targ == attacker ||  mod == MOD_FALLING )) {
+		damage = 0;
+	}
+
+
+//So people can be telefragged!
+	if ((g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_LMS) && level.time < level.roundStartTime && ((mod == MOD_LAVA) || (mod == MOD_SLIME)) ) {
+		damage = 1000;
+	}
+
+
 	take = damage;
 	save = 0;
 
@@ -1029,9 +1058,9 @@
 
 	// See if it's the player hurting the emeny flag carrier
 #ifdef MISSIONPACK
-	if( g_gametype.integer == GT_CTF || g_gametype.integer == GT_1FCTF ) {
+	if( g_gametype.integer == GT_CTF || g_gametype.integer == GT_1FCTF || g_gametype.integer == GT_CTF_ELIMINATION) {
 #else	
-	if( g_gametype.integer == GT_CTF) {
+	if( g_gametype.integer == GT_CTF || g_gametype.integer == GT_CTF_ELIMINATION) {
 #endif
 		Team_CheckHurtCarrier(targ, attacker);
 	}
@@ -1042,6 +1071,17 @@
 		targ->client->lasthurt_mod = mod;
 	}
 
+	//If vampire is enabled, gain health but not from self or teammate, cannot steal more than targ has
+	if((targ != attacker) && !(OnSameTeam(targ, attacker)) && g_vampire.value>0.0)
+	{
+		if(take<targ->health)
+			attacker->health += (int)(((float)take)*g_vampire.value);
+		else
+			attacker->health += (int)(((float)targ->health)*g_vampire.value);
+		if(attacker->health>g_vampireMaxHealth.integer)
+			attacker->health = g_vampireMaxHealth.integer;
+	}
+
 	// do the damage
 	if (take) {
 		targ->health = targ->health - take;
@@ -1064,6 +1104,7 @@
 		}
 	}
 
+	
 }
 
 
Index: code/game/ai_cmd.c
===================================================================
--- code/game/ai_cmd.c	(revision 1145)
+++ code/game/ai_cmd.c	(working copy)
@@ -129,11 +129,24 @@
 			BotAI_Print(PRT_MESSAGE, "%s: I'm gonna camp for %1.0f secs\n", netname, t);
 			break;
 		}
-		case LTG_PATROL:
+		case LTG_PATROL:type "dd_start_pointb"
+{
+"I'll dominate point B";
+}
 		{
 			BotAI_Print(PRT_MESSAGE, "%s: I'm gonna patrol for %1.0f secs\n", netname, t);
 			break;
 		}
+		case LTG_POINTA:
+		{
+			BotAI_Print(PRT_MESSAGE, "%s: I'm gonna take care of point A for %1.0f secs\n", netname, t);
+			break;
+		}
+		case LTG_POINTB:
+		{
+			BotAI_Print(PRT_MESSAGE, "%s: I'm gonna take care of point B for %1.0f secs\n", netname, t);
+			break;
+		}
 		default:
 		{
 			if (bs->ctfroam_time > FloatTime()) {
@@ -652,6 +665,104 @@
 
 /*
 ==================
+BotMatch_TakeA
+For Double Domination
+==================
+*/
+void BotMatch_TakeA(bot_state_t *bs, bot_match_t *match) {
+// 	char itemname[MAX_MESSAGE_SIZE];
+	char netname[MAX_MESSAGE_SIZE];
+	int client;
+
+	if (!TeamPlayIsOn()) return;
+	//if not addressed to this bot
+	if (!BotAddressedToBot(bs, match)) return;
+	//get the match variable
+	/*trap_BotMatchVariable(match, KEYAREA, itemname, sizeof(itemname));
+	//
+	if (!BotGetMessageTeamGoal(bs, itemname, &bs->teamgoal)) {
+		//BotAI_BotInitialChat(bs, "cannotfind", itemname, NULL);
+		//trap_BotEnterChat(bs->cs, bs->client, CHAT_TEAM);
+		return;
+	}*/
+	//
+	trap_BotMatchVariable(match, NETNAME, netname, sizeof(netname));
+	//
+	client = ClientFromName(netname);
+	//the team mate who ordered
+	bs->decisionmaker = client;
+	bs->ordered = qtrue;
+	bs->order_time = FloatTime();
+	//set the time to send a message to the team mates
+	bs->teammessage_time = FloatTime() + 2 * random();
+	//set the ltg type
+	bs->ltgtype = LTG_POINTA;
+	//get the team goal time
+	bs->teamgoal_time = BotGetTime(match);
+	//set the team goal time
+	if (!bs->teamgoal_time) bs->teamgoal_time = FloatTime() + DD_POINTA;
+	//away from defending
+	bs->defendaway_time = 0;
+	//
+	BotSetTeamStatus(bs);
+	// remember last ordered task
+	BotRememberLastOrderedTask(bs);
+#ifdef DEBUG
+	BotPrintTeamGoal(bs);
+#endif //DEBUG
+}
+
+/*
+==================
+BotMatch_TakeA
+For Double Domination
+==================
+*/
+void BotMatch_TakeB(bot_state_t *bs, bot_match_t *match) {
+// 	char itemname[MAX_MESSAGE_SIZE];
+	char netname[MAX_MESSAGE_SIZE];
+	int client;
+
+	if (!TeamPlayIsOn()) return;
+	//if not addressed to this bot
+	if (!BotAddressedToBot(bs, match)) return;
+	//get the match variable
+	/*trap_BotMatchVariable(match, KEYAREA, itemname, sizeof(itemname));
+	//
+	if (!BotGetMessageTeamGoal(bs, itemname, &bs->teamgoal)) {
+		//BotAI_BotInitialChat(bs, "cannotfind", itemname, NULL);
+		//trap_BotEnterChat(bs->cs, bs->client, CHAT_TEAM);
+		//return;
+	}*/
+	//
+	trap_BotMatchVariable(match, NETNAME, netname, sizeof(netname));
+	//
+	client = ClientFromName(netname);
+	//the team mate who ordered
+	bs->decisionmaker = client;
+	bs->ordered = qtrue;
+	bs->order_time = FloatTime();
+	//set the time to send a message to the team mates
+	bs->teammessage_time = FloatTime() + 2 * random();
+	//set the ltg type
+	bs->ltgtype = LTG_POINTB;
+	//get the team goal time
+	bs->teamgoal_time = BotGetTime(match);
+	//set the team goal time
+	if (!bs->teamgoal_time) bs->teamgoal_time = FloatTime() + DD_POINTA;
+	//away from defending
+	bs->defendaway_time = 0;
+	//
+	BotSetTeamStatus(bs);
+	// remember last ordered task
+	BotRememberLastOrderedTask(bs);
+#ifdef DEBUG
+	BotPrintTeamGoal(bs);
+#endif //DEBUG
+}
+
+/*
+==================
 BotMatch_GetItem
 ==================
 */
@@ -830,7 +941,7 @@
 	char netname[MAX_MESSAGE_SIZE];
 	int client;
 
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		if (!ctf_redflag.areanum || !ctf_blueflag.areanum)
 			return;
 	}
@@ -860,7 +971,7 @@
 	//set the team goal time
 	bs->teamgoal_time = FloatTime() + CTF_GETFLAG_TIME;
 	// get an alternate route in ctf
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		//get an alternative route goal towards the enemy base
 		BotGetAlternateRouteGoal(bs, BotOppositeTeam(bs));
 	}
@@ -882,7 +993,7 @@
 	char netname[MAX_MESSAGE_SIZE];
 	int client;
 
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF|| gametype == GT_CTF_ELIMINATION) {
 		BotMatch_GetFlag(bs, match);
 	}
 #ifdef MISSIONPACK
@@ -973,7 +1084,7 @@
 	char netname[MAX_MESSAGE_SIZE];
 	int client;
 
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF|| gametype == GT_CTF_ELIMINATION) {
 		if (!ctf_redflag.areanum || !ctf_blueflag.areanum)
 			return;
 	}
@@ -1068,7 +1179,7 @@
 
 	//if not in CTF mode
 	if (
-		gametype != GT_CTF
+		gametype != GT_CTF && gametype != GT_CTF_ELIMINATION
 #ifdef MISSIONPACK
 		&& gametype != GT_1FCTF
 #endif
@@ -1308,7 +1419,7 @@
 		//get the team mate that will be the team leader
 		trap_BotMatchVariable(match, NETNAME, teammate, sizeof(teammate));
 		strncpy(bs->teamleader, teammate, sizeof(bs->teamleader));
-		bs->teamleader[sizeof(bs->teamleader)-1] = '\0';
+		bs->teamleader[sizeof(bs->teamleader)] = '\0';
 	}
 	//chats for someone else
 	else {
@@ -1448,6 +1559,16 @@
 			break;
 		}
 #endif
+		case LTG_POINTA:
+		{
+			BotAI_BotInitialChat(bs, "dd_pointa", NULL);
+			break;
+		}
+		case LTG_POINTB:
+		{
+			BotAI_BotInitialChat(bs, "dd_pointb", NULL);
+			break;
+		}
 		default:
 		{
 			BotAI_BotInitialChat(bs, "roaming", NULL);
@@ -1567,7 +1688,7 @@
 		}
 	}
 	if (bestitem != -1) {
-		if (gametype == GT_CTF
+		if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION
 #ifdef MISSIONPACK
 			|| gametype == GT_1FCTF
 #endif
@@ -1724,7 +1845,7 @@
 
 	char flag[128], netname[MAX_NETNAME];
 
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		trap_BotMatchVariable(match, FLAG, flag, sizeof(flag));
 		if (match->subtype & ST_GOTFLAG) {
 			if (!Q_stricmp(flag, "red")) {
@@ -1982,6 +2103,16 @@
 			BotMatch_Suicide(bs, &match);
 			break;
 		}
+		case MSG_TAKEA:
+		{
+			BotMatch_TakeA(bs, &match);
+			break;
+		}
+		case MSG_TAKEB:
+		{
+			BotMatch_TakeB(bs, &match);
+			break;
+		}
 		default:
 		{
 			BotAI_Print(PRT_MESSAGE, "unknown match type\n");
Index: code/game/g_arenas.c
===================================================================
--- code/game/g_arenas.c	(revision 1145)
+++ code/game/g_arenas.c	(working copy)
@@ -85,7 +85,7 @@
 		}
 #ifdef MISSIONPACK
 		won = qfalse;
-		if (g_gametype.integer >= GT_CTF) {
+		if (g_gametype.integer >= GT_CTF && g_ffa_gt==0) {
 			score1 = level.teamScores[TEAM_RED];
 			score2 = level.teamScores[TEAM_BLUE];
 			if (level.clients[playerClientNum].sess.sessionTeam	== TEAM_RED) {
Index: code/game/ai_dmnet.c
===================================================================
--- code/game/ai_dmnet.c	(revision 1145)
+++ code/game/ai_dmnet.c	(working copy)
@@ -525,6 +525,59 @@
 			bs->defendaway_time = 0;
 		}
 	}
+	//For double domination
+	if (bs->ltgtype == LTG_POINTA &&
+				bs->defendaway_time < FloatTime()) {
+		//check for bot typing status message
+		if (bs->teammessage_time && bs->teammessage_time < FloatTime()) {
+			trap_BotGoalName(bs->teamgoal.number, buf, sizeof(buf));
+			BotAI_BotInitialChat(bs, "dd_start_pointa", buf, NULL);
+			trap_BotEnterChat(bs->cs, 0, CHAT_TEAM);
+			//BotVoiceChatOnly(bs, -1, VOICECHAT_ONDEFENSE);
+			bs->teammessage_time = 0;
+		}
+		//set the bot goal
+		memcpy(goal, &ctf_redflag, sizeof(bot_goal_t));
+		//if very close... go away for some time
+		VectorSubtract(goal->origin, bs->origin, dir);
+		if (VectorLengthSquared(dir) < Square(70)) {
+			trap_BotResetAvoidReach(bs->ms);
+			bs->defendaway_time = FloatTime() + 3 + 3 * random();
+			if (BotHasPersistantPowerupAndWeapon(bs)) {
+				bs->defendaway_range = 100;
+			}
+			else {
+				bs->defendaway_range = 350;
+			}
+		}
+		return qtrue;
+	}
+	if (bs->ltgtype == LTG_POINTB &&
+				bs->defendaway_time < FloatTime()) {
+		//check for bot typing status message
+		if (bs->teammessage_time && bs->teammessage_time < FloatTime()) {
+			trap_BotGoalName(bs->teamgoal.number, buf, sizeof(buf));
+			BotAI_BotInitialChat(bs, "dd_start_pointb", buf, NULL);
+			trap_BotEnterChat(bs->cs, 0, CHAT_TEAM);
+			//BotVoiceChatOnly(bs, -1, VOICECHAT_ONDEFENSE);
+			bs->teammessage_time = 0;
+		}
+		//set the bot goal
+		memcpy(goal, &ctf_blueflag, sizeof(bot_goal_t));
+		//if very close... go away for some time
+		VectorSubtract(goal->origin, bs->origin, dir);
+		if (VectorLengthSquared(dir) < Square(70)) {
+			trap_BotResetAvoidReach(bs->ms);
+			bs->defendaway_time = FloatTime() + 3 + 3 * random();
+			if (BotHasPersistantPowerupAndWeapon(bs)) {
+				bs->defendaway_range = 100;
+			}
+			else {
+				bs->defendaway_range = 350;
+			}
+		}
+		return qtrue;
+	}
 	//if defending a key area
 	if (bs->ltgtype == LTG_DEFENDKEYAREA && !retreat &&
 				bs->defendaway_time < FloatTime()) {
@@ -748,7 +801,7 @@
 		return qtrue;
 	}
 #ifdef CTF
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		//if going for enemy flag
 		if (bs->ltgtype == LTG_GETFLAG) {
 			//check for bot typing status message
@@ -1872,7 +1925,7 @@
 		else range = 150;
 		//
 #ifdef CTF
-		if (gametype == GT_CTF) {
+		if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 			//if carrying a flag the bot shouldn't be distracted too much
 			if (BotCTFCarryingFlag(bs))
 				range = 50;
@@ -2391,7 +2444,7 @@
 		bs->check_time = FloatTime() + 1;
 		range = 150;
 #ifdef CTF
-		if (gametype == GT_CTF) {
+		if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 			//if carrying a flag the bot shouldn't be distracted too much
 			if (BotCTFCarryingFlag(bs))
 				range = 50;
Index: code/game/g_active.c
===================================================================
--- code/game/g_active.c	(revision 1145)
+++ code/game/g_active.c	(working copy)
@@ -254,8 +254,9 @@
 		return;
 	}
 
-	// dead clients don't activate triggers!
-	if ( ent->client->ps.stats[STAT_HEALTH] <= 0 ) {
+	//ELIMINATION LMS
+	// dead clients don't activate triggers! The reason our pm_spectators can't do anything
+	if ( ent->client->ps.stats[STAT_HEALTH] <= 0 && ent->client->ps.pm_type != PM_SPECTATOR) {
 		return;
 	}
 
@@ -279,11 +280,12 @@
 		}
 
 		// ignore most entities if a spectator
-		if ( ent->client->sess.sessionTeam == TEAM_SPECTATOR ) {
+		if ( (ent->client->sess.sessionTeam == TEAM_SPECTATOR) || ent->client->ps.pm_type == PM_SPECTATOR ) {
 			if ( hit->s.eType != ET_TELEPORT_TRIGGER &&
 				// this is ugly but adding a new ET_? type will
 				// most likely cause network incompatibilities
-				hit->touch != Touch_DoorTrigger) {
+				//We need to stop eliminated players from opening doors somewhere else /Sago007 20070814
+				hit->touch != Touch_DoorTrigger ) {
 				continue;
 			}
 		}
@@ -350,6 +352,11 @@
 		trap_UnlinkEntity( ent );
 	}
 
+	/* Stopped players from going into follow mode in B5, should be fixed in B9
+	if(ent->client->sess.sessionTeam != TEAM_SPECTATOR && g_gametype.integer>=GT_ELIMINATION && g_gametype.integer<=GT_LMS)
+		return;
+	*/
+	
 	client->oldbuttons = client->buttons;
 	client->buttons = ucmd->buttons;
 
@@ -357,6 +364,14 @@
 	if ( ( client->buttons & BUTTON_ATTACK ) && ! ( client->oldbuttons & BUTTON_ATTACK ) ) {
 		Cmd_FollowCycle_f( ent, 1 );
 	}
+
+	if ( ( client->buttons & BUTTON_USE_HOLDABLE ) && ! ( client->oldbuttons & BUTTON_USE_HOLDABLE ) ) {
+		//Cmd_FollowCycle_f( ent, 1 );
+		//client->sess.spectatorState = SPECTATOR_FREE;
+		StopFollowing(ent);
+		//ent->client->ps.stats[STAT_HEALTH] = 0;
+		//ClientBegin( ent->client - level.clients );
+	}
 }
 
 
@@ -412,6 +427,10 @@
 	while ( client->timeResidual >= 1000 ) {
 		client->timeResidual -= 1000;
 
+		//Stop in elimination!!!
+		if (client->ps.pm_flags & PMF_ELIMWARMUP)
+			continue;
+
 		// regenerate
 #ifdef MISSIONPACK
 		if( bg_itemlist[client->ps.stats[STAT_PERSISTANT_POWERUP]].giTag == PW_GUARD ) {
@@ -458,6 +477,18 @@
 			if ( ent->health > client->ps.stats[STAT_MAX_HEALTH] ) {
 				ent->health--;
 			}
+			//Start killing players in LMS, if we are in overtime
+			if(g_gametype.integer==GT_LMS && TeamHealthCount( -1, TEAM_FREE ) != ent->health &&(level.roundNumber==level.roundNumberStarted)&&(level.time>=level.roundStartTime+1000*g_elimination_roundtime.integer)) {
+				ent->damage=5;
+				G_Damage (ent, NULL, NULL, NULL, NULL, 
+					ent->damage, DAMAGE_NO_ARMOR, MOD_UNKNOWN);
+			}
+			else
+			if ( ent->health < client->ps.stats[STAT_MAX_HEALTH] ) {
+				ent->health+=g_regen.integer;
+				if(ent->health>client->ps.stats[STAT_MAX_HEALTH])
+					ent->health= client->ps.stats[STAT_MAX_HEALTH];
+			}
 		}
 
 		// count down armor when over max
@@ -811,7 +842,7 @@
 	}
 
 	// spectators don't do much
-	if ( client->sess.sessionTeam == TEAM_SPECTATOR ) {
+	if ( (client->sess.sessionTeam == TEAM_SPECTATOR) || client->isEliminated ) {
 		if ( client->sess.spectatorState == SPECTATOR_SCOREBOARD ) {
 			return;
 		}
@@ -997,18 +1028,20 @@
 	// check for respawning
 	if ( client->ps.stats[STAT_HEALTH] <= 0 ) {
 		// wait for the attack button to be pressed
-		if ( level.time > client->respawnTime ) {
-			// forcerespawn is to prevent users from waiting out powerups
-			if ( g_forcerespawn.integer > 0 && 
-				( level.time - client->respawnTime ) > g_forcerespawn.integer * 1000 ) {
-				respawn( ent );
-				return;
-			}
-		
-			// pressing attack or use is the normal respawn method
-			if ( ucmd->buttons & ( BUTTON_ATTACK | BUTTON_USE_HOLDABLE ) ) {
-				respawn( ent );
-			}
+		// forcerespawn is to prevent users from waiting out powerups
+		// In Last man standing, we force a quick respawn, since
+		// the player must be able to loose health
+		// pressing attack or use is the normal respawn method
+		if ( ( level.time > client->respawnTime ) &&
+			( ( ( g_forcerespawn.integer > 0 ) && 
+			( level.time - client->respawnTime  > g_forcerespawn.integer * 1000 ) ) ||
+			( ( ( g_gametype.integer == GT_LMS ) ||
+			( g_gametype.integer == GT_ELIMINATION ) ||
+			( g_gametype.integer == GT_CTF_ELIMINATION ) ) &&
+			( level.time - client->respawnTime > 0 ) ) ||	
+			( ucmd->buttons & ( BUTTON_ATTACK | BUTTON_USE_HOLDABLE ) ) ) ) {
+
+			respawn( ent );
 		}
 		return;
 	}
@@ -1057,6 +1090,7 @@
 */
 void SpectatorClientEndFrame( gentity_t *ent ) {
 	gclient_t	*cl;
+	int i, preservedScore[MAX_PERSISTANT]; //for keeping in elimination
 
 	// if we are doing a chase cam or a remote view, grab the latest info
 	if ( ent->client->sess.spectatorState == SPECTATOR_FOLLOW ) {
@@ -1074,7 +1108,16 @@
 			cl = &level.clients[ clientNum ];
 			if ( cl->pers.connected == CON_CONNECTED && cl->sess.sessionTeam != TEAM_SPECTATOR ) {
 				flags = (cl->ps.eFlags & ~(EF_VOTED | EF_TEAMVOTED)) | (ent->client->ps.eFlags & (EF_VOTED | EF_TEAMVOTED));
-				ent->client->ps = cl->ps;
+				//this is here LMS/Elimination goes wrong with player follow
+				if(ent->client->sess.sessionTeam!=TEAM_SPECTATOR){
+					for(i = 0; i < MAX_PERSISTANT; i++)
+						preservedScore[i] = ent->client->ps.persistant[i];
+					ent->client->ps = cl->ps;
+					for(i = 0; i < MAX_PERSISTANT; i++)
+						ent->client->ps.persistant[i] = preservedScore[i];
+				}
+				else
+					ent->client->ps = cl->ps;
 				ent->client->ps.pm_flags |= PMF_FOLLOW;
 				ent->client->ps.eFlags = flags;
 				return;
@@ -1086,6 +1129,9 @@
 				}
 			}
 		}
+	
+		
+			
 	}
 
 	if ( ent->client->sess.spectatorState == SPECTATOR_SCOREBOARD ) {
@@ -1108,7 +1154,7 @@
 	int			i;
 	clientPersistant_t	*pers;
 
-	if ( ent->client->sess.sessionTeam == TEAM_SPECTATOR ) {
+	if ( (ent->client->sess.sessionTeam == TEAM_SPECTATOR) || ent->client->isEliminated ) {
 		SpectatorClientEndFrame( ent );
 		return;
 	}
Index: code/game/g_rankings.c
===================================================================
--- code/game/g_rankings.c	(revision 1145)
+++ code/game/g_rankings.c	(working copy)
@@ -104,7 +104,7 @@
 				}
 				break;
 			case QGR_STATUS_ACTIVE:
-				if( (ent->client->sess.sessionTeam == TEAM_SPECTATOR) &&
+				if( (ent->client->sess.sessionTeam == TEAM_SPECTATOR || (client->isEliminated)) &&
 					(g_gametype.integer < GT_TEAM) )
 				{
 					SetTeam( ent, "free" );
Index: code/game/g_session.c
===================================================================
--- code/game/g_session.c	(revision 1145)
+++ code/game/g_session.c	(working copy)
@@ -109,7 +109,7 @@
 	sess = &client->sess;
 
 	// initial team determination
-	if ( g_gametype.integer >= GT_TEAM ) {
+	if ( g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		if ( g_teamAutoJoin.integer ) {
 			sess->sessionTeam = PickTeam( -1 );
 			BroadcastTeamChange( client, -1 );
@@ -126,6 +126,7 @@
 			switch ( g_gametype.integer ) {
 			default:
 			case GT_FFA:
+			case GT_LMS:
 			case GT_SINGLE_PLAYER:
 				if ( g_maxGameClients.integer > 0 && 
 					level.numNonSpectatorClients >= g_maxGameClients.integer ) {
Index: code/game/g_bot.c
===================================================================
--- code/game/g_bot.c	(revision 1145)
+++ code/game/g_bot.c	(working copy)
@@ -406,7 +406,7 @@
 	minplayers = bot_minplayers.integer;
 	if (minplayers <= 0) return;
 
-	if (g_gametype.integer >= GT_TEAM) {
+	if (g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		if (minplayers >= g_maxclients.integer / 2) {
 			minplayers = (g_maxclients.integer / 2) -1;
 		}
@@ -446,7 +446,7 @@
 			}
 		}
 	}
-	else if (g_gametype.integer == GT_FFA) {
+	else if (g_gametype.integer == GT_FFA || g_gametype.integer == GT_LMS) {
 		if (minplayers >= g_maxclients.integer) {
 			minplayers = g_maxclients.integer-1;
 		}
@@ -659,7 +659,7 @@
 
 	// initialize the bot settings
 	if( !team || !*team ) {
-		if( g_gametype.integer >= GT_TEAM ) {
+		if( g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 			if( PickTeam(clientNum) == TEAM_RED) {
 				team = "red";
 			}
Index: code/game/g_main.c
===================================================================
--- code/game/g_main.c	(revision 1145)
+++ code/game/g_main.c	(working copy)
@@ -94,7 +94,44 @@
 vmCvar_t	g_enableBreath;
 vmCvar_t	g_proxMineTimeout;
 #endif
+//Following for elimination:
+vmCvar_t	g_elimination_selfdamage;
+vmCvar_t	g_elimination_startHealth;
+vmCvar_t	g_elimination_startArmor;
+vmCvar_t	g_elimination_bfg;
+vmCvar_t	g_elimination_roundtime;
+vmCvar_t	g_elimination_warmup;
+vmCvar_t	g_elimination_activewarmup;
+//more weapons in beta 9:
+vmCvar_t	g_elimination_machinegun;
+vmCvar_t	g_elimination_shotgun;
+vmCvar_t	g_elimination_grenade;
+vmCvar_t	g_elimination_rocket;
+vmCvar_t	g_elimination_railgun;
+vmCvar_t	g_elimination_lightning;
+vmCvar_t	g_elimination_plasmagun;
+#ifdef MISSIONPACK
+vmCvar_t	g_elimination_chain;
+vmCvar_t	g_elimination_mine;
+vmCvar_t	g_elimination_nail;
+#endif
+//dmn_clowns suggestions (with my idea of implementing):
+vmCvar_t	g_instantgib;
+vmCvar_t	g_vampire;
+vmCvar_t	g_vampireMaxHealth;
+//Regen
+vmCvar_t	g_regen;
+//Beta 4
+int	g_ffa_gt; //Are this a FFA gametype even if gametype is high?
+//beta 5
+vmCvar_t	g_lms_lives;
 
+//beta 8
+vmCvar_t	g_lms_mode;
+
+//beta 10
+vmCvar_t	g_elimination_ctf_oneway;
+
 // bk001129 - made static to avoid aliasing
 static cvarTable_t		gameCvarTable[] = {
 	// don't override the cheat state set by the system
@@ -178,8 +215,40 @@
 	{ &pmove_fixed, "pmove_fixed", "0", CVAR_SYSTEMINFO, 0, qfalse},
 	{ &pmove_msec, "pmove_msec", "8", CVAR_SYSTEMINFO, 0, qfalse},
 
-	{ &g_rankings, "g_rankings", "0", 0, 0, qfalse}
+	{ &g_rankings, "g_rankings", "0", 0, 0, qfalse},
+	//Now for elimination stuff:
+	{ &g_elimination_selfdamage, "elimination_selfdamage", "0", 0, 0, qtrue },
+	{ &g_elimination_startHealth, "elimination_startHealth", "200", CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_startArmor, "elimination_startArmor", "200", CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_bfg, "elimination_bfg", "0", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_roundtime, "elimination_roundtime", "120", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_warmup, "elimination_warmup", "7", 0, 0, qtrue },
+	{ &g_elimination_activewarmup, "elimination_activewarmup", "5", 0, 0, qtrue },
+//more weapons in beta 9:
+	{ &g_elimination_machinegun, "elimination_machinegun", "200", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_shotgun, "elimination_shotgun", "200", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_grenade, "elimination_grenade", "200", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_rocket, "elimination_rocket", "200", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_railgun, "elimination_railgun", "200", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_lightning, "elimination_lightning", "200", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_plasmagun, "elimination_plasmagun", "200", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+#ifdef MISSIONPACK
+	{ &g_elimination_chain, "elimination_chain", "0", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_mine, "elimination_mine", "0", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+	{ &g_elimination_nail, "elimination_nail", "0", CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
+#endif
+	//Beta 10
+	{ &g_elimination_ctf_oneway, "elimination_ctf_oneway", "0", CVAR_SERVERINFO | CVAR_ARCHIVE| CVAR_NORESTART, 0, qtrue },
 
+	//Instantgib and Vampire thingies
+	{ &g_instantgib, "g_instantgib", "0", CVAR_SERVERINFO | CVAR_LATCH | CVAR_NORESTART, 0, qfalse },
+	{ &g_vampire, "g_vampire", "0.0", CVAR_NORESTART, 0, qfalse },
+	{ &g_regen, "g_regen", "0", CVAR_NORESTART, 0, qfalse },
+	{ &g_vampireMaxHealth, "g_vampire_max_health", "500", CVAR_NORESTART, 0, qtrue },
+	//beta 5
+	{ &g_lms_lives, "g_lms_lives", "1", CVAR_NORESTART, 0, qtrue },
+	//beta 8
+	{ &g_lms_mode, "g_lms_mode", "0", CVAR_ARCHIVE | CVAR_SERVERINFO | CVAR_NORESTART, 0, qtrue },
 };
 
 // bk001129 - made static to avoid aliasing
@@ -362,6 +431,13 @@
 		trap_Cvar_Set( "g_gametype", "0" );
 	}
 
+	//set FFA status for high gametypes:
+	if ( g_gametype.integer == GT_LMS ) {
+		g_ffa_gt = 1;	//Last Man standig is a FFA gametype
+	} else {
+		g_ffa_gt = 0;	//If >GT_CTF use bases
+	}
+
 	level.warmupModificationCount = g_warmup.modificationCount;
 }
 
@@ -484,7 +560,7 @@
 	G_FindTeams();
 
 	// make sure we have flags for CTF, etc
-	if( g_gametype.integer >= GT_TEAM ) {
+	if( g_gametype.integer >= GT_TEAM && (g_ffa_gt!=1)) {
 		G_CheckTeamItems();
 	}
 
@@ -506,6 +582,15 @@
 
 	G_RemapTeamShaders();
 
+	//elimination:
+	level.roundNumber = 1;
+	level.roundNumberStarted = 0;
+	level.roundStartTime = level.time+g_elimination_warmup.integer*1000;
+	level.roundRespawned = qfalse;
+	level.eliminationSides = rand()%2; //0 or 1
+
+	if(g_gametype.integer == GT_DOUBLE_D)
+		Team_SpawnDoubleDominationPoints();
 }
 
 
@@ -802,7 +887,7 @@
 		sizeof(level.sortedClients[0]), SortRanks );
 
 	// set the rank value for all clients that are connected and not spectators
-	if ( g_gametype.integer >= GT_TEAM ) {
+	if ( g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		// in team games, rank is just the order of the teams, 0=red, 1=blue, 2=tied
 		for ( i = 0;  i < level.numConnectedClients; i++ ) {
 			cl = &level.clients[ level.sortedClients[i] ];
@@ -837,7 +922,7 @@
 	}
 
 	// set the CS_SCORES1/2 configstrings, which will be visible to everyone
-	if ( g_gametype.integer >= GT_TEAM ) {
+	if ( g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		trap_SetConfigstring( CS_SCORES1, va("%i", level.teamScores[TEAM_RED] ) );
 		trap_SetConfigstring( CS_SCORES2, va("%i", level.teamScores[TEAM_BLUE] ) );
 	} else {
@@ -891,6 +976,57 @@
 
 /*
 ========================
+SendElimiantionMessageToAllClients
+
+Used to send information important to Elimination
+========================
+*/
+void SendEliminationMessageToAllClients( void ) {
+	int		i;
+
+	for ( i = 0 ; i < level.maxclients ; i++ ) {
+		if ( level.clients[ i ].pers.connected == CON_CONNECTED ) {
+			EliminationMessage( g_entities + i );
+		}
+	}
+}
+
+/*
+========================
+SendDDtimetakenMessageToAllClients
+
+Do this if a team just started dominating.
+========================
+*/
+void SendDDtimetakenMessageToAllClients( void ) {
+	int		i;
+
+	for ( i = 0 ; i < level.maxclients ; i++ ) {
+		if ( level.clients[ i ].pers.connected == CON_CONNECTED ) {
+			DoubleDominationScoreTimeMessage( g_entities + i );
+		}
+	}
+}
+
+/*
+========================
+SendAttackingTeamMessageToAllClients
+
+Used for CTF Elimination oneway
+========================
+*/
+void SendAttackingTeamMessageToAllClients( void ) {
+	int		i;
+
+	for ( i = 0 ; i < level.maxclients ; i++ ) {
+		if ( level.clients[ i ].pers.connected == CON_CONNECTED ) {
+			AttackingTeamMessage( g_entities + i );
+		}
+	}
+}
+
+/*
+========================
 MoveClientToIntermission
 
 When the intermission starts, this will be called for all players.
@@ -1135,7 +1271,7 @@
 		numSorted = 32;
 	}
 
-	if ( g_gametype.integer >= GT_TEAM ) {
+	if ( g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		G_LogPrintf( "red:%i  blue:%i\n",
 			level.teamScores[TEAM_RED], level.teamScores[TEAM_BLUE] );
 	}
@@ -1167,7 +1303,7 @@
 
 #ifdef MISSIONPACK
 	if (g_singlePlayer.integer) {
-		if (g_gametype.integer >= GT_CTF) {
+		if (g_gametype.integer >= GT_CTF && g_ffa_gt==0) {
 			won = level.teamScores[TEAM_RED] > level.teamScores[TEAM_BLUE];
 		}
 		trap_SendConsoleCommand( EXEC_APPEND, (won) ? "spWin\n" : "spLose\n" );
@@ -1189,7 +1325,7 @@
 =================
 */
 void CheckIntermissionExit( void ) {
-	int			ready, notReady, playerCount;
+	int			ready, notReady;
 	int			i;
 	gclient_t	*cl;
 	int			readyMask;
@@ -1202,7 +1338,6 @@
 	ready = 0;
 	notReady = 0;
 	readyMask = 0;
-	playerCount = 0;
 	for (i=0 ; i< g_maxclients.integer ; i++) {
 		cl = level.clients + i;
 		if ( cl->pers.connected != CON_CONNECTED ) {
@@ -1212,7 +1347,6 @@
 			continue;
 		}
 
-		playerCount++;
 		if ( cl->readyToExit ) {
 			ready++;
 			if ( i < 16 ) {
@@ -1238,19 +1372,16 @@
 		return;
 	}
 
-	// only test ready status when there are real players present
-	if ( playerCount > 0 ) {
-		// if nobody wants to go, clear timer
-		if ( !ready ) {
-			level.readyToExit = qfalse;
-			return;
-		}
+	// if nobody wants to go, clear timer
+	if ( !ready ) {
+		level.readyToExit = qfalse;
+		return;
+	}
 
-		// if everyone wants to go, go now
-		if ( !notReady ) {
-			ExitLevel();
-			return;
-		}
+	// if everyone wants to go, go now
+	if ( !notReady ) {
+		ExitLevel();
+		return;
 	}
 
 	// the first person to ready starts the ten second timeout
@@ -1280,7 +1411,7 @@
 		return qfalse;
 	}
 	
-	if ( g_gametype.integer >= GT_TEAM ) {
+	if ( g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		return level.teamScores[TEAM_RED] == level.teamScores[TEAM_BLUE];
 	}
 
@@ -1343,7 +1474,7 @@
 		return;
 	}
 
-	if ( g_gametype.integer < GT_CTF && g_fraglimit.integer ) {
+	if ( (g_gametype.integer < GT_CTF || g_ffa_gt>0 ) && g_fraglimit.integer ) {
 		if ( level.teamScores[TEAM_RED] >= g_fraglimit.integer ) {
 			trap_SendServerCommand( -1, "print \"Red hit the fraglimit.\n\"" );
 			LogExit( "Fraglimit hit." );
@@ -1374,7 +1505,7 @@
 		}
 	}
 
-	if ( g_gametype.integer >= GT_CTF && g_capturelimit.integer ) {
+	if ( (g_gametype.integer >= GT_CTF && g_ffa_gt<1) && g_capturelimit.integer ) {
 
 		if ( level.teamScores[TEAM_RED] >= g_capturelimit.integer ) {
 			trap_SendServerCommand( -1, "print \"Red hit the capturelimit.\n\"" );
@@ -1390,8 +1521,79 @@
 	}
 }
 
+//LMS - Last man Stading functions:
+void StartLMSRound(void) {
+	int		countsLiving;
+	countsLiving = TeamLivingCount( -1, TEAM_FREE );
+	if(countsLiving<2) {
+		trap_SendServerCommand( -1, "print \"Not enough players to start the round\n\"");
+		level.roundNumberStarted = level.roundNumber-1;
+		level.roundStartTime = level.time+1000*g_elimination_warmup.integer;
+		return;
+	}
 
+	//If we are enough to start a round:
+	level.roundNumberStarted = level.roundNumber; //Set numbers
 
+	SendEliminationMessageToAllClients();
+	EnableWeapons();
+}
+
+//the elimination start function
+void StartEliminationRound(void) {
+
+	int		countsLiving[TEAM_NUM_TEAMS];
+	countsLiving[TEAM_BLUE] = TeamLivingCount( -1, TEAM_BLUE );
+	countsLiving[TEAM_RED] = TeamLivingCount( -1, TEAM_RED );
+	if((countsLiving[TEAM_BLUE]==0) || (countsLiving[TEAM_RED]==0))
+	{
+		trap_SendServerCommand( -1, "print \"Not enough players to start the round\n\"");
+		level.roundNumberStarted = level.roundNumber-1;
+		level.roundRespawned = qfalse;
+		//Remember that one of the teams is empty!
+		level.roundRedPlayers = countsLiving[TEAM_RED];
+		level.roundBluePlayers = countsLiving[TEAM_BLUE];
+		level.roundStartTime = level.time+1000*g_elimination_warmup.integer;
+		return;
+	}
+	
+	//If we are enough to start a round:
+	level.roundNumberStarted = level.roundNumber; //Set numbers
+	level.roundRedPlayers = countsLiving[TEAM_RED];
+	level.roundBluePlayers = countsLiving[TEAM_BLUE];
+	if(g_gametype.integer == GT_CTF_ELIMINATION) {
+		Team_ReturnFlag( TEAM_RED );
+		Team_ReturnFlag( TEAM_BLUE );
+	}
+	SendEliminationMessageToAllClients();
+	if(g_elimination_ctf_oneway.integer)
+		SendAttackingTeamMessageToAllClients(); //Ensure that evaryone know who should attack.
+	EnableWeapons();
+}
+
+//things to do at end of round:
+void EndEliminationRound(void)
+{
+	DisableWeapons();
+	level.roundNumber++;
+	level.roundStartTime = level.time+1000*g_elimination_warmup.integer;
+	SendEliminationMessageToAllClients();
+	level.roundRespawned = qfalse;
+	if(g_elimination_ctf_oneway.integer)
+		SendAttackingTeamMessageToAllClients();
+}
+
+//Things to do if we don't want to move the roundNumber
+void RestartEliminationRound(void) {
+	DisableWeapons();
+	level.roundNumberStarted = level.roundNumber-1;
+	level.roundStartTime = level.time+1000*g_elimination_warmup.integer;
+	SendEliminationMessageToAllClients();
+	level.roundRespawned = qfalse;
+	if(g_elimination_ctf_oneway.integer)
+		SendAttackingTeamMessageToAllClients();
+}
+
 /*
 ========================================================================
 
@@ -1400,9 +1602,275 @@
 ========================================================================
 */
 
+/*
+CheckDoubleDomination
+*/
 
+void CheckDoubleDomination( void ) {
+	if ( level.numPlayingClients < 1 ) {
+		return;
+	}
+
+	if(g_gametype.integer != GT_DOUBLE_D)
+		return;
+
+	//Don't score if we are in intermission. Both points might have been taken when we went into intermission
+	if(level.intermissiontime)
+		return;
+
+	if(level.pointStatusA == TEAM_RED && level.pointStatusB == TEAM_RED && level.timeTaken + 10*1000 <= level.time) {
+		//Red scores
+		trap_SendServerCommand( -1, "print \"Red team scores!\n\"");
+		AddTeamScore(level.intermission_origin,TEAM_RED,1);
+		Team_ForceGesture(TEAM_RED);
+		Team_DD_bonusAtPoints(TEAM_RED);
+		Team_RemoveDoubleDominationPoints();
+		//We start again in 10 seconds:
+		level.roundStartTime = level.time + 10*1000;
+		SendScoreboardMessageToAllClients();
+		CalculateRanks();
+	}
+
+	if(level.pointStatusA == TEAM_BLUE && level.pointStatusB == TEAM_BLUE && level.timeTaken + 10*1000 <= level.time) {
+		//Blue scores
+		trap_SendServerCommand( -1, "print \"Blue team scores!\n\"");
+		AddTeamScore(level.intermission_origin,TEAM_BLUE,1);
+		Team_ForceGesture(TEAM_BLUE);
+		Team_DD_bonusAtPoints(TEAM_BLUE);
+		Team_RemoveDoubleDominationPoints();
+		//We start again in 10 seconds:
+		level.roundStartTime = level.time + 10*1000;
+		SendScoreboardMessageToAllClients();
+		CalculateRanks();
+	}
+
+	if((level.pointStatusA == TEAM_NONE || level.pointStatusB == TEAM_NONE) && level.time>level.roundStartTime) {
+		trap_SendServerCommand( -1, "print \"A new round has started\n\"");
+		Team_SpawnDoubleDominationPoints();
+		SendScoreboardMessageToAllClients();
+	}
+}
+
 /*
+CheckLMS
+*/
+
+void CheckLMS(void) {
+	int mode;
+	mode = g_lms_mode.integer;
+	if ( level.numPlayingClients < 1 ) {
+		return;
+	}
+
+	//We don't want to do anything in intermission
+	if(level.intermissiontime) {
+		if(level.roundRespawned) {
+			RestartEliminationRound();
+		}
+		level.roundStartTime = level.time; //so that a player might join at any time to fix the bots+no humans+autojoin bug
+		return;
+	}
+
+	if(g_gametype.integer == GT_LMS)
+	{
+		int		countsLiving[TEAM_NUM_TEAMS];
+		//trap_SendServerCommand( -1, "print \"This is LMS!\n\"");
+		countsLiving[TEAM_FREE] = TeamLivingCount( -1, TEAM_FREE );
+		if(countsLiving[TEAM_FREE]==1 && level.roundNumber==level.roundNumberStarted)
+		{
+			if(mode <=1 )
+			LMSpoint();
+			trap_SendServerCommand( -1, "print \"We have a winner!\n\"");
+			EndEliminationRound();
+			Team_ForceGesture(TEAM_FREE);
+		}
+
+		if(countsLiving[TEAM_FREE]==0 && level.roundNumber==level.roundNumberStarted)
+		{
+			trap_SendServerCommand( -1, "print \"All death... how sad\n\"");
+			EndEliminationRound();
+		}
+
+		if((level.roundNumber==level.roundNumberStarted)&&(g_lms_mode.integer == 1 || g_lms_mode.integer==3)&&(level.time>=level.roundStartTime+1000*g_elimination_roundtime.integer))
+		{
+			trap_SendServerCommand( -1, "print \"Time up - Overtime disabled\n\"");
+			if(mode <=1 )
+			LMSpoint();
+			EndEliminationRound();
+		}
+
+		//This might be better placed another place:
+		if(g_elimination_activewarmup.integer<2)
+			g_elimination_activewarmup.integer=2; //We need at least 2 seconds to spawn all players
+		if(g_elimination_activewarmup.integer > g_elimination_warmup.integer) //This must not be true
+			g_elimination_warmup.integer = g_elimination_activewarmup.integer+1; //Increase warmup
+
+		//Force respawn
+		if(level.roundNumber != level.roundNumberStarted && level.time>level.roundStartTime-1000*g_elimination_activewarmup.integer && !level.roundRespawned)
+		{
+			level.roundRespawned = qtrue;
+			RespawnAll();
+			DisableWeapons();
+			SendEliminationMessageToAllClients();
+		}
+
+		if(level.time<=level.roundStartTime && level.time>level.roundStartTime-1000*g_elimination_activewarmup.integer)
+		{
+			RespawnDead();
+			//DisableWeapons();
+		}
+
+		if(level.roundNumber == level.roundNumberStarted)
+		{
+			EnableWeapons();
+		}
+
+		if((level.roundNumber>level.roundNumberStarted)&&(level.time>=level.roundStartTime))
+			StartLMSRound();
+	
+		if(level.time+1000*g_elimination_warmup.integer-500>level.roundStartTime && level.numPlayingClients < 2)
+		{
+			RespawnDead(); //Allow player to run around anyway
+			RestartEliminationRound(); //Start over
+			return;
+		}
+
+	}
+}
+
+/*
 =============
+CheckElimination
+=============
+*/
+void CheckElimination(void) {
+	if ( level.numPlayingClients < 1 ) {
+		if( (g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION) &&
+			( level.time+1000*g_elimination_warmup.integer-500>level.roundStartTime ))
+			RestartEliminationRound(); //For spectators
+		return;
+	}	
+
+	//We don't want to do anything in itnermission
+	if(level.intermissiontime) {
+		if(level.roundRespawned)
+			RestartEliminationRound();
+		level.roundStartTime = level.time+1000*g_elimination_warmup.integer;
+		return;
+	}	
+
+	if(g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION)
+	{
+		int		counts[TEAM_NUM_TEAMS];
+		int		countsLiving[TEAM_NUM_TEAMS];
+		int		countsHealth[TEAM_NUM_TEAMS];
+		counts[TEAM_BLUE] = TeamCount( -1, TEAM_BLUE );
+		counts[TEAM_RED] = TeamCount( -1, TEAM_RED );
+
+		countsLiving[TEAM_BLUE] = TeamLivingCount( -1, TEAM_BLUE );
+		countsLiving[TEAM_RED] = TeamLivingCount( -1, TEAM_RED );
+
+		countsHealth[TEAM_BLUE] = TeamHealthCount( -1, TEAM_BLUE );
+		countsHealth[TEAM_RED] = TeamHealthCount( -1, TEAM_RED );
+
+		if(level.roundBluePlayers != 0 && level.roundRedPlayers != 0) { //Cannot score if one of the team never got any living players
+			if((countsLiving[TEAM_BLUE]==0)&&(level.roundNumber==level.roundNumberStarted))
+			{
+				//Blue team has been eliminated!
+				trap_SendServerCommand( -1, "print \"Blue Team eliminated!\n\"");
+				AddTeamScore(level.intermission_origin,TEAM_RED,1);
+				EndEliminationRound();
+				Team_ForceGesture(TEAM_RED);
+			}
+			else if((countsLiving[TEAM_RED]==0)&&(level.roundNumber==level.roundNumberStarted))
+			{
+				//Red team eliminated!
+				trap_SendServerCommand( -1, "print \"Red Team eliminated!\n\"");
+				AddTeamScore(level.intermission_origin,TEAM_BLUE,1);
+				EndEliminationRound();
+				Team_ForceGesture(TEAM_BLUE);
+			}
+		}
+
+		//Time up
+		if((level.roundNumber==level.roundNumberStarted)&&(level.time>=level.roundStartTime+1000*g_elimination_roundtime.integer))
+		{
+			trap_SendServerCommand( -1, "print \"No teams eliminated!\n\"");
+
+			if(level.roundBluePlayers != 0 && level.roundRedPlayers != 0) {//We don't want to divide by zero. (should not be possible)
+				if(g_gametype.integer == GT_CTF_ELIMINATION && g_elimination_ctf_oneway.integer) {
+					//One way CTF, make defensice team the winner.
+					if ( (level.eliminationSides+level.roundNumber)%2 == 0 ) { //Red was attacking
+						trap_SendServerCommand( -1, "print \"Blue team defended the base\n\"");
+						AddTeamScore(level.intermission_origin,TEAM_BLUE,1);
+					}
+					else {
+						trap_SendServerCommand( -1, "print \"Red team defended the base\n\"");
+						AddTeamScore(level.intermission_origin,TEAM_RED,1);
+					}
+				}
+				else if(((double)countsLiving[TEAM_RED])/((double)level.roundRedPlayers)>((double)countsLiving[TEAM_BLUE])/((double)level.roundBluePlayers))
+				{
+					//Red team has higher procentage survivors
+					trap_SendServerCommand( -1, "print \"Red team has most survivers!\n\"");
+					AddTeamScore(level.intermission_origin,TEAM_RED,1);
+				}
+				else if(((double)countsLiving[TEAM_RED])/((double)level.roundRedPlayers)<((double)countsLiving[TEAM_BLUE])/((double)level.roundBluePlayers))
+				{
+					//Blue team has higher procentage survivors
+					trap_SendServerCommand( -1, "print \"Blue team has most survivers!\n\"");
+					AddTeamScore(level.intermission_origin,TEAM_BLUE,1);	
+				}
+				else if(countsHealth[TEAM_RED]>countsHealth[TEAM_BLUE])
+				{
+					//Red team has more health
+					trap_SendServerCommand( -1, "print \"Red team has more health left!\n\"");
+					AddTeamScore(level.intermission_origin,TEAM_RED,1);
+				}
+				else if(countsHealth[TEAM_RED]<countsHealth[TEAM_BLUE])
+				{
+					//Blue team has more health
+					trap_SendServerCommand( -1, "print \"Blue team has more health left!\n\"");
+					AddTeamScore(level.intermission_origin,TEAM_BLUE,1);
+				}
+			}
+			EndEliminationRound();
+		}
+
+		//This might be better placed another place:
+		if(g_elimination_activewarmup.integer<1)
+			g_elimination_activewarmup.integer=1; //We need at least 1 second to spawn all players
+		if(g_elimination_activewarmup.integer > g_elimination_warmup.integer) //This must not be true
+			g_elimination_warmup.integer = g_elimination_activewarmup.integer+1; //Increase warmup
+
+		//Force respawn
+		if(level.roundNumber!=level.roundNumberStarted && level.time>level.roundStartTime-1000*g_elimination_activewarmup.integer && !level.roundRespawned)
+		{
+			level.roundRespawned = qtrue;
+			RespawnAll();
+			SendEliminationMessageToAllClients();
+		}
+
+		if(level.time<=level.roundStartTime && level.time>level.roundStartTime-1000*g_elimination_activewarmup.integer)
+		{
+			RespawnDead();
+		}
+			
+
+		if((level.roundNumber>level.roundNumberStarted)&&(level.time>=level.roundStartTime))
+			StartEliminationRound();
+	
+		if(level.time+1000*g_elimination_warmup.integer-500>level.roundStartTime)
+		if(counts[TEAM_BLUE]<1 || counts[TEAM_RED]<1)
+		{
+			RespawnDead(); //Allow players to run around anyway
+			RestartEliminationRound(); //Start over
+			return;
+		}
+	}
+}
+/*
+=============
 CheckTournament
 
 Once a frame, check for changes in tournement player state
@@ -1822,6 +2290,13 @@
 	// see if it is time to do a tournement restart
 	CheckTournament();
 
+	//Check Elimination state
+	CheckElimination();
+	CheckLMS();
+
+	//Check Double Domination
+	CheckDoubleDomination();
+
 	// see if it is time to end the level
 	CheckExitRules();
 
Index: code/game/g_mover.c
===================================================================
--- code/game/g_mover.c	(revision 1145)
+++ code/game/g_mover.c	(working copy)
@@ -857,7 +857,7 @@
 ================
 */
 void Touch_DoorTrigger( gentity_t *ent, gentity_t *other, trace_t *trace ) {
-	if ( other->client && other->client->sess.sessionTeam == TEAM_SPECTATOR ) {
+	if ( other->client && (other->client->sess.sessionTeam == TEAM_SPECTATOR || other->client->ps.pm_type == PM_SPECTATOR)) {
 		// if the door is not open and not opening
 		if ( ent->parent->moverState != MOVER_1TO2 &&
 			ent->parent->moverState != MOVER_POS2) {
Index: code/game/bg_pmove.c
===================================================================
--- code/game/bg_pmove.c	(revision 1145)
+++ code/game/bg_pmove.c	(working copy)
@@ -48,7 +48,6 @@
 
 int		c_pmove = 0;
 
-
 /*
 ===============
 PM_AddEvent
@@ -234,11 +233,14 @@
 ==============
 PM_Accelerate
 
+TODO: bunny hoping
+
 Handles user intended acceleration
 ==============
 */
 static void PM_Accelerate( vec3_t wishdir, float wishspeed, float accel ) {
 #if 1
+
 	// q2 style
 	int			i;
 	float		addspeed, accelspeed, currentspeed;
@@ -273,6 +275,7 @@
 	}
 
 	VectorMA( pm->ps->velocity, canPush, pushDir, pm->ps->velocity );
+}
 #endif
 }
 
@@ -357,6 +360,8 @@
 =============
 */
 static qboolean PM_CheckJump( void ) {
+
+
 	if ( pm->ps->pm_flags & PMF_RESPAWNED ) {
 		return qfalse;		// don't allow jump until all buttons are up
 	}
@@ -366,6 +371,7 @@
 		return qfalse;
 	}
 
+
 	// must wait for jump to be released
 	if ( pm->ps->pm_flags & PMF_JUMP_HELD ) {
 		// clear upmove so cmdscale doesn't lower running speed
@@ -373,6 +379,9 @@
 		return qfalse;
 	}
 
+	
+
+
 	pml.groundPlane = qfalse;		// jumping away
 	pml.walking = qfalse;
 	pm->ps->pm_flags |= PMF_JUMP_HELD;
@@ -1533,6 +1542,9 @@
 PM_Weapon
 
 Generates weapon events and modifes the weapon counter
+
+Elimination TODO:
+Make this thing stop during warmup (done)
 ==============
 */
 static void PM_Weapon( void ) {
@@ -1544,7 +1556,7 @@
 	}
 
 	// ignore if spectator
-	if ( pm->ps->persistant[PERS_TEAM] == TEAM_SPECTATOR ) {
+	if ( pm->ps->persistant[PERS_TEAM] == TEAM_SPECTATOR || pm->ps->pm_type == PM_SPECTATOR) {
 		return;
 	}
 
@@ -1635,8 +1647,8 @@
 		return;
 	}
 
-	// take an ammo away if not infinite
-	if ( pm->ps->ammo[ pm->ps->weapon ] != -1 ) {
+	// take an ammo away if not infinite, 999 or up
+	if ( !(pm->ps->ammo[ pm->ps->weapon ] == -1 || pm->ps->ammo[ pm->ps->weapon ] >=999 )) {
 		pm->ps->ammo[ pm->ps->weapon ]--;
 	}
 
@@ -2000,6 +2012,7 @@
 	PM_SetWaterLevel();
 
 	// weapons
+	if(!(pm->ps->pm_flags & PMF_ELIMWARMUP))
 	PM_Weapon();
 
 	// torso animation
Index: code/game/ai_team.c
===================================================================
--- code/game/ai_team.c	(revision 1145)
+++ code/game/ai_team.c	(working copy)
@@ -131,7 +131,7 @@
 	int traveltimes[MAX_CLIENTS];
 	bot_goal_t *goal = NULL;
 
-	if (gametype == GT_CTF || gametype == GT_1FCTF) {
+	if (gametype == GT_CTF || gametype == GT_1FCTF || gametype == GT_CTF_ELIMINATION) {
 		if (BotTeam(bs) == TEAM_RED)
 			goal = &ctf_redflag;
 		else
@@ -180,6 +180,57 @@
 
 /*
 ==================
+BotSortTeamMatesByReletiveTravelTime2ddA
+For Double Domination
+==================
+*/
+int BotSortTeamMatesByRelativeTravelTime2ddA(bot_state_t *bs, int *teammates, int maxteammates) {
+	int i, j, k, numteammates;
+	double traveltime, traveltime2b;
+	char buf[MAX_INFO_STRING];
+	static int maxclients;
+	double traveltimes[MAX_CLIENTS];
+	//int traveltimes2b[MAX_CLIENTS];
+	bot_goal_t *goalA = &ctf_redflag;
+	bot_goal_t *goalB = &ctf_blueflag;
+
+	if (!maxclients)
+		maxclients = trap_Cvar_VariableIntegerValue("sv_maxclients");
+
+	numteammates = 0;
+
+	for (i = 0; i < maxclients && i < MAX_CLIENTS; i++) {
+		trap_GetConfigstring(CS_PLAYERS+i, buf, sizeof(buf));
+		//if no config string or no name
+		if (!strlen(buf) || !strlen(Info_ValueForKey(buf, "n"))) continue;
+		//skip spectators
+		if (atoi(Info_ValueForKey(buf, "t")) == TEAM_SPECTATOR) continue;
+		if (BotSameTeam(bs, i)) {
+			traveltime = (double)BotClientTravelTimeToGoal(i, goalA);
+			traveltime2b = (double)BotClientTravelTimeToGoal(i, goalB);
+			traveltime = traveltime/traveltime2b;
+
+			for (j = 0; j < numteammates; j++) {
+				if (traveltime < traveltimes[j]) {
+					for (k = numteammates; k > j; k--) {
+						traveltimes[k] = traveltimes[k-1];
+						teammates[k] = teammates[k-1];
+					}
+					break;
+				}
+			}
+			traveltimes[j] = traveltime;
+			teammates[j] = i;
+			numteammates++;
+			if (numteammates >= maxteammates) break;
+		}
+	}
+
+	return numteammates;
+}
+
+/*
+==================
 BotSetTeamMateTaskPreference
 ==================
 */
@@ -448,9 +499,26 @@
 	int numteammates, defenders, attackers, i;
 	int teammates[MAX_CLIENTS];
 	char name[MAX_NETNAME];
+	qboolean weAreAttacking;
 
 	numteammates = BotSortTeamMatesByBaseTravelTime(bs, teammates, sizeof(teammates));
 	BotSortTeamMatesByTaskPreference(bs, teammates, numteammates);
+
+	weAreAttacking = qfalse;
+
+	//In oneway ctf we must all move out of the base (only one strategi, maybe we can also send some to the enemy base  to meet the flag carier?)
+	//We must be defending
+	if(g_elimination_ctf_oneway.integer > 0) {
+		for (i = 0; i < numteammates; i++) {
+			//
+			ClientName(teammates[i], name, sizeof(name));
+			BotAI_BotInitialChat(bs, "cmd_getflag", name, NULL);
+			BotSayTeamOrder(bs, teammates[i]);
+			BotSayVoiceTeamOrder(bs, teammates[i], VOICECHAT_GETFLAG);
+		}
+		return;
+	}
+
 	//passive strategy
 	if (!(bs->ctfstrategy & CTFS_AGRESSIVE)) {
 		//different orders based on the number of team mates
@@ -682,7 +750,55 @@
 	}
 }
 
+/*
+==================
+BotDDorders
+==================
+*/
 
+void BotDDorders_Standard(bot_state_t *bs) {
+	int numteammates, i;
+	int teammates[MAX_CLIENTS];
+	char name[MAX_NETNAME];
+
+	//sort team mates by travel time to base
+	numteammates = BotSortTeamMatesByRelativeTravelTime2ddA(bs, teammates, sizeof(teammates));
+
+	switch(numteammates) {
+		case 1: break;
+		/*case 2: 
+		{
+			//the one closest to point A will take that
+			ClientName(teammates[0], name, sizeof(name));
+			BotAI_BotInitialChat(bs, "cmd_takea", name, NULL);
+			BotSayTeamOrder(bs, teammates[0]);
+			//BotSayVoiceTeamOrder(bs, teammates[0], VOICECHAT_TAKEA);
+			//the other goes for point B
+			ClientName(teammates[1], name, sizeof(name));
+			BotAI_BotInitialChat(bs, "cmd_takeb", name, NULL);
+			BotSayTeamOrder(bs, teammates[1]);
+			//BotSayVoiceTeamOrder(bs, teammates[1], VOICECHAT_TAKEB);
+			break;
+		}*/
+		default:
+		{
+			for(i=0;i<numteammates/2;i++) { //Half take point A
+				ClientName(teammates[i], name, sizeof(name));
+				BotAI_BotInitialChat(bs, "cmd_takea", name, NULL);
+				BotSayTeamOrder(bs, teammates[i]);
+				//BotSayVoiceTeamOrder(bs, teammates[0], VOICECHAT_TAKEA);
+			}
+			for(i=numteammates/2+1;i<numteammates;i++) { //Rest takes point B
+				ClientName(teammates[i], name, sizeof(name));
+				BotAI_BotInitialChat(bs, "cmd_takeb", name, NULL);
+				BotSayTeamOrder(bs, teammates[i]);
+				//BotSayVoiceTeamOrder(bs, teammates[0], VOICECHAT_TAKEB);
+			}
+			break;
+		}
+	}
+}
+
 /*
 ==================
 BotCTFOrders
@@ -692,11 +808,40 @@
 	int numteammates, defenders, attackers, i;
 	int teammates[MAX_CLIENTS];
 	char name[MAX_NETNAME];
+	qboolean weAreAttacking;
 
 	//sort team mates by travel time to base
 	numteammates = BotSortTeamMatesByBaseTravelTime(bs, teammates, sizeof(teammates));
 	//sort team mates by CTF preference
 	BotSortTeamMatesByTaskPreference(bs, teammates, numteammates);
+
+	weAreAttacking = qfalse;
+
+	if(g_elimination_ctf_oneway.integer > 0) {
+		//See if we are attacking:
+		if( ( (level.eliminationSides+level.roundNumber)%2 == 0 ) && (BotTeam(bs) == TEAM_RED))
+			weAreAttacking = qtrue;
+		
+		if(weAreAttacking) {
+			for (i = 0; i < numteammates; i++) {
+				//
+				ClientName(teammates[i], name, sizeof(name));
+				BotAI_BotInitialChat(bs, "cmd_getflag", name, NULL);
+				BotSayTeamOrder(bs, teammates[i]);
+				BotSayVoiceTeamOrder(bs, teammates[i], VOICECHAT_GETFLAG);
+			}
+		} else {
+			for (i = 0; i < numteammates; i++) {
+				//
+				ClientName(teammates[i], name, sizeof(name));
+				BotAI_BotInitialChat(bs, "cmd_defendbase", name, NULL);
+				BotSayTeamOrder(bs, teammates[i]);
+				BotSayVoiceTeamOrder(bs, teammates[i], VOICECHAT_DEFEND);
+			}
+		}
+		return; //Sago: Or the leader will make a counter order.
+	}
+
 	//passive strategy
 	if (!(bs->ctfstrategy & CTFS_AGRESSIVE)) {
 		//different orders based on the number of team mates
@@ -844,7 +989,16 @@
 	}
 }
 
+/*
+==================
+BotDDorders
+==================
+*/
+void BotDDorders(bot_state_t *bs) {
+	BotDDorders_Standard(bs);	
+}
 
+
 /*
 ==================
 BotCreateGroup
@@ -1922,6 +2076,8 @@
 	return qfalse;
 }
 
+int lastRoundNumber; //used to give new orders every round
+
 /*
 ==================
 BotTeamAI
@@ -1932,7 +2088,7 @@
 	char netname[MAX_NETNAME];
 
 	//
-	if ( gametype < GT_TEAM  )
+	if ( gametype < GT_TEAM || g_ffa_gt == 1 )
 		return;
 	// make sure we've got a valid team leader
 	if (!BotValidTeamLeader(bs)) {
@@ -1960,7 +2116,7 @@
 				BotSayVoiceTeamOrder(bs, -1, VOICECHAT_STARTLEADER);
 				ClientName(bs->client, netname, sizeof(netname));
 				strncpy(bs->teamleader, netname, sizeof(bs->teamleader));
-				bs->teamleader[sizeof(bs->teamleader)-1] = '\0';
+				bs->teamleader[sizeof(bs->teamleader)] = '\0';
 				bs->becometeamleader_time = 0;
 			}
 			return;
@@ -1992,14 +2148,16 @@
 			break;
 		}
 		case GT_CTF:
+		case GT_CTF_ELIMINATION:
 		{
 			//if the number of team mates changed or the flag status changed
 			//or someone wants to know what to do
-			if (bs->numteammates != numteammates || bs->flagstatuschanged || bs->forceorders) {
+			if (bs->numteammates != numteammates || bs->flagstatuschanged || bs->forceorders || lastRoundNumber != level.roundNumber) {
 				bs->teamgiveorders_time = FloatTime();
 				bs->numteammates = numteammates;
 				bs->flagstatuschanged = qfalse;
 				bs->forceorders = qfalse;
+				lastRoundNumber = level.roundNumber;
 			}
 			//if there were no flag captures the last 3 minutes
 			if (bs->lastflagcapture_time < FloatTime() - 240) {
@@ -2018,6 +2176,24 @@
 			}
 			break;
 		}
+		case GT_DOUBLE_D:
+		{
+			//if the number of team mates changed or the domination point status changed
+			//or someone wants to know what to do
+			if (bs->numteammates != numteammates || bs->flagstatuschanged || bs->forceorders) {
+				bs->teamgiveorders_time = FloatTime();
+				bs->numteammates = numteammates;
+				bs->flagstatuschanged = qfalse;
+				bs->forceorders = qfalse;
+			}
+			//if it's time to give orders
+			if (bs->teamgiveorders_time && bs->teamgiveorders_time < FloatTime() - 3) {
+				BotDDorders(bs);
+				//
+				bs->teamgiveorders_time = 0;
+			}
+			break;
+		}
 #ifdef MISSIONPACK
 		case GT_1FCTF:
 		{
Index: code/game/g_weapon.c
===================================================================
--- code/game/g_weapon.c	(revision 1145)
+++ code/game/g_weapon.c	(working copy)
@@ -111,7 +111,10 @@
 	}
 #endif
 
-	damage = 50 * s_quadFactor;
+	if(g_instantgib.integer)
+		damage = 1000; //High damage in instant gib (normally enough to gib)
+	else
+		damage = 50 * s_quadFactor;
 	G_Damage( traceEnt, ent, ent, forward, tr.endpos,
 		damage, 0, MOD_GAUNTLET );
 
@@ -454,6 +457,8 @@
 	gentity_t	*unlinkedEntities[MAX_RAIL_HITS];
 
 	damage = 100 * s_quadFactor;
+	if(g_instantgib.integer)
+		damage = 5000;
 
 	VectorMA (muzzle, 8192, forward, end);
 
@@ -810,6 +815,18 @@
 ===============
 */
 void FireWeapon( gentity_t *ent ) {
+
+
+	//If elimination warmup, don't fire at all!
+	if (g_gametype.integer == GT_ELIMINATION && level.roundStartTime>level.time)
+		return;
+
+	//Make people drop out of follow mode (this should be moved, so people can change betwean players.)
+	if (ent->client->sess.spectatorState == SPECTATOR_FOLLOW) {
+		StopFollowing( ent );
+		return;
+	}
+
 	if (ent->client->ps.powerups[PW_QUAD] ) {
 		s_quadFactor = g_quadfactor.value;
 	} else {
Index: code/game/g_misc.c
===================================================================
--- code/game/g_misc.c	(revision 1145)
+++ code/game/g_misc.c	(working copy)
@@ -81,7 +81,7 @@
 
 	// use temp events at source and destination to prevent the effect
 	// from getting dropped by a second player event
-	if ( player->client->sess.sessionTeam != TEAM_SPECTATOR ) {
+	if ( player->client->sess.sessionTeam != TEAM_SPECTATOR && player->client->ps.pm_type != PM_SPECTATOR) {
 		tent = G_TempEntity( player->client->ps.origin, EV_PLAYER_TELEPORT_OUT );
 		tent->s.clientNum = player->s.clientNum;
 
@@ -108,7 +108,7 @@
 	SetClientViewAngle( player, angles );
 
 	// kill anything at the destination
-	if ( player->client->sess.sessionTeam != TEAM_SPECTATOR ) {
+	if ( player->client->sess.sessionTeam != TEAM_SPECTATOR && player->client->ps.pm_type != PM_SPECTATOR ) {
 		G_KillBox (player);
 	}
 
@@ -118,7 +118,7 @@
 	// use the precise origin for linking
 	VectorCopy( player->client->ps.origin, player->r.currentOrigin );
 
-	if ( player->client->sess.sessionTeam != TEAM_SPECTATOR ) {
+	if ( player->client->sess.sessionTeam != TEAM_SPECTATOR && player->client->ps.pm_type != PM_SPECTATOR ) {
 		trap_LinkEntity (player);
 	}
 }
Index: code/game/match.h
===================================================================
--- code/game/match.h	(revision 1145)
+++ code/game/match.h	(working copy)
@@ -67,6 +67,9 @@
 #define MSG_ATTACKENEMYBASE				31		//attack the enemy base
 #define MSG_HARVEST						32		//go harvest
 #define MSG_SUICIDE						33		//order to suicide
+//Double Domination messages
+#define MSG_TAKEA					34
+#define MSG_TAKEB					35
 //
 #define MSG_ME							100
 #define MSG_EVERYONE					101
Index: code/game/ai_vcmd.c
===================================================================
--- code/game/ai_vcmd.c	(revision 1145)
+++ code/game/ai_vcmd.c	(working copy)
@@ -71,7 +71,7 @@
 */
 void BotVoiceChat_GetFlag(bot_state_t *bs, int client, int mode) {
 	//
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		if (!ctf_redflag.areanum || !ctf_blueflag.areanum)
 			return;
 	}
@@ -95,7 +95,7 @@
 	//set the team goal time
 	bs->teamgoal_time = FloatTime() + CTF_GETFLAG_TIME;
 	// get an alternate route in ctf
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		//get an alternative route goal towards the enemy base
 		BotGetAlternateRouteGoal(bs, BotOppositeTeam(bs));
 	}
@@ -114,7 +114,7 @@
 ==================
 */
 void BotVoiceChat_Offense(bot_state_t *bs, int client, int mode) {
-	if ( gametype == GT_CTF
+	if ( gametype == GT_CTF || gametype == GT_CTF_ELIMINATION
 #ifdef MISSIONPACK
 		|| gametype == GT_1FCTF
 #endif
@@ -181,7 +181,7 @@
 	}
 	else
 #endif
-		if (gametype == GT_CTF
+		if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION
 #ifdef MISSIONPACK
 			|| gametype == GT_1FCTF
 #endif
@@ -383,7 +383,7 @@
 void BotVoiceChat_ReturnFlag(bot_state_t *bs, int client, int mode) {
 	//if not in CTF mode
 	if (
-		gametype != GT_CTF
+		gametype != GT_CTF && gametype != GT_CTF_ELIMINATION
 #ifdef MISSIONPACK
 		&& gametype != GT_1FCTF
 #endif
Index: code/game/bg_local.h
===================================================================
--- code/game/bg_local.h	(revision 1145)
+++ code/game/bg_local.h	(working copy)
@@ -73,6 +73,10 @@
 
 extern	int		c_pmove;
 
+//Repeting airjumps/no bunny, elimination B5
+extern	int	pm_airjumps;
+extern	int	pm_nobunny;
+
 void PM_ClipVelocity( vec3_t in, vec3_t normal, vec3_t out, float overbounce );
 void PM_AddTouchEnt( int entityNum );
 void PM_AddEvent( int newEvent );
Index: code/game/g_trigger.c
===================================================================
--- code/game/g_trigger.c	(revision 1145)
+++ code/game/g_trigger.c	(working copy)
@@ -274,12 +274,13 @@
 	if ( !other->client ) {
 		return;
 	}
+
 	if ( other->client->ps.pm_type == PM_DEAD ) {
 		return;
 	}
 	// Spectators only?
 	if ( ( self->spawnflags & 1 ) && 
-		other->client->sess.sessionTeam != TEAM_SPECTATOR ) {
+		(other->client->sess.sessionTeam != TEAM_SPECTATOR && other->client->ps.pm_type != PM_SPECTATOR) ) {
 		return;
 	}
 
Index: code/game/g_missile.c
===================================================================
--- code/game/g_missile.c	(revision 1145)
+++ code/game/g_missile.c	(working copy)
@@ -137,7 +137,7 @@
 	}
 
 
-	if ( g_gametype.integer >= GT_TEAM ) {
+	if ( g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		// don't trigger same team mines
 		if (trigger->parent->s.generic1 == other->client->sess.sessionTeam) {
 			return;
Index: code/game/ai_dmq3.c
===================================================================
--- code/game/ai_dmq3.c	(revision 1145)
+++ code/game/ai_dmq3.c	(working copy)
@@ -128,7 +128,7 @@
 ==================
 */
 int BotCTFCarryingFlag(bot_state_t *bs) {
-	if (gametype != GT_CTF) return CTF_FLAG_NONE;
+	if (gametype != GT_CTF && gametype!=GT_CTF_ELIMINATION) return CTF_FLAG_NONE;
 
 	if (bs->inventory[INVENTORY_REDFLAG] > 0) return CTF_FLAG_RED;
 	else if (bs->inventory[INVENTORY_BLUEFLAG] > 0) return CTF_FLAG_BLUE;
@@ -369,7 +369,7 @@
 			break;
 		case LTG_TEAMACCOMPANY:
 			BotEntityInfo(bs->teammate, &entinfo);
-			if ( ( (gametype == GT_CTF || gametype == GT_1FCTF) && EntityCarriesFlag(&entinfo))
+			if ( ( (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION || gametype == GT_1FCTF) && EntityCarriesFlag(&entinfo))
 				|| ( gametype == GT_HARVESTER && EntityCarriesCubes(&entinfo)) ) {
 				teamtask = TEAMTASK_ESCORT;
 			}
@@ -408,6 +408,16 @@
 		case LTG_ATTACKENEMYBASE:
 			teamtask = TEAMTASK_OFFENSE;
 			break;
+		case LTG_POINTA:
+			if(BotTeam(bs) == TEAM_BLUE)
+				teamtask = TEAMTASK_OFFENSE;
+			else
+				teamtask = TEAMTASK_DEFENSE;
+		case LTG_POINTB:
+			if(BotTeam(bs) == TEAM_RED)
+				teamtask = TEAMTASK_OFFENSE;
+			else
+				teamtask = TEAMTASK_DEFENSE;
 		default:
 			teamtask = TEAMTASK_PATROL;
 			break;
@@ -423,7 +433,7 @@
 */
 int BotSetLastOrderedTask(bot_state_t *bs) {
 
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		// don't go back to returning the flag if it's at the base
 		if ( bs->lastgoal_ltgtype == LTG_RETURNFLAG ) {
 			if ( BotTeam(bs) == TEAM_RED ) {
@@ -448,7 +458,7 @@
 		bs->teamgoal_time = FloatTime() + 300;
 		BotSetTeamStatus(bs);
 		//
-		if ( gametype == GT_CTF ) {
+		if ( gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 			if ( bs->ltgtype == LTG_GETFLAG ) {
 				bot_goal_t *tb, *eb;
 				int tt, et;
@@ -789,6 +799,53 @@
 	}
 }
 
+/*
+==================
+BotDDSeekGoals
+==================
+*/
+
+void BotDDSeekGoals(bot_state_t *bs) {
+
+	/*if (bs->ltgtype == LTG_TEAMHELP ||
+			bs->ltgtype == LTG_TEAMACCOMPANY ||
+			bs->ltgtype == LTG_CAMPORDER ||
+			bs->ltgtype == LTG_PATROL ||
+			bs->ltgtype == LTG_GETITEM) {
+		return;
+	}*/
+
+	if(bs->ltgtype == LTG_POINTA)
+		memcpy(&bs->teamgoal, &ctf_redflag, sizeof(bot_goal_t));
+	if(bs->ltgtype == LTG_POINTB)
+		memcpy(&bs->teamgoal, &ctf_blueflag, sizeof(bot_goal_t));
+
+	if(bs->ltgtype == LTG_POINTA || bs->ltgtype == LTG_POINTB)
+		return;
+
+	if(rand()%2==0)
+		bs->ltgtype = LTG_POINTA;
+	else
+		bs->ltgtype = LTG_POINTB;
+
+	if(bs->ltgtype == LTG_POINTA) {
+		memcpy(&bs->teamgoal, &ctf_redflag, sizeof(bot_goal_t));
+		if(BotTeam(bs) == TEAM_BLUE)
+			BotSetUserInfo(bs, "teamtask", va("%d", TEAMTASK_OFFENSE));
+		else
+			BotSetUserInfo(bs, "teamtask", va("%d", TEAMTASK_DEFENSE));
+	} else
+	if(bs->ltgtype == LTG_POINTB) {
+		memcpy(&bs->teamgoal, &ctf_blueflag, sizeof(bot_goal_t));
+		if(BotTeam(bs) == TEAM_RED)
+			BotSetUserInfo(bs, "teamtask", va("%d", TEAMTASK_OFFENSE));
+		else
+			BotSetUserInfo(bs, "teamtask", va("%d", TEAMTASK_DEFENSE));
+	}
+
+
+}
+
 #ifdef MISSIONPACK
 /*
 ==================
@@ -1326,7 +1383,7 @@
 void BotTeamGoals(bot_state_t *bs, int retreat) {
 
 	if ( retreat ) {
-		if (gametype == GT_CTF) {
+		if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION ) {
 			BotCTFRetreatGoals(bs);
 		}
 #ifdef MISSIONPACK
@@ -1342,7 +1399,7 @@
 #endif
 	}
 	else {
-		if (gametype == GT_CTF) {
+		if (gametype == GT_CTF|| gametype == GT_CTF_ELIMINATION) {
 			//decide what to do in CTF mode
 			BotCTFSeekGoals(bs);
 		}
@@ -1358,6 +1415,10 @@
 		}
 #endif
 	}
+
+	if(gametype == GT_DOUBLE_D) //Don't care about retreat
+		BotDDSeekGoals(bs);
+
 	// reset the order time which is used to see if
 	// we decided to refuse an order
 	bs->order_time = 0;
@@ -1537,7 +1598,7 @@
 
 	context = CONTEXT_NORMAL|CONTEXT_NEARBYITEM|CONTEXT_NAMES;
 	//
-	if (gametype == GT_CTF
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION
 #ifdef MISSIONPACK
 		|| gametype == GT_1FCTF
 #endif
@@ -1625,7 +1686,7 @@
 #ifdef MISSIONPACK
 	int offence, leader;
 
-	if (gametype <= GT_TEAM)
+	if (gametype <= GT_TEAM && g_ffa_gt==0)
 		return;
 
 	offence = -1;
@@ -1664,18 +1725,20 @@
 					//trap_BotEnterChat(bs->cs, leader, CHAT_TELL);
 				}
 				else if (g_spSkill.integer <= 3) {
-					if ( bs->ltgtype != LTG_GETFLAG &&
-						 bs->ltgtype != LTG_ATTACKENEMYBASE &&
-						 bs->ltgtype != LTG_HARVEST ) {
-						//
-						if ((gametype != GT_CTF || (bs->redflagstatus == 0 && bs->blueflagstatus == 0)) &&
-							(gametype != GT_1FCTF || bs->neutralflagstatus == 0) ) {
+					if ( ( bs->ltgtype != LTG_GETFLAG ) &&
+						( bs->ltgtype != LTG_ATTACKENEMYBASE ) &&
+						( bs->ltgtype != LTG_HARVEST ) &&
+						( ( ( gametype != GT_CTF ) &&
+						( gametype != GT_CTF_ELIMINATION ) ) ||
+						( ( bs->redflagstatus == 0 ) &&
+						( bs->blueflagstatus == 0 ) ) ) &&
+						( ( gametype != GT_1FCTF ) ||
+						( bs->neutralflagstatus == 0 ) ) ) {
 							// tell the leader we want to be on offence
 							BotVoiceChat(bs, leader, VOICECHAT_WANTONOFFENSE);
 							//BotAI_BotInitialChat(bs, "wantoffence", NULL);
 							//trap_BotEnterChat(bs->cs, leader, CHAT_TELL);
 						}
-					}
 					bs->teamtaskpreference |= TEAMTP_ATTACKER;
 				}
 			}
@@ -1690,17 +1753,19 @@
 					//BotAI_BotInitialChat(bs, "wantdefence", NULL);
 					//trap_BotEnterChat(bs->cs, leader, CHAT_TELL);
 				}
-				else if (g_spSkill.integer <= 3) {
-					if ( bs->ltgtype != LTG_DEFENDKEYAREA ) {
-						//
-						if ((gametype != GT_CTF || (bs->redflagstatus == 0 && bs->blueflagstatus == 0)) &&
-							(gametype != GT_1FCTF || bs->neutralflagstatus == 0) ) {
-							// tell the leader we want to be on defense
-							BotVoiceChat(bs, -1, VOICECHAT_WANTONDEFENSE);
-							//BotAI_BotInitialChat(bs, "wantdefence", NULL);
-							//trap_BotEnterChat(bs->cs, leader, CHAT_TELL);
-						}
-					}
+				else if ( (g_spSkill.integer <= 3) &&
+					( bs->ltgtype != LTG_DEFENDKEYAREA ) &&
+					( ( ( gametype != GT_CTF ) &&
+					( gametype != GT_CTF_ELIMINATION ) ) ||
+					( ( bs->redflagstatus == 0 ) &&
+					( bs->blueflagstatus == 0 ) ) ) &&
+					( ( gametype != GT_1FCTF ) ||
+					( bs->neutralflagstatus == 0 ) ) ) {
+
+					// tell the leader we want to be on defense
+					BotVoiceChat(bs, -1, VOICECHAT_WANTONDEFENSE);
+					//BotAI_BotInitialChat(bs, "wantdefence", NULL);
+					//trap_BotEnterChat(bs->cs, leader, CHAT_TELL);
 				}
 				bs->teamtaskpreference |= TEAMTP_DEFENDER;
 			}
@@ -1826,7 +1891,7 @@
 	if (bs->kamikaze_time > FloatTime())
 		return;
 	bs->kamikaze_time = FloatTime() + 0.2;
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		//never use kamikaze if the team flag carrier is visible
 		if (BotCTFCarryingFlag(bs))
 			return;
@@ -1933,7 +1998,7 @@
 	if (bs->invulnerability_time > FloatTime())
 		return;
 	bs->invulnerability_time = FloatTime() + 0.2;
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		//never use kamikaze if the team flag carrier is visible
 		if (BotCTFCarryingFlag(bs))
 			return;
@@ -2188,7 +2253,7 @@
 ==================
 */
 int TeamPlayIsOn(void) {
-	return ( gametype >= GT_TEAM );
+	return ( gametype >= GT_TEAM && g_ffa_gt!=1);
 }
 
 /*
@@ -2268,7 +2333,7 @@
 int BotWantsToRetreat(bot_state_t *bs) {
 	aas_entityinfo_t entinfo;
 
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		//always retreat when carrying a CTF flag
 		if (BotCTFCarryingFlag(bs))
 			return qtrue;
@@ -2321,7 +2386,7 @@
 int BotWantsToChase(bot_state_t *bs) {
 	aas_entityinfo_t entinfo;
 
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		//never chase when carrying a CTF flag
 		if (BotCTFCarryingFlag(bs))
 			return qfalse;
@@ -2776,7 +2841,7 @@
 		//BotAI_Print(PRT_ERROR, "BotSameTeam: client out of range\n");
 		return qfalse;
 	}
-	if ( gametype >= GT_TEAM ) {
+	if ( gametype >= GT_TEAM && g_ffa_gt!=1) {
 		trap_GetConfigstring(CS_PLAYERS+bs->client, info1, sizeof(info1));
 		trap_GetConfigstring(CS_PLAYERS+entnum, info2, sizeof(info2));
 		//
@@ -4176,7 +4241,7 @@
 		return 0;
 	}
 	trap_AAS_ValueForBSPEpairKey(ent, "classname", classname, sizeof(classname));
-	if (!*classname) {
+	if (!classname) {
 		BotAI_Print(PRT_ERROR, "BotGetActivateGoal: entity with model %s has no classname\n", model);
 		return 0;
 	}
@@ -4865,7 +4930,7 @@
 		}
 		case EV_GLOBAL_TEAM_SOUND:
 		{
-			if (gametype == GT_CTF) {
+			if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 				switch(state->eventParm) {
 					case GTS_RED_CAPTURE:
 						bs->blueflagstatus = 0;
@@ -5130,7 +5195,7 @@
 	if (altroutegoals_setup)
 		return;
 #ifdef MISSIONPACK
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		if (trap_BotGetLevelItemGoal(-1, "Neutral Flag", &ctf_neutralflag) < 0)
 			BotAI_Print(PRT_WARNING, "no alt routes without Neutral Flag\n");
 		if (ctf_neutralflag.areanum) {
@@ -5402,12 +5467,18 @@
 	trap_Cvar_Register(&bot_predictobstacles, "bot_predictobstacles", "1", 0);
 	trap_Cvar_Register(&g_spSkill, "g_spSkill", "2", 0);
 	//
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		if (trap_BotGetLevelItemGoal(-1, "Red Flag", &ctf_redflag) < 0)
 			BotAI_Print(PRT_WARNING, "CTF without Red Flag\n");
 		if (trap_BotGetLevelItemGoal(-1, "Blue Flag", &ctf_blueflag) < 0)
 			BotAI_Print(PRT_WARNING, "CTF without Blue Flag\n");
 	}
+	else if (gametype == GT_DOUBLE_D) {
+		if (trap_BotGetLevelItemGoal(-1, "Red Flag", &ctf_redflag) < 0)
+			BotAI_Print(PRT_WARNING, "DD without Point A\n");
+		if (trap_BotGetLevelItemGoal(-1, "Blue Flag", &ctf_blueflag) < 0)
+			BotAI_Print(PRT_WARNING, "DD without Point B\n");
+	}
 #ifdef MISSIONPACK
 	else if (gametype == GT_1FCTF) {
 		if (trap_BotGetLevelItemGoal(-1, "Neutral Flag", &ctf_neutralflag) < 0)
Index: code/game/bg_lib.h
===================================================================
--- code/game/bg_lib.h	(revision 1145)
+++ code/game/bg_lib.h	(working copy)
@@ -26,13 +26,6 @@
 #ifndef BG_LIB_H
 #define BG_LIB_H
 
-//Ignore __attribute__ on non-gcc platforms
-#ifndef __GNUC__
-#ifndef __attribute__
-#define __attribute__(x)
-#endif
-#endif
-
 #ifndef NULL
 #define NULL ((void *)0)
 #endif
Index: code/game/g_client.c
===================================================================
--- code/game/g_client.c	(revision 1145)
+++ code/game/g_client.c	(working copy)
@@ -55,6 +55,10 @@
 	SP_info_player_deathmatch( ent );
 }
 
+//One for Double_D
+void SP_info_player_dd(gentity_t *ent) {
+}
+
 /*QUAKED info_player_intermission (1 0 1) (-16 -16 -24) (16 16 32)
 The intermission will be viewed from this point.  Target an info_notnull for the view direction.
 */
@@ -306,12 +310,24 @@
 ============
 */
 gentity_t *SelectSpectatorSpawnPoint( vec3_t origin, vec3_t angles ) {
+	//gentity_t	*spot;
+
 	FindIntermissionPoint();
 
 	VectorCopy( level.intermission_origin, origin );
 	VectorCopy( level.intermission_angle, angles );
 
-	return NULL;
+
+
+	//for some reason we need to return an specific point in elimination (this might not be neccecary anymore but to be sure...)
+	//if(g_gametype.integer == GT_ELIMINATION)
+	//	return SelectSpawnPoint( vec3_origin, origin, angles );
+
+	//VectorCopy (origin,spot->s.origin);
+	//spot->s.origin[2] += 9;
+	//VectorCopy (angles, spot->s.angles);
+
+	return NULL; //spot;
 }
 
 /*
@@ -499,16 +515,71 @@
 void respawn( gentity_t *ent ) {
 	gentity_t	*tent;
 
-	CopyToBodyQue (ent);
-	ClientSpawn(ent);
+	if((g_gametype.integer!=GT_ELIMINATION && g_gametype.integer!=GT_CTF_ELIMINATION && g_gametype.integer !=GT_LMS) && !ent->client->isEliminated)
+	{
+		ent->client->isEliminated = qtrue; //must not be true in warmup
+		CopyToBodyQue (ent);
+	}
 
-	// add a teleportation effect
-	tent = G_TempEntity( ent->client->ps.origin, EV_PLAYER_TELEPORT_IN );
-	tent->s.clientNum = ent->s.clientNum;
+	if(g_gametype.integer==GT_LMS) {
+		if(ent->client->pers.livesLeft>0)
+		{
+			//ent->client->pers.livesLeft--; Coutned down somewhere else
+			ent->client->isEliminated = qfalse;
+		}
+		else //We have used all our lives
+		{
+			if( ent->client->isEliminated!=qtrue) {
+				ent->client->isEliminated = qtrue;
+				if((g_lms_mode.integer == 2 || g_lms_mode.integer == 3) && level.roundNumber == level.roundNumberStarted)
+					LMSpoint();	
+				ent->client->sess.spectatorState = PM_SPECTATOR;			
+			}
+			return;
+		}
+	}
+
+	if((g_gametype.integer==GT_ELIMINATION || g_gametype.integer==GT_CTF_ELIMINATION) 
+			&& ent->client->ps.pm_type == PM_SPECTATOR && ent->client->ps.stats[STAT_HEALTH] > 0)
+		return;
+		ClientSpawn(ent);
+
+		// add a teleportation effect
+		if(g_gametype.integer!=GT_ELIMINATION && g_gametype.integer!=GT_CTF_ELIMINATION && g_gametype.integer!=GT_LMS)
+		{	
+			tent = G_TempEntity( ent->client->ps.origin, EV_PLAYER_TELEPORT_IN );
+			tent->s.clientNum = ent->s.clientNum;
+		}
 }
 
 /*
 ================
+respawnRound
+================
+*/
+void respawnRound( gentity_t *ent ) {
+	gentity_t	*tent;
+
+	//if(g_gametype.integer!=GT_ELIMINATION || !ent->client->isEliminated)
+	//{
+	//	ent->client->isEliminated  = qtrue;
+		//CopyToBodyQue (ent);
+	//}
+
+	//if(g_gametype.integer==GT_ELIMINATION && ent->client->ps.pm_type == PM_SPECTATOR && ent->client->ps.stats[STAT_HEALTH] > 0)
+	//	return;
+		ClientSpawn(ent);
+
+		// add a teleportation effect
+		if(g_gametype.integer!=GT_ELIMINATION && g_gametype.integer!=GT_CTF_ELIMINATION && g_gametype.integer!=GT_LMS)
+		{	
+			tent = G_TempEntity( ent->client->ps.origin, EV_PLAYER_TELEPORT_IN );
+			tent->s.clientNum = ent->s.clientNum;
+		}
+}
+
+/*
+================
 TeamCount
 
 Returns number of players on a team
@@ -535,6 +606,223 @@
 
 /*
 ================
+TeamLivingCount
+
+Returns number of living players on a team
+================
+*/
+team_t TeamLivingCount( int ignoreClientNum, int team ) {
+	int		i;
+	int		count = 0;
+	qboolean	LMS = (g_gametype.integer==GT_LMS);
+
+	for ( i = 0 ; i < level.maxclients ; i++ ) {
+		if ( i == ignoreClientNum ) {
+			continue;
+		}
+		if ( level.clients[i].pers.connected == CON_DISCONNECTED ) {
+			continue;
+		}
+		//crash if g_gametype.integer is used here, why?
+		if ( level.clients[i].sess.sessionTeam == team && (level.clients[i].ps.stats[STAT_HEALTH]>0 || LMS) && !(level.clients[i].isEliminated)) {
+			count++;
+		}
+	}
+
+	return count;
+}
+
+/*
+================
+TeamHealthCount
+
+Count total number of healthpoints on teh teams used for draws in Elimination
+================
+*/
+
+team_t TeamHealthCount(int ignoreClientNum, int team ) {
+	int 		i;
+	int 		count = 0;
+
+	for ( i = 0 ; i < level.maxclients ; i++ ) {
+		if ( i == ignoreClientNum ) {
+			continue;
+		}
+		if ( level.clients[i].pers.connected == CON_DISCONNECTED ) {
+			continue;
+		}
+		//only count clients with positive health
+		if ( level.clients[i].sess.sessionTeam == team && (level.clients[i].ps.stats[STAT_HEALTH]>0)&& !(level.clients[i].isEliminated)) {
+			count+=level.clients[i].ps.stats[STAT_HEALTH];
+		}
+	}
+
+	return count;
+}
+
+
+/*
+================
+RespawnAll
+
+Forces all clients to respawn.
+================
+*/
+
+void RespawnAll(void)
+{
+	int i;
+	gentity_t	*client;
+	for(i=0;i<level.maxclients;i++)
+	{
+		if ( level.clients[i].pers.connected == CON_DISCONNECTED ) {
+			continue;
+		}
+
+		if ( level.clients[i].sess.sessionTeam == TEAM_SPECTATOR ) {
+			continue;
+		}
+		client = g_entities + i;
+		client->client->ps.pm_type = PM_NORMAL;
+		client->client->pers.livesLeft = g_lms_lives.integer;
+		respawnRound(client);
+	}
+	return;
+}
+
+/*
+================
+RespawnDead
+
+Forces all *DEAD* clients to respawn.
+================
+*/
+
+void RespawnDead(void)
+{
+	int i;
+	gentity_t	*client;
+	for(i=0;i<level.maxclients;i++)
+	{
+		
+		if ( level.clients[i].pers.connected == CON_DISCONNECTED ) {
+			continue;
+		}
+		if ( level.clients[i].isEliminated == qfalse ){
+			continue;
+		}
+		if ( level.clients[i].sess.sessionTeam == TEAM_SPECTATOR ) {
+			continue;
+		}
+		client = g_entities + i;
+		client->client->pers.livesLeft = g_lms_lives.integer;
+		respawnRound(client);
+	}
+	return;
+}
+
+/*
+================
+DisableWeapons
+
+disables all weapons
+================
+*/
+
+void DisableWeapons(void)
+{
+	int i;
+	gentity_t	*client;
+	for(i=0;i<level.maxclients;i++)
+	{
+		if ( level.clients[i].pers.connected == CON_DISCONNECTED ) {
+			continue;
+		}
+
+		if ( level.clients[i].sess.sessionTeam == TEAM_SPECTATOR ) {
+			continue;
+		}
+		client = g_entities + i;
+		client->client->ps.pm_flags |= PMF_ELIMWARMUP;
+	}
+	return;
+}
+
+/*
+================
+EnableWeapons
+
+enables all weapons
+================
+*/
+
+void EnableWeapons(void)
+{
+	int i;
+	gentity_t	*client;
+	for(i=0;i<level.maxclients;i++)
+	{
+		if ( level.clients[i].pers.connected == CON_DISCONNECTED ) {
+			continue;
+		}
+
+		if ( level.clients[i].sess.sessionTeam == TEAM_SPECTATOR ) {
+			continue;
+		}
+
+		/*if ( level.clients[i].isEliminated == qtrue ){
+			continue;
+		}*/
+
+		client = g_entities + i;
+		client->client->ps.pm_flags &= ~PMF_ELIMWARMUP;
+	}
+	return;
+}
+
+/*
+================
+LMSpoint
+
+Gives a point to the lucky survivor
+================
+*/
+
+void LMSpoint(void)
+{
+	int i;
+	gentity_t	*client;
+	for(i=0;i<level.maxclients;i++)
+	{
+		if ( level.clients[i].pers.connected == CON_DISCONNECTED ) {
+			continue;
+		}
+
+		if ( level.clients[i].sess.sessionTeam == TEAM_SPECTATOR ) {
+			continue;
+		}
+
+		if ( level.clients[i].isEliminated == qtrue ){
+			continue;
+		}
+		
+		client = g_entities + i;
+		/*
+		Not good in mode 2 & 3
+		if ( client->health <= 0 ){
+			continue;
+		}
+		*/
+	
+		client->client->ps.persistant[PERS_SCORE] += 1;
+	}
+	
+	CalculateRanks();
+	return;
+}
+
+/*
+================
 TeamLeader
 
 Returns the client number of the team leader
@@ -739,10 +1027,19 @@
 	s = Info_ValueForKey (userinfo, "name");
 	ClientCleanName( s, client->pers.netname, sizeof(client->pers.netname) );
 
-	if ( client->sess.sessionTeam == TEAM_SPECTATOR ) {
-		if ( client->sess.spectatorState == SPECTATOR_SCOREBOARD ) {
-			Q_strncpyz( client->pers.netname, "scoreboard", sizeof(client->pers.netname) );
-		}
+	// N_G: this condition makes no sense to me and I'm not going to
+	// try finding out what it means, I've added parentheses according to
+	// evaluation rules of the original code so grab a
+	// parentheses pairing highlighting text editor and see for yourself
+	// if you got it right
+	//Sago: One redundant check and CTF Elim and LMS was missing. Not an important function and I might never have noticed, should properly be ||
+	if ( ( ( client->sess.sessionTeam == TEAM_SPECTATOR ) ||
+		( ( ( client->isEliminated ) /*||
+		( client->ps.pm_type == PM_SPECTATOR )*/ ) &&   //Sago: If this is true client.isEliminated or TEAM_SPECTATOR is true to and this is redundant
+		( g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_LMS) ) ) &&
+		( client->sess.spectatorState == SPECTATOR_SCOREBOARD ) ) {
+
+		Q_strncpyz( client->pers.netname, "scoreboard", sizeof(client->pers.netname) );
 	}
 
 	if ( client->pers.connected == CON_CONNECTED ) {
@@ -773,7 +1070,7 @@
 	client->ps.stats[STAT_MAX_HEALTH] = client->pers.maxHealth;
 
 	// set model
-	if( g_gametype.integer >= GT_TEAM ) {
+	if( g_gametype.integer >= GT_TEAM && g_ffa_gt==0) {
 		Q_strncpyz( model, Info_ValueForKey (userinfo, "team_model"), sizeof( model ) );
 		Q_strncpyz( headModel, Info_ValueForKey (userinfo, "team_headmodel"), sizeof( headModel ) );
 	} else {
@@ -782,7 +1079,7 @@
 	}
 
 	// bots set their team a few frames later
-	if (g_gametype.integer >= GT_TEAM && g_entities[clientNum].r.svFlags & SVF_BOT) {
+	if (g_gametype.integer >= GT_TEAM && g_ffa_gt==0 && g_entities[clientNum].r.svFlags & SVF_BOT) {
 		s = Info_ValueForKey( userinfo, "team" );
 		if ( !Q_stricmp( s, "red" ) || !Q_stricmp( s, "r" ) ) {
 			team = TEAM_RED;
@@ -819,7 +1116,7 @@
 */
 
 #ifdef MISSIONPACK
-	if (g_gametype.integer >= GT_TEAM) {
+	if (g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		client->pers.teamInfo = qtrue;
 	} else {
 		s = Info_ValueForKey( userinfo, "teamoverlay" );
@@ -1012,6 +1309,13 @@
 	client->pers.enterTime = level.time;
 	client->pers.teamState.state = TEAM_BEGIN;
 
+	//Elimination:
+	client->pers.roundReached = 0; //We will spawn in next round
+	if(g_gametype.integer == GT_LMS) {
+		client->isEliminated = qtrue; //So player does not give a point in gamemode 2 and 3
+		//trap_SendServerCommand( -1, va("print \"%s" S_COLOR_WHITE " will start dead\n\"", client->pers.netname) );
+	}
+
 	// save eflags around this, because changing teams will
 	// cause this to happen with a valid entity, and we
 	// want to make sure the teleport bit is set right
@@ -1024,7 +1328,13 @@
 	// locate ent at a spawn point
 	ClientSpawn( ent );
 
-	if ( client->sess.sessionTeam != TEAM_SPECTATOR ) {
+	// N_G: I'm really sure line 1333 is not what you meant
+	if( ( client->sess.sessionTeam != TEAM_SPECTATOR ) &&
+		( ( !( client->isEliminated ) /*&&
+		( ( !client->ps.pm_type ) == PM_SPECTATOR ) */ ) || //Sago: Yes, it made no sense 
+		( ( g_gametype.integer != GT_ELIMINATION ) &&
+		( g_gametype.integer != GT_CTF_ELIMINATION ) &&
+		( g_gametype.integer != GT_LMS ) ) ) ) {
 		// send event
 		tent = G_TempEntity( ent->client->ps.origin, EV_PLAYER_TELEPORT_IN );
 		tent->s.clientNum = ent->s.clientNum;
@@ -1067,13 +1377,67 @@
 	index = ent - g_entities;
 	client = ent->client;
 
+	//In Elimination the player should not spawn if he have already spawned in the round (but not for spectators)
+	// N_G: You've obviously wanted something ELSE
+	//Sago: Yes, the !level.intermissiontime is currently redundant but it might still be the bast place to make the test, CheckElimination in g_main makes sure the next if will fail and the rest of the things this block does might not affect if in Intermission (I'll just test that)
+	if( ( ( g_gametype.integer == GT_ELIMINATION ||
+		g_gametype.integer == GT_CTF_ELIMINATION ) &&
+		!level.intermissiontime  ) &&
+		( client->sess.sessionTeam != TEAM_SPECTATOR ) )
+	{
+		// N_G: Another condition that makes no sense to me, see for
+		// yourself if you really meant this
+		// Sago: I beleive the TeamCount is to make sure people can join even if the game can't start
+		if( ( level.roundNumber == level.roundNumberStarted ) ||
+			( (level.time < level.roundStartTime - g_elimination_activewarmup.integer*1000 ) &&
+			TeamCount( -1, TEAM_BLUE ) &&
+			TeamCount( -1, TEAM_RED )  ) )
+		{	
+			client->sess.spectatorState = SPECTATOR_FREE;
+			client->isEliminated = qtrue;
+			client->ps.pm_type = PM_SPECTATOR;
+			return;
+		}
+		else
+		{
+			client->pers.roundReached = level.roundNumber+1;
+			client->sess.spectatorState = SPECTATOR_NOT;
+			client->ps.pm_type = PM_NORMAL;
+			client->isEliminated = qfalse;
+		}
+	}
+
+	if(g_gametype.integer == GT_LMS && client->sess.sessionTeam != TEAM_SPECTATOR && !level.intermissiontime)
+	{
+		if(level.roundNumber==level.roundNumberStarted /*|| level.time<level.roundStartTime-g_elimination_activewarmup.integer*1000*/ && 1>client->pers.livesLeft)
+		{	
+			client->sess.spectatorState = SPECTATOR_FREE;
+			if( ent->client->isEliminated!=qtrue) {
+				client->isEliminated = qtrue;
+				if((g_lms_mode.integer == 2 || g_lms_mode.integer == 3) && level.roundNumber == level.roundNumberStarted)
+					LMSpoint();
+			}
+			client->ps.pm_type = PM_SPECTATOR;
+			return;
+		}
+		
+		client->sess.spectatorState = SPECTATOR_NOT;
+		client->ps.pm_type = PM_NORMAL;
+		client->isEliminated = qfalse;
+		if(client->pers.livesLeft>0)
+			client->pers.livesLeft--;
+	}
+
 	// find a spawn point
 	// do it before setting health back up, so farthest
 	// ranging doesn't count this client
-	if ( client->sess.sessionTeam == TEAM_SPECTATOR ) {
-		spawnPoint = SelectSpectatorSpawnPoint ( 
-						spawn_origin, spawn_angles);
-	} else if (g_gametype.integer >= GT_CTF ) {
+	if ((client->sess.sessionTeam == TEAM_SPECTATOR) 
+			|| ( (client->ps.pm_type == PM_SPECTATOR || client->isEliminated )  && (g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION) ) ) {
+		spawnPoint = SelectSpectatorSpawnPoint ( spawn_origin, spawn_angles);
+	} else if (g_gametype.integer == GT_DOUBLE_D) {
+		//Double Domination uses special spawn points:
+		spawnPoint = SelectDoubleDominationSpawnPoint (spawn_origin, spawn_angles);
+	} else if (g_gametype.integer >= GT_CTF && g_ffa_gt==0) {
 		// all base oriented team games use the CTF spawn points
 		spawnPoint = SelectCTFSpawnPoint ( 
 						client->sess.sessionTeam, 
@@ -1176,6 +1540,8 @@
 
 	client->ps.clientNum = index;
 
+if(g_gametype.integer != GT_ELIMINATION && g_gametype.integer != GT_CTF_ELIMINATION && g_gametype.integer != GT_LMS)
+{
 	client->ps.stats[STAT_WEAPONS] = ( 1 << WP_MACHINEGUN );
 	if ( g_gametype.integer == GT_TEAM ) {
 		client->ps.ammo[WP_MACHINEGUN] = 50;
@@ -1189,17 +1555,90 @@
 
 	// health will count down towards max_health
 	ent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] + 25;
+}
+else
+{
+	client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_GAUNTLET );
+	client->ps.ammo[WP_GAUNTLET] = -1;
+	client->ps.ammo[WP_GRAPPLING_HOOK] = -1;
+	if (g_elimination_machinegun.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_MACHINEGUN );
+		client->ps.ammo[WP_MACHINEGUN] = g_elimination_machinegun.integer;
+	}
+	if (g_elimination_shotgun.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_SHOTGUN );
+		client->ps.ammo[WP_SHOTGUN] = g_elimination_shotgun.integer;
+	}
+	if (g_elimination_grenade.integer > 0) {	
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_GRENADE_LAUNCHER );
+		client->ps.ammo[WP_GRENADE_LAUNCHER] = g_elimination_grenade.integer;
+	}
+	if (g_elimination_rocket.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_ROCKET_LAUNCHER );
+		client->ps.ammo[WP_ROCKET_LAUNCHER] = g_elimination_rocket.integer;
+	}
+	if (g_elimination_lightning.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_LIGHTNING );
+		client->ps.ammo[WP_LIGHTNING] = g_elimination_lightning.integer;
+	}
+	if (g_elimination_railgun.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_RAILGUN );
+		client->ps.ammo[WP_RAILGUN] = g_elimination_railgun.integer;
+	}
+	if (g_elimination_plasmagun.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_PLASMAGUN );
+		client->ps.ammo[WP_PLASMAGUN] = g_elimination_plasmagun.integer;
+	}
+	if (g_elimination_bfg.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_BFG );
+		client->ps.ammo[WP_BFG] = g_elimination_bfg.integer;
+	}
+#ifdef MISSIONPACK
+	if (g_elimination_nail.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_NAILGUN );
+		client->ps.ammo[WP_NAILGUN] = g_elimination_nail.integer;
+	}
+	if (g_elimination_mine.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_PROX_LAUNCHER );
+		client->ps.ammo[WP_PROX_LAUNCHER] = g_elimination_mine.integer;
+	}
+	if (g_elimination_chain.integer > 0) {
+		client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_CHAINGUN );
+		client->ps.ammo[WP_CHAINGUN] = g_elimination_chain.integer;
+	}
+#endif
+	
+	ent->health = client->ps.stats[STAT_ARMOR] = g_elimination_startArmor.integer; //client->ps.stats[STAT_MAX_HEALTH]*2;
+	ent->health = client->ps.stats[STAT_HEALTH] = g_elimination_startHealth.integer; //client->ps.stats[STAT_MAX_HEALTH]*2;	
 
+	
+	//	ent->health = client->ps.stats[STAT_HEALTH] = 0;
+}
+	//Instantgib mode, replace weapons with rail (and maybe gauntlet)
+	if(g_instantgib.integer)
+	{
+		client->ps.stats[STAT_WEAPONS] = ( 1 << WP_RAILGUN );
+		client->ps.ammo[WP_RAILGUN] = 999; //Don't display any ammo
+		if(g_instantgib.integer>1)
+		{
+			 client->ps.stats[STAT_WEAPONS] |= ( 1 << WP_GAUNTLET );
+	              	client->ps.ammo[WP_GAUNTLET] = -1;
+		}
+	}
+
 	G_SetOrigin( ent, spawn_origin );
 	VectorCopy( spawn_origin, client->ps.origin );
 
 	// the respawned flag will be cleared after the attack and jump keys come up
 	client->ps.pm_flags |= PMF_RESPAWNED;
+	if(g_gametype.integer==GT_ELIMINATION || g_gametype.integer==GT_CTF_ELIMINATION || g_gametype.integer==GT_LMS)	
+		client->ps.pm_flags |= PMF_ELIMWARMUP;
 
 	trap_GetUsercmd( client - level.clients, &ent->client->pers.cmd );
 	SetClientViewAngle( ent, spawn_angles );
 
-	if ( ent->client->sess.sessionTeam == TEAM_SPECTATOR ) {
+	if ( (ent->client->sess.sessionTeam == TEAM_SPECTATOR) || ((client->ps.pm_type == PM_SPECTATOR || client->isEliminated) && 
+		(g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_LMS) ) ) {
 
 	} else {
 		G_KillBox( ent );
@@ -1247,7 +1686,8 @@
 	ClientThink( ent-g_entities );
 
 	// positively link the client, even if the command times are weird
-	if ( ent->client->sess.sessionTeam != TEAM_SPECTATOR ) {
+	if ( (ent->client->sess.sessionTeam != TEAM_SPECTATOR) || ( (!client->isEliminated || client->ps.pm_type != PM_SPECTATOR)&& 
+		(g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_LMS) ) ) {
 		BG_PlayerStateToEntityState( &client->ps, &ent->s, qtrue );
 		VectorCopy( ent->client->ps.origin, ent->r.currentOrigin );
 		trap_LinkEntity( ent );
@@ -1289,7 +1729,7 @@
 
 	// stop any following clients
 	for ( i = 0 ; i < level.maxclients ; i++ ) {
-		if ( level.clients[i].sess.sessionTeam == TEAM_SPECTATOR
+		if ( (level.clients[i].sess.sessionTeam == TEAM_SPECTATOR || level.clients[i].ps.pm_type == PM_SPECTATOR)
 			&& level.clients[i].sess.spectatorState == SPECTATOR_FOLLOW
 			&& level.clients[i].sess.spectatorClient == clientNum ) {
 			StopFollowing( &g_entities[i] );
Index: code/game/g_items.c
===================================================================
--- code/game/g_items.c	(revision 1145)
+++ code/game/g_items.c	(working copy)
@@ -86,7 +86,7 @@
 
     // if same team in team game, no sound
     // cannot use OnSameTeam as it expects to g_entities, not clients
-  	if ( g_gametype.integer >= GT_TEAM && other->client->sess.sessionTeam == client->sess.sessionTeam  ) {
+  	if ( g_gametype.integer >= GT_TEAM && g_ffa_gt==0 && other->client->sess.sessionTeam == client->sess.sessionTeam  ) {
       continue;
     }
 
@@ -419,6 +419,23 @@
 	int			respawn;
 	qboolean	predict;
 
+	//instant gib
+	if ((g_instantgib.integer || g_gametype.integer == GT_CTF_ELIMINATION) && ent->item->giType != IT_TEAM)
+		return;
+
+	//Cannot touch flag before round starts
+	if(g_gametype.integer == GT_CTF_ELIMINATION && level.roundNumber != level.roundNumberStarted)
+		return;
+
+	//Cannot take ctf elimination oneway
+	if(g_gametype.integer == GT_CTF_ELIMINATION && g_elimination_ctf_oneway.integer!=0 && (
+			(other->client->sess.sessionTeam==TEAM_BLUE && (level.eliminationSides+level.roundNumber)%2 == 0 ) ||
+			(other->client->sess.sessionTeam==TEAM_RED && (level.eliminationSides+level.roundNumber)%2 != 0 ) ))
+		return;
+
+	if (g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_LMS)
+		return;		//nothing to pick up in elimination
+
 	if (!other->client)
 		return;
 	if (other->health < 1)
@@ -429,6 +446,16 @@
 		return;
 	}
 
+	//In double DD we cannot "pick up" a flag we already got
+	if(g_gametype.integer == GT_DOUBLE_D) {
+		if( strcmp(ent->classname, "team_CTF_redflag") == 0 )
+			if(other->client->sess.sessionTeam == level.pointStatusA)
+				return;
+		if( strcmp(ent->classname, "team_CTF_blueflag") == 0 )
+			if(other->client->sess.sessionTeam == level.pointStatusB)
+				return;
+	}
+
 	G_LogPrintf( "Item: %i %s\n", other->s.number, ent->item->classname );
 
 	predict = other->client->pers.predictItemPickup;
@@ -584,9 +611,9 @@
 
 	dropped->s.eFlags |= EF_BOUNCE_HALF;
 #ifdef MISSIONPACK
-	if ((g_gametype.integer == GT_CTF || g_gametype.integer == GT_1FCTF)			&& item->giType == IT_TEAM) { // Special case for CTF flags
+	if ((g_gametype.integer == GT_CTF || g_gametype.integer == GT_1FCTF || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_DOUBLE_D)			&& item->giType == IT_TEAM) { // Special case for CTF flags
 #else
-	if (g_gametype.integer == GT_CTF && item->giType == IT_TEAM) { // Special case for CTF flags
+	if ((g_gametype.integer == GT_CTF || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_DOUBLE_D)&& item->giType == IT_TEAM) { // Special case for CTF flags
 #endif
 		dropped->think = Team_DroppedFlagThink;
 		dropped->nextthink = level.time + 30000;
@@ -689,7 +716,9 @@
 		return;
 	}
 
-	// powerups don't spawn in for a while
+	
+	// powerups don't spawn in for a while (but not in elimination)
+	if(g_gametype.integer != GT_ELIMINATION && g_gametype.integer != GT_CTF_ELIMINATION && g_gametype.integer != GT_LMS && !g_instantgib.integer)	
 	if ( ent->item->giType == IT_POWERUP ) {
 		float	respawn;
 
@@ -718,7 +747,7 @@
 	// Set up team stuff
 	Team_InitGame();
 
-	if( g_gametype.integer == GT_CTF ) {
+	if( g_gametype.integer == GT_CTF || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_DOUBLE_D) {
 		gitem_t	*item;
 
 		// check for the two flags
@@ -800,15 +829,49 @@
 void ClearRegisteredItems( void ) {
 	memset( itemRegistered, 0, sizeof( itemRegistered ) );
 
-	// players always start with the base weapon
-	RegisterItem( BG_FindItemForWeapon( WP_MACHINEGUN ) );
-	RegisterItem( BG_FindItemForWeapon( WP_GAUNTLET ) );
+	if(g_instantgib.integer) {
+		//Always load Gauntlet and machine gun because g_instantgib might suddenly change
+		RegisterItem( BG_FindItemForWeapon( WP_GAUNTLET ) );
+		RegisterItem( BG_FindItemForWeapon( WP_MACHINEGUN ) );
+		RegisterItem( BG_FindItemForWeapon( WP_RAILGUN ) );
+	}
+	else
+	{
+		// players always start with the base weapon
+		RegisterItem( BG_FindItemForWeapon( WP_MACHINEGUN ) );
+		RegisterItem( BG_FindItemForWeapon( WP_GAUNTLET ) );
+		if(g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_CTF_ELIMINATION || g_gametype.integer == GT_LMS)
+		{
+			RegisterItem( BG_FindItemForWeapon( WP_SHOTGUN ) );
+			RegisterItem( BG_FindItemForWeapon( WP_GRENADE_LAUNCHER ) );
+			RegisterItem( BG_FindItemForWeapon( WP_ROCKET_LAUNCHER ) );
+			RegisterItem( BG_FindItemForWeapon( WP_LIGHTNING ) );
+			RegisterItem( BG_FindItemForWeapon( WP_RAILGUN ) );
+			RegisterItem( BG_FindItemForWeapon( WP_PLASMAGUN ) );
+			RegisterItem( BG_FindItemForWeapon( WP_BFG ) );
 #ifdef MISSIONPACK
+			RegisterItem( BG_FindItemForWeapon( WP_NAILGUN ) );
+			RegisterItem( BG_FindItemForWeapon( WP_PROX_LAUNCHER ) );
+			RegisterItem( BG_FindItemForWeapon( WP_CHAINGUN ) );
+#endif
+		}
+	}
+#ifdef MISSIONPACK
 	if( g_gametype.integer == GT_HARVESTER ) {
 		RegisterItem( BG_FindItem( "Red Cube" ) );
 		RegisterItem( BG_FindItem( "Blue Cube" ) );
 	}
 #endif
+	if(g_gametype.integer == GT_DOUBLE_D ) {
+		RegisterItem( BG_FindItem( "Point A (Blue)" ) );
+		RegisterItem( BG_FindItem( "Point A (Red)" ) );
+		RegisterItem( BG_FindItem( "Point A (White)" ) );
+		RegisterItem( BG_FindItem( "Point B (Blue)" ) );
+		RegisterItem( BG_FindItem( "Point B (Red)" ) );
+		RegisterItem( BG_FindItem( "Point B (White)" ) );
+	}
+
+	
 }
 
 /*
@@ -881,9 +944,18 @@
 	G_SpawnFloat( "random", "0", &ent->random );
 	G_SpawnFloat( "wait", "0", &ent->wait );
 
-	RegisterItem( item );
-	if ( G_ItemDisabled(item) )
-		return;
+	//Load all items in instantgib anyway or we will be in trouble if it is suddenly disabled!
+	//if((item->giType == IT_TEAM && g_instantgib.integer) || !g_instantgib.integer)
+	{
+		//Don't load pickups in Elimination (or maybe... gives warnings)
+		if (g_gametype.integer != GT_ELIMINATION && g_gametype.integer != GT_CTF_ELIMINATION && g_gametype.integer != GT_LMS)
+			RegisterItem( item );
+		//Registrer flags anyway in CTF Elimination:
+		if (g_gametype.integer == GT_CTF_ELIMINATION && item->giType == IT_TEAM)
+			RegisterItem( item );
+		if ( G_ItemDisabled(item) )
+			return;
+	}
 
 	ent->item = item;
 	// some movers spawn on the second frame, so delay item
@@ -893,6 +965,17 @@
 
 	ent->physicsBounce = 0.50;		// items are bouncy
 
+	if (g_gametype.integer == GT_ELIMINATION || g_gametype.integer == GT_LMS || 
+			( item->giType != IT_TEAM && (g_instantgib.integer || g_gametype.integer==GT_CTF_ELIMINATION) ) )
+		ent->s.eFlags |= EF_NODRAW; //Invisible in elimination
+
+	if(g_gametype.integer == GT_DOUBLE_D && (strcmp(ent->classname, "team_CTF_redflag")==0 || strcmp(ent->classname, "team_CTF_blueflag")==0 || strcmp(ent->classname, "team_CTF_neutralflag") == 0 || item->giType == IT_PERSISTANT_POWERUP  ))
+		ent->s.eFlags |= EF_NODRAW; //Don't draw the flag models/persistant powerups
+
+#ifdef MISSIONPACK
+	if(g_gametype.integer == GT_CTF_ELIMINATION && strcmp(ent->classname, "team_CTF_neutralflag") == 0)
+		ent->s.eFlags |= EF_NODRAW; // Don't draw the flag in CTF_elimination
+#endif
 	if ( item->giType == IT_POWERUP ) {
 		G_SoundIndex( "sound/items/poweruprespawn.wav" );
 		G_SpawnFloat( "noglobalsound", "0", &ent->speed);
Index: code/game/bg_public.h
===================================================================
--- code/game/bg_public.h	(revision 1145)
+++ code/game/bg_public.h	(working copy)
@@ -102,11 +102,22 @@
 	//-- team games go after this --
 
 	GT_TEAM,			// team deathmatch
-	GT_CTF,				// capture the flag
+
+	//-- team games that uses bases go after this
+
+	GT_CTF,				// capture the flag	
 	GT_1FCTF,
 	GT_OBELISK,
-	GT_HARVESTER,
+	GT_HARVESTER,	
+	
+	//-- custom game types, there will be a variable in 
+	
+	GT_ELIMINATION,			// team elimination (custom)
+	GT_CTF_ELIMINATION,		// ctf elimination
+	GT_LMS,				// Last man standing
+	GT_DOUBLE_D,			// Double Domination
 	GT_MAX_GAME_TYPE
+	
 } gametype_t;
 
 typedef enum { GENDER_MALE, GENDER_FEMALE, GENDER_NEUTER } gender_t;
@@ -153,6 +164,9 @@
 #define PMF_FOLLOW			4096	// spectate following another player
 #define PMF_SCOREBOARD		8192	// spectate as a scoreboard
 #define PMF_INVULEXPAND		16384	// invulnerability sphere set to full size
+//Elimination players cannot fire in warmup
+#define PMF_ELIMWARMUP		32768	//I hope this is more than 16 signed bits! (it's not but it just works anyway...)
+//Don't add anymore, I have already set the sign bit :-(
 
 #define	PMF_ALL_TIMES	(PMF_TIME_WATERJUMP|PMF_TIME_LAND|PMF_TIME_KNOCKBACK)
 
@@ -300,7 +314,18 @@
 	HI_NUM_HOLDABLE
 } holdable_t;
 
+typedef enum {
+	DD_NONE,
 
+	DD_POINTARED,
+	DD_POINTABLUE,
+	DD_POINTAWHITE,
+	DD_POINTBRED,
+	DD_POINTBBLUE,
+	DD_POINTBWHITE
+} doubled_t;
+
+
 typedef enum {
 	WP_NONE,
 
@@ -550,6 +575,9 @@
 	TEAM_NUM_TEAMS
 } team_t;
 
+// This is a fair assumption for Double Domination:
+#define TEAM_NONE TEAM_SPECTATOR
+
 // Time between location updates
 #define TEAM_LOCATION_UPDATE_TIME		1000
 
Index: code/game/g_cmds.c
===================================================================
--- code/game/g_cmds.c	(revision 1145)
+++ code/game/g_cmds.c	(working copy)
@@ -64,8 +64,9 @@
 		}
 		perfect = ( cl->ps.persistant[PERS_RANK] == 0 && cl->ps.persistant[PERS_KILLED] == 0 ) ? 1 : 0;
 
+
 		Com_sprintf (entry, sizeof(entry),
-			" %i %i %i %i %i %i %i %i %i %i %i %i %i %i", level.sortedClients[i],
+			" %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i", level.sortedClients[i],
 			cl->ps.persistant[PERS_SCORE], ping, (level.time - cl->pers.enterTime)/60000,
 			scoreFlags, g_entities[level.sortedClients[i]].s.powerups, accuracy, 
 			cl->ps.persistant[PERS_IMPRESSIVE_COUNT],
@@ -74,7 +75,8 @@
 			cl->ps.persistant[PERS_DEFEND_COUNT], 
 			cl->ps.persistant[PERS_ASSIST_COUNT], 
 			perfect,
-			cl->ps.persistant[PERS_CAPTURES]);
+			cl->ps.persistant[PERS_CAPTURES],
+			cl->isEliminated);
 		j = strlen(entry);
 		if (stringlength + j > 1024)
 			break;
@@ -82,14 +84,50 @@
 		stringlength += j;
 	}
 
-	trap_SendServerCommand( ent-g_entities, va("scores %i %i %i%s", i, 
-		level.teamScores[TEAM_RED], level.teamScores[TEAM_BLUE],
+	trap_SendServerCommand( ent-g_entities, va("scores %i %i %i %i%s", i, 
+		level.teamScores[TEAM_RED], level.teamScores[TEAM_BLUE], level.roundStartTime,
 		string ) );
 }
 
+/*
+==================
+EliminationMessage
 
+==================
+*/
+
+void EliminationMessage(gentity_t *ent) {
+	trap_SendServerCommand( ent-g_entities, va("elimination %i %i %i", 
+		level.teamScores[TEAM_RED], level.teamScores[TEAM_BLUE], level.roundStartTime) );
+}
+
 /*
 ==================
+DoubleDominationScoreTime
+
+==================
+*/
+void DoubleDominationScoreTimeMessage( gentity_t *ent ) {
+	trap_SendServerCommand( ent-g_entities, va("ddtaken %i", level.timeTaken));
+}
+
+/*
+==================
+AttackingTeamMessage
+
+==================
+*/
+void AttackingTeamMessage( gentity_t *ent ) {
+	int team;
+	if ( (level.eliminationSides+level.roundNumber)%2 == 0 )
+		team = TEAM_RED;
+	else
+		team = TEAM_BLUE;
+	trap_SendServerCommand( ent-g_entities, va("attackingteam %i", team));
+}
+
+/*
+==================
 Cmd_Score_f
 
 Request current scoreboard information
@@ -462,7 +500,7 @@
 =================
 */
 void Cmd_Kill_f( gentity_t *ent ) {
-	if ( ent->client->sess.sessionTeam == TEAM_SPECTATOR ) {
+	if ( (ent->client->sess.sessionTeam == TEAM_SPECTATOR) || ent->client->isEliminated ) {
 		return;
 	}
 	if (ent->health <= 0) {
@@ -532,7 +570,7 @@
 	} else if ( !Q_stricmp( s, "spectator" ) || !Q_stricmp( s, "s" ) ) {
 		team = TEAM_SPECTATOR;
 		specState = SPECTATOR_FREE;
-	} else if ( g_gametype.integer >= GT_TEAM ) {
+	} else if ( g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		// if running a team game, assign player to one of the teams
 		specState = SPECTATOR_NOT;
 		if ( !Q_stricmp( s, "red" ) || !Q_stricmp( s, "r" ) ) {
@@ -644,8 +682,16 @@
 =================
 */
 void StopFollowing( gentity_t *ent ) {
-	ent->client->ps.persistant[ PERS_TEAM ] = TEAM_SPECTATOR;	
-	ent->client->sess.sessionTeam = TEAM_SPECTATOR;	
+	if(g_gametype.integer<GT_ELIMINATION || g_gametype.integer>GT_LMS)
+	{
+		//Shouldn't this already be the case?
+		ent->client->ps.persistant[ PERS_TEAM ] = TEAM_SPECTATOR;	
+		ent->client->sess.sessionTeam = TEAM_SPECTATOR;	
+	}
+	else {
+		ent->client->ps.stats[STAT_HEALTH] = 0;
+		ent->health = 0;
+	}
 	ent->client->sess.spectatorState = SPECTATOR_FREE;
 	ent->client->ps.pm_flags &= ~PMF_FOLLOW;
 	ent->r.svFlags &= ~SVF_BOT;
@@ -708,6 +754,10 @@
 	int		i;
 	char	arg[MAX_TOKEN_CHARS];
 
+	//Don't folow in elimination mode, or player will get wrong score
+	/*if(ent->client->sess.sessionTeam != TEAM_SPECTATOR && g_gametype.integer>=GT_ELIMINATION && g_gametype.integer<=GT_LMS)
+		return;*/
+	
 	if ( trap_Argc() != 2 ) {
 		if ( ent->client->sess.spectatorState == SPECTATOR_FOLLOW ) {
 			StopFollowing( ent );
@@ -715,19 +765,22 @@
 		return;
 	}
 
+
 	trap_Argv( 1, arg, sizeof( arg ) );
 	i = ClientNumberFromString( ent, arg );
 	if ( i == -1 ) {
 		return;
 	}
 
+	
+
 	// can't follow self
 	if ( &level.clients[ i ] == ent->client ) {
 		return;
 	}
 
-	// can't follow another spectator
-	if ( level.clients[ i ].sess.sessionTeam == TEAM_SPECTATOR ) {
+	// can't follow another spectator (or an eliminated player)
+	if ( (level.clients[ i ].sess.sessionTeam == TEAM_SPECTATOR) || level.clients[ i ].isEliminated) {
 		return;
 	}
 
@@ -738,7 +791,8 @@
 	}
 
 	// first set them to spectator
-	if ( ent->client->sess.sessionTeam != TEAM_SPECTATOR ) {
+	//if ( ent->client->sess.sessionTeam != TEAM_SPECTATOR ) {
+	if ( ent->client->sess.spectatorState == SPECTATOR_NOT ) {
 		SetTeam( ent, "spectator" );
 	}
 
@@ -786,7 +840,7 @@
 		}
 
 		// can't follow another spectator
-		if ( level.clients[ clientnum ].sess.sessionTeam == TEAM_SPECTATOR ) {
+		if ( (level.clients[ clientnum ].sess.sessionTeam == TEAM_SPECTATOR) || level.clients[ clientnum ].isEliminated) {
 			continue;
 		}
 
@@ -845,7 +899,7 @@
 	char		text[MAX_SAY_TEXT];
 	char		location[64];
 
-	if ( g_gametype.integer < GT_TEAM && mode == SAY_TEAM ) {
+	if ( (g_gametype.integer < GT_TEAM || g_ffa_gt == 1) && mode == SAY_TEAM ) {
 		mode = SAY_ALL;
 	}
 
@@ -867,7 +921,7 @@
 		color = COLOR_CYAN;
 		break;
 	case SAY_TELL:
-		if (target && g_gametype.integer >= GT_TEAM &&
+		if (target && g_gametype.integer >= GT_TEAM && g_ffa_gt != 1 &&
 			target->client->sess.sessionTeam == ent->client->sess.sessionTeam &&
 			Team_GetLocationMsg(ent, location, sizeof(location)))
 			Com_sprintf (name, sizeof(name), EC"[%s%c%c"EC"] (%s)"EC": ", ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE, location );
@@ -1000,7 +1054,7 @@
 	int			j;
 	gentity_t	*other;
 
-	if ( g_gametype.integer < GT_TEAM && mode == SAY_TEAM ) {
+	if ( (g_gametype.integer < GT_TEAM || g_ffa_gt==1 ) && mode == SAY_TEAM ) {
 		mode = SAY_ALL;
 	}
 
@@ -1133,7 +1187,7 @@
 		}
 	}
 
-	if (g_gametype.integer >= GT_TEAM) {
+	if (g_gametype.integer >= GT_TEAM && g_ffa_gt!=1) {
 		// praise a team mate who just got a reward
 		for(i = 0; i < MAX_CLIENTS; i++) {
 			who = g_entities + i;
@@ -1204,7 +1258,11 @@
 	"Capture the Flag",
 	"One Flag CTF",
 	"Overload",
-	"Harvester"
+	"Harvester",
+	"Elimination",
+	"CTF Elimination",
+	"Last Man Standing",
+	"Double Domination"
 };
 
 /*
@@ -1696,6 +1754,8 @@
 		Cmd_SetViewpos_f( ent );
 	else if (Q_stricmp (cmd, "stats") == 0)
 		Cmd_Stats_f( ent );
+	else if (Q_stricmp (cmd, "free_spectator") == 0)
+		StopFollowing( ent );
 	else
 		trap_SendServerCommand( clientNum, va("print \"unknown cmd %s\n\"", cmd ) );
 }
Index: code/game/g_team.c
===================================================================
--- code/game/g_team.c	(revision 1145)
+++ code/game/g_team.c	(working copy)
@@ -40,6 +40,10 @@
 
 gentity_t	*neutralObelisk;
 
+//Some pointers for Double Domination so we don't need GFind (I think it might crash at random times...)
+gentity_t	*ddA;
+gentity_t	*ddB;
+
 void Team_SetFlagStatus( int team, flagStatus_t status );
 
 void Team_InitGame( void ) {
@@ -47,10 +51,14 @@
 
 	switch( g_gametype.integer ) {
 	case GT_CTF:
+	case GT_CTF_ELIMINATION:
+	case GT_DOUBLE_D:
 		teamgame.redStatus = -1; // Invalid to force update
 		Team_SetFlagStatus( TEAM_RED, FLAG_ATBASE );
 		 teamgame.blueStatus = -1; // Invalid to force update
 		Team_SetFlagStatus( TEAM_BLUE, FLAG_ATBASE );
+		ddA = NULL;
+		ddB = NULL;
 		break;
 #ifdef MISSIONPACK
 	case GT_1FCTF:
@@ -177,7 +185,7 @@
 		return qfalse;
 	}
 
-	if ( g_gametype.integer < GT_TEAM ) {
+	if ( g_gametype.integer < GT_TEAM || g_ffa_gt==1) {
 		return qfalse;
 	}
 
@@ -218,14 +226,20 @@
 		break;
 	}
 
+
 	if( modified ) {
 		char st[4];
 
-		if( g_gametype.integer == GT_CTF ) {
+		if( g_gametype.integer == GT_CTF || g_gametype.integer == GT_CTF_ELIMINATION) {
 			st[0] = ctfFlagStatusRemap[teamgame.redStatus];
 			st[1] = ctfFlagStatusRemap[teamgame.blueStatus];
 			st[2] = 0;
 		}
+		else if (g_gametype.integer == GT_DOUBLE_D) {
+			st[0] = oneFlagStatusRemap[teamgame.redStatus];
+			st[1] = oneFlagStatusRemap[teamgame.blueStatus];
+			st[2] = 0;
+		}
 		else {		// GT_1FCTF
 			st[0] = oneFlagStatusRemap[teamgame.flagStatus];
 			st[1] = 0;
@@ -264,13 +278,47 @@
 			continue;
 		if (ent->client->sess.sessionTeam != team)
 			continue;
-		//
 		ent->flags |= FL_FORCE_GESTURE;
 	}
 }
 
 /*
 ================
+Team_DD_bonusAtPoints
+Adds bonus point to a player if he is close to the point and on the team that scores 
+================
+*/
+
+void Team_DD_bonusAtPoints(int team) {
+	vec3_t v1, v2;
+	int i;
+	gentity_t *player;
+
+	for (i = 0; i < MAX_CLIENTS; i++) {
+		player = &g_entities[i];
+		if (!player->inuse)
+			continue;
+		if (!player->client)
+			continue;
+		
+		if( player->client->sess.sessionTeam != team )
+			return; //player was not on scoring team 
+
+		//See if the player is close to any of the points:
+		VectorSubtract(player->r.currentOrigin, ddA->r.currentOrigin, v1);
+		VectorSubtract(player->r.currentOrigin, ddB->r.currentOrigin, v2);
+		if (!( ( ( VectorLength(v1) < CTF_TARGET_PROTECT_RADIUS &&
+				trap_InPVS(ddA->r.currentOrigin, player->r.currentOrigin ) ) ||
+				( VectorLength(v2) < CTF_TARGET_PROTECT_RADIUS &&
+				trap_InPVS(ddB->r.currentOrigin, player->r.currentOrigin ) ) )))
+					return; //Wasn't close to any of the points
+	
+		AddScore(player, player->r.currentOrigin, DD_AT_POINT_AT_CAPTURE);
+	}
+}
+
+/*
+================
 Team_FragBonuses
 
 Calculate the bonuses for flag defense, flag carrier defense, etc.
@@ -392,6 +440,76 @@
 		return;
 	}
 
+//We palce the Double Domination bonus test here! This appears to be the best place to place them.
+	if ( g_gametype.integer == GT_DOUBLE_D ) {
+		if(attacker->client->sess.sessionTeam == level.pointStatusA ) { //Attack must defend point A
+			//See how close attacker and target was to Point A:
+			VectorSubtract(targ->r.currentOrigin, ddA->r.currentOrigin, v1);
+			VectorSubtract(attacker->r.currentOrigin, ddA->r.currentOrigin, v2);
+
+			if ( ( ( VectorLength(v1) < CTF_TARGET_PROTECT_RADIUS &&
+				trap_InPVS(ddA->r.currentOrigin, targ->r.currentOrigin ) ) ||
+				( VectorLength(v2) < CTF_TARGET_PROTECT_RADIUS &&
+				trap_InPVS(ddA->r.currentOrigin, attacker->r.currentOrigin ) ) ) &&
+				attacker->client->sess.sessionTeam != targ->client->sess.sessionTeam) {
+				
+				//We defended point A
+				//Was we dominating and maybe close to score?
+				if(attacker->client->sess.sessionTeam == level.pointStatusB && level.time - level.timeTaken > (10-DD_CLOSE)*1000)
+					AddScore(attacker, targ->r.currentOrigin, DD_POINT_DEFENCE_CLOSE_BONUS);
+				else
+					AddScore(attacker, targ->r.currentOrigin, DD_POINT_DEFENCE_BONUS);
+				attacker->client->pers.teamState.basedefense++;
+
+				attacker->client->ps.persistant[PERS_DEFEND_COUNT]++;
+				// add the sprite over the player's head
+				attacker->client->ps.eFlags &= ~(EF_AWARD_IMPRESSIVE | EF_AWARD_EXCELLENT | EF_AWARD_GAUNTLET | EF_AWARD_ASSIST | EF_AWARD_DEFEND | EF_AWARD_CAP );
+				attacker->client->ps.eFlags |= EF_AWARD_DEFEND;
+				attacker->client->rewardTime = level.time + REWARD_SPRITE_TIME;
+
+				return; //Return so we don't recieve credits for point B also
+
+			} //We denfended point A
+
+
+
+		} //Defend point A
+
+		if(attacker->client->sess.sessionTeam == level.pointStatusB ) { //Attack must defend point B
+			//See how close attacker and target was to Point B:
+			VectorSubtract(targ->r.currentOrigin, ddB->r.currentOrigin, v1);
+			VectorSubtract(attacker->r.currentOrigin, ddB->r.currentOrigin, v2);
+
+			if ( ( ( VectorLength(v1) < CTF_TARGET_PROTECT_RADIUS &&
+				trap_InPVS(ddB->r.currentOrigin, targ->r.currentOrigin ) ) ||
+				( VectorLength(v2) < CTF_TARGET_PROTECT_RADIUS &&
+				trap_InPVS(ddB->r.currentOrigin, attacker->r.currentOrigin ) ) ) &&
+				attacker->client->sess.sessionTeam != targ->client->sess.sessionTeam) {
+				
+				//We defended point B
+				//Was we dominating and maybe close to score?
+				if(attacker->client->sess.sessionTeam == level.pointStatusA && level.time - level.timeTaken > (10-DD_CLOSE)*1000)
+					AddScore(attacker, targ->r.currentOrigin, DD_POINT_DEFENCE_CLOSE_BONUS);
+				else
+					AddScore(attacker, targ->r.currentOrigin, DD_POINT_DEFENCE_BONUS);
+				attacker->client->pers.teamState.basedefense++;
+
+				attacker->client->ps.persistant[PERS_DEFEND_COUNT]++;
+				// add the sprite over the player's head
+				attacker->client->ps.eFlags &= ~(EF_AWARD_IMPRESSIVE | EF_AWARD_EXCELLENT | EF_AWARD_GAUNTLET | EF_AWARD_ASSIST | EF_AWARD_DEFEND | EF_AWARD_CAP );
+				attacker->client->ps.eFlags |= EF_AWARD_DEFEND;
+				attacker->client->rewardTime = level.time + REWARD_SPRITE_TIME;
+
+				return;
+
+			} //We denfended point B
+
+
+
+		} //Defend point B
+	return; //In double Domination we shall not go on, or we would test for team bases that we don't use
+	}
+
 	// flag and flag carrier area defense bonuses
 
 	// we have to find the flag and carrier entities
@@ -455,7 +573,10 @@
 		trap_InPVS(flag->r.currentOrigin, targ->r.currentOrigin ) ) ||
 		( VectorLength(v2) < CTF_TARGET_PROTECT_RADIUS &&
 		trap_InPVS(flag->r.currentOrigin, attacker->r.currentOrigin ) ) ) &&
-		attacker->client->sess.sessionTeam != targ->client->sess.sessionTeam) {
+		attacker->client->sess.sessionTeam != targ->client->sess.sessionTeam && g_gametype.integer != GT_ELIMINATION &&
+		(g_gametype.integer != GT_CTF_ELIMINATION || g_elimination_ctf_oneway.integer==0 || 
+		((level.eliminationSides+level.roundNumber)%2 == 0 && attacker->client->sess.sessionTeam == TEAM_BLUE ) ||
+		((level.eliminationSides+level.roundNumber)%2 == 1 && attacker->client->sess.sessionTeam == TEAM_RED ) ) ) {
 
 		// we defended the base flag
 		AddScore(attacker, targ->r.currentOrigin, CTF_FLAG_DEFENSE_BONUS);
@@ -558,8 +679,88 @@
 	return rent;
 }
 
+//Functions for Double Domination
+
+void Team_DD_RemovePointAgfx( void ) {
+	/*gentity_t *ent;
+	while ((ent = G_Find (ent, FOFS(classname), "team_DD_pointAblue")) != NULL)
+		G_FreeEntity(ent);
+	while ((ent = G_Find (ent, FOFS(classname), "team_DD_pointAred")) != NULL)
+		G_FreeEntity(ent);
+	while ((ent = G_Find (ent, FOFS(classname), "team_DD_pointAwhite")) != NULL)
+		G_FreeEntity(ent);*/
+	if(ddA!=NULL) {
+		G_FreeEntity(ddA);
+		ddA = NULL;
+	}
+}
+
+void Team_DD_RemovePointBgfx( void ) {
+	/*gentity_t *ent;
+	while ((ent = G_Find (ent, FOFS(classname), "team_DD_pointBblue")) != NULL)
+		G_FreeEntity(ent);
+	while ((ent = G_Find (ent, FOFS(classname), "team_DD_pointBred")) != NULL)
+		G_FreeEntity(ent);
+	while ((ent = G_Find (ent, FOFS(classname), "team_DD_pointBwhite")) != NULL) {
+		G_FreeEntity(ent);*/
+	if(ddB!=NULL) {
+		G_FreeEntity(ddB);
+		ddB = NULL;
+	}
+}
+
+void Team_DD_makeA2team( gentity_t *target, int team ) {
+	gitem_t			*it;
+	//gentity_t		*it_ent;
+	Team_DD_RemovePointAgfx();
+	it = NULL;
+	if(team == TEAM_NONE)
+		return;
+	if(team == TEAM_RED)
+		it = BG_FindItem ("Point A (Red)");
+	if(team == TEAM_BLUE)
+		it = BG_FindItem ("Point A (Blue)");
+	if(team == TEAM_FREE)
+		it = BG_FindItem ("Point A (White)");
+	if (!it || it == NULL) {
+		PrintMsg( NULL, "No item\n");
+		return;
+	}
+	ddA = G_Spawn();
+	
+	VectorCopy( target->r.currentOrigin, ddA->s.origin );
+	ddA->classname = it->classname;
+	G_SpawnItem(ddA, it);
+	FinishSpawningItem(ddA );
+}
+
+void Team_DD_makeB2team( gentity_t *target, int team ) {
+	gitem_t			*it;
+	//gentity_t		*it_ent;
+	it = NULL;
+	Team_DD_RemovePointBgfx();
+	if(team == TEAM_NONE)
+		return;
+	if(team == TEAM_RED)
+		it = BG_FindItem ("Point B (Red)");
+	if(team == TEAM_BLUE)
+		it = BG_FindItem ("Point B (Blue)");
+	if(team == TEAM_FREE)
+		it = BG_FindItem ("Point B (White)");
+	if (!it) {
+		PrintMsg( NULL, "No item\n");
+		return;
+	}
+	ddB = G_Spawn();
+	
+	VectorCopy( target->r.currentOrigin, ddB->s.origin );
+	ddB->classname = it->classname;
+	G_SpawnItem(ddB, it);
+	FinishSpawningItem(ddB );
+}
+
 void Team_ResetFlags( void ) {
-	if( g_gametype.integer == GT_CTF ) {
+	if( g_gametype.integer == GT_CTF || g_gametype.integer == GT_CTF_ELIMINATION) {
 		Team_ResetFlag( TEAM_RED );
 		Team_ResetFlag( TEAM_BLUE );
 	}
@@ -578,6 +779,10 @@
 		return;
 	}
 
+	//See if we are during CTF_ELIMINATION warmup
+	if((level.time<=level.roundStartTime && level.time>level.roundStartTime-1000*g_elimination_activewarmup.integer)&&g_gametype.integer == GT_CTF_ELIMINATION)
+		return;
+
 	te = G_TempEntity( ent->s.pos.trBase, EV_GLOBAL_TEAM_SOUND );
 	if( team == TEAM_BLUE ) {
 		te->s.eventParm = GTS_RED_RETURN;
@@ -601,7 +806,7 @@
 	switch(team) {
 		case TEAM_RED:
 			if( teamgame.blueStatus != FLAG_ATBASE ) {
-				if (teamgame.blueTakenTime > level.time - 10000)
+				if (teamgame.blueTakenTime > level.time - 10000 && g_gametype.integer != GT_CTF_ELIMINATION)
 					return;
 			}
 			teamgame.blueTakenTime = level.time;
@@ -609,7 +814,7 @@
 
 		case TEAM_BLUE:	// CTF
 			if( teamgame.redStatus != FLAG_ATBASE ) {
-				if (teamgame.redTakenTime > level.time - 10000)
+				if (teamgame.redTakenTime > level.time - 10000 && g_gametype.integer != GT_CTF_ELIMINATION)
 					return;
 			}
 			teamgame.redTakenTime = level.time;
@@ -692,12 +897,148 @@
 	// Reset Flag will delete this entity
 }
 
+/*
+Update DD points
+*/
 
+void updateDDpoints(void) {
+	//teamgame.redStatus = -1; // Invalid to force update
+	Team_SetFlagStatus( TEAM_RED, level.pointStatusA );
+	//teamgame.blueStatus = -1; // Invalid to force update
+	Team_SetFlagStatus( TEAM_BLUE, level.pointStatusB );
+}
+
 /*
 ==============
-Team_DroppedFlagThink
+Team_SpawnDoubleDominationPoints
 ==============
 */
+
+int Team_SpawnDoubleDominationPoints ( void ) {
+	gentity_t	*ent;
+	level.pointStatusA = TEAM_FREE;
+	level.pointStatusB = TEAM_FREE;
+	updateDDpoints();
+	ent = NULL;
+	if ((ent = G_Find (ent, FOFS(classname), "team_CTF_redflag")) != NULL) {
+		Team_DD_makeA2team( ent, TEAM_FREE );
+	}
+	if ((ent = G_Find (ent, FOFS(classname), "team_CTF_blueflag")) != NULL) {
+		Team_DD_makeB2team( ent, TEAM_FREE );
+	}
+	return 1;
+}
+
+/*
+==============
+Team_RemoveDoubleDominationPoints
+==============
+*/
+
+int Team_RemoveDoubleDominationPoints ( void ) {
+	level.pointStatusA = TEAM_NONE;
+	level.pointStatusB = TEAM_NONE;
+	updateDDpoints();
+	Team_DD_makeA2team( NULL, TEAM_NONE );
+	Team_DD_makeB2team( NULL, TEAM_NONE );
+	return 1;
+}
+
+/*
+==============
+Team_TouchDoubleDominationPoint
+==============
+*/
+
+//team is the either TEAM_RED(A) or TEAM_BLUE(B)
+int Team_TouchDoubleDominationPoint( gentity_t *ent, gentity_t *other, int team ) {
+	gclient_t	*cl = other->client;
+	qboolean	otherDominating, isClose;
+	int 		clientTeam = cl->sess.sessionTeam;
+	int		otherTeam;
+	int		score; //Used to add the scores together 
+
+	if(clientTeam == TEAM_RED)
+		otherTeam = TEAM_BLUE;
+	else
+		otherTeam = TEAM_RED;
+
+	otherDominating = qfalse;
+	isClose = qfalse;
+
+	if(level.pointStatusA == otherTeam && level.pointStatusB == otherTeam) {
+		otherDominating = qtrue;
+		if(level.time - level.timeTaken > (10-DD_CLOSE)*1000)
+			isClose = qtrue;
+	}	
+	
+
+	if(team == TEAM_RED) //We have touched point A
+	{
+		if(TEAM_NONE == level.pointStatusA)
+			return 0; //Haven't spawned yet
+		if(clientTeam == level.pointStatusA)
+			return 0; //If we already have the flag
+		//if we didn't have the point, then we have now!
+		level.pointStatusA = clientTeam;
+		PrintMsg( NULL, "%s" S_COLOR_WHITE " (%s) took control of A!\n", cl->pers.netname, TeamName(clientTeam) );
+		Team_DD_makeA2team( ent, clientTeam );
+		//Give personal score
+		score = DD_POINT_CAPTURE; //Base score for capture
+		if(otherDominating){
+			score += DD_POINT_CAPTURE_BREAK;
+			if(isClose)
+				score += DD_POINT_CAPTURE_CLOSE;
+		}
+		AddScore(other, ent->r.currentOrigin, score);
+		//Do we also have point B?
+		if(clientTeam == level.pointStatusB)
+		{
+			//We are dominating!
+			level.timeTaken = level.time; //At this time
+			PrintMsg( NULL, "%s" S_COLOR_WHITE " is dominating!\n", TeamName(clientTeam) );
+			SendDDtimetakenMessageToAllClients();
+		}
+	}
+
+	if(team == TEAM_BLUE) //We have touched point B
+	{
+		if(TEAM_NONE == level.pointStatusB)
+			return 0; //Haven't spawned yet
+		if(clientTeam == level.pointStatusB)
+			return 0; //If we already have the flag
+		//if we didn't have the point, then we have now!
+		level.pointStatusB = clientTeam;
+		PrintMsg( NULL, "%s" S_COLOR_WHITE " (%s) took control of B!\n", cl->pers.netname, TeamName(clientTeam) );
+		Team_DD_makeB2team( ent, clientTeam );
+		//Give personal score
+		score = DD_POINT_CAPTURE; //Base score for capture
+		if(otherDominating){
+			score += DD_POINT_CAPTURE_BREAK;
+			if(isClose)
+				score += DD_POINT_CAPTURE_CLOSE;
+		}
+		AddScore(other, ent->r.currentOrigin, score);
+		//Do we also have point A?
+		if(clientTeam == level.pointStatusA)
+		{
+			//We are dominating!
+			level.timeTaken = level.time; //At this time
+			PrintMsg( NULL, "%s" S_COLOR_WHITE " is dominating!\n", TeamName(clientTeam) );
+			SendDDtimetakenMessageToAllClients();
+		}
+	}
+
+	updateDDpoints();
+
+	return 0;
+}
+
+/*
+==============
+Team_TouchOurFlag
+==============
+*/
 int Team_TouchOurFlag( gentity_t *ent, gentity_t *other, int team ) {
 	int			i;
 	gentity_t	*player;
@@ -754,6 +1095,10 @@
 	// Increase the team's score
 	AddTeamScore(ent->s.pos.trBase, other->client->sess.sessionTeam, 1);
 	Team_ForceGesture(other->client->sess.sessionTeam);
+	//If CTF Elimination, stop the round:
+	if(g_gametype.integer==GT_CTF_ELIMINATION) {
+		EndEliminationRound();
+	}
 
 	other->client->pers.teamState.captures++;
 	// add the sprite over the player's head
@@ -852,7 +1197,7 @@
 int Pickup_Team( gentity_t *ent, gentity_t *other ) {
 	int team;
 	gclient_t *cl = other->client;
-
+	
 #ifdef MISSIONPACK
 	if( g_gametype.integer == GT_OBELISK ) {
 		// there are no team items that can be picked up in obelisk
@@ -896,6 +1241,9 @@
 		return 0;
 	}
 #endif
+	if( g_gametype.integer == GT_DOUBLE_D) {
+		return Team_TouchDoubleDominationPoint( ent, other, team );
+	}
 	// GT_CTF
 	if( team == cl->sess.sessionTeam) {
 		return Team_TouchOurFlag( ent, other, team );
@@ -988,6 +1336,15 @@
 	gentity_t	*spots[MAX_TEAM_SPAWN_POINTS];
 	char		*classname;
 
+	if(g_gametype.integer == GT_ELIMINATION) { //change sides every round
+		if((level.roundNumber+level.eliminationSides)%2==1){
+			if(team == TEAM_RED)
+				team = TEAM_BLUE;
+			else if(team == TEAM_BLUE)
+				team = TEAM_RED;
+		}
+	}
+
 	if (teamstate == TEAM_BEGIN) {
 		if (team == TEAM_RED)
 			classname = "team_CTF_redplayer";
@@ -1024,7 +1381,46 @@
 	return spots[ selection ];
 }
 
+/*
+================
+SelectRandomDDSpawnPoint
 
+go to a random Double Domination Spawn Point
+================
+*/
+#define	MAX_TEAM_SPAWN_POINTS	32
+gentity_t *SelectRandomDDSpawnPoint( void ) {
+	gentity_t	*spot;
+	int			count;
+	int			selection;
+	gentity_t	*spots[MAX_TEAM_SPAWN_POINTS];
+	char		*classname;
+
+	
+	classname = "info_player_dd";
+		
+	count = 0;
+
+	spot = NULL;
+
+	while ((spot = G_Find (spot, FOFS(classname), classname)) != NULL) {
+		if ( SpotWouldTelefrag( spot ) ) {
+			continue;
+		}
+		spots[ count ] = spot;
+		if (++count == MAX_TEAM_SPAWN_POINTS)
+			break;
+	}
+
+	if ( !count ) {	// no spots that won't telefrag
+		return G_Find( NULL, FOFS(classname), classname);
+	}
+
+	selection = rand() % count;
+	return spots[ selection ];
+}
+
+
 /*
 ===========
 SelectCTFSpawnPoint
@@ -1047,6 +1443,28 @@
 	return spot;
 }
 
+/*
+===========
+SelectDoubleDominationSpawnPoint
+
+============
+*/
+gentity_t *SelectDoubleDominationSpawnPoint ( vec3_t origin, vec3_t angles ) {
+	gentity_t	*spot;
+
+	spot = SelectRandomDDSpawnPoint (  );
+
+	if (!spot) {
+		return SelectSpawnPoint( vec3_origin, origin, angles );
+	}
+
+	VectorCopy (spot->s.origin, origin);
+	origin[2] += 9;
+	VectorCopy (spot->s.angles, angles);
+
+	return spot;
+}
+
 /*---------------------------------------------------------------------------*/
 
 static int QDECL SortClients( const void *a, const void *b ) {
@@ -1070,7 +1488,7 @@
 	int			i, j;
 	gentity_t	*player;
 	int			cnt;
-	int			h, a;
+	int			h, a, w;
 	int			clients[TEAM_MAXOVERLAY];
 
 	if ( ! ent->client->pers.teamInfo )
@@ -1101,6 +1519,13 @@
 
 			h = player->client->ps.stats[STAT_HEALTH];
 			a = player->client->ps.stats[STAT_ARMOR];
+			w = player->client->ps.weapon;
+			if(player->client->isEliminated)
+			{
+				h = 0;
+				a = 0;
+				w = 0;
+			}			
 			if (h < 0) h = 0;
 			if (a < 0) a = 0;
 
@@ -1108,7 +1533,7 @@
 				" %i %i %i %i %i %i", 
 //				level.sortedClients[i], player->client->pers.teamState.location, h, a, 
 				i, player->client->pers.teamState.location, h, a, 
-				player->client->ps.weapon, player->s.powerups);
+				w, player->s.powerups);
 			j = strlen(entry);
 			if (stringlength + j > sizeof(string))
 				break;
@@ -1373,7 +1798,7 @@
 void SP_team_redobelisk( gentity_t *ent ) {
 	gentity_t *obelisk;
 
-	if ( g_gametype.integer <= GT_TEAM ) {
+	if ( g_gametype.integer <= GT_TEAM || g_ffa_gt>0) {
 		G_FreeEntity(ent);
 		return;
 	}
@@ -1398,7 +1823,7 @@
 void SP_team_blueobelisk( gentity_t *ent ) {
 	gentity_t *obelisk;
 
-	if ( g_gametype.integer <= GT_TEAM ) {
+	if ( g_gametype.integer <= GT_TEAM || g_ffa_gt>0) {
 		G_FreeEntity(ent);
 		return;
 	}
Index: code/game/ai_main.c
===================================================================
--- code/game/ai_main.c	(revision 1145)
+++ code/game/ai_main.c	(working copy)
@@ -285,7 +285,7 @@
 	else leader = " ";
 
 	strcpy(flagstatus, "  ");
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		if (BotCTFCarryingFlag(bs)) {
 			if (BotTeam(bs) == TEAM_RED) strcpy(flagstatus, S_COLOR_RED"F ");
 			else strcpy(flagstatus, S_COLOR_BLUE"F ");
@@ -373,6 +373,16 @@
 			BotAI_Print(PRT_MESSAGE, "%-20s%s%s: harvesting\n", netname, leader, flagstatus);
 			break;
 		}
+		case LTG_POINTA:
+		{
+			BotAI_Print(PRT_MESSAGE, "%-20s%s%s: going for point A\n", netname, leader, flagstatus);
+			break;
+		}
+		case LTG_POINTB:
+		{
+			BotAI_Print(PRT_MESSAGE, "%-20s%s%s: going for point B\n", netname, leader, flagstatus);
+			break;
+		}
 		default:
 		{
 			BotAI_Print(PRT_MESSAGE, "%-20s%s%s: roaming\n", netname, leader, flagstatus);
@@ -435,7 +445,7 @@
 	else leader = " ";
 
 	strcpy(carrying, "  ");
-	if (gametype == GT_CTF) {
+	if (gametype == GT_CTF || gametype == GT_CTF_ELIMINATION) {
 		if (BotCTFCarryingFlag(bs)) {
 			strcpy(carrying, "F ");
 		}
@@ -521,6 +531,16 @@
 			Com_sprintf(action, sizeof(action), "harvesting");
 			break;
 		}
+		case LTG_POINTA:
+		{
+			Com_sprintf(action, sizeof(action), "going for point A");
+			break;
+		}
+		case LTG_POINTB:
+		{
+			Com_sprintf(action, sizeof(action), "going for point B");
+			break;
+		}
 		default:
 		{
 			trap_BotGetTopGoal(bs->gs, &goal);
Index: code/qcommon/q_shared.h
===================================================================
--- code/qcommon/q_shared.h	(revision 1145)
+++ code/qcommon/q_shared.h	(working copy)
@@ -26,17 +26,17 @@
 // q_shared.h -- included first by ALL program modules.
 // A user mod should never modify this file
 
-#define Q3_VERSION            "ioQ3 1.33"
+#define Q3_VERSION            "ioQ3 1.33+oa"
 #ifndef SVN_VERSION
   #define SVN_VERSION Q3_VERSION
 #endif
-#define CLIENT_WINDOW_TITLE   "ioquake3"
-#define CLIENT_WINDOW_ICON    "ioq3"
-#define CONSOLE_WINDOW_TITLE  "ioquake3 console"
-#define CONSOLE_WINDOW_ICON   "ioq3 console"
+#define CLIENT_WINDOW_TITLE   "OpenArena"
+#define CLIENT_WINDOW_ICON    "OpenArena"
+#define CONSOLE_WINDOW_TITLE  "OpenArena console"
+#define CONSOLE_WINDOW_ICON   "OpenArena console"
 // 1.32 released 7-10-2002
 
-#define BASEGAME              "baseq3"
+#define BASEGAME              "baseoa"
 
 #define MAX_TEAMNAME 32
 
Index: code/qcommon/files.c
===================================================================
--- code/qcommon/files.c	(revision 1145)
+++ code/qcommon/files.c	(working copy)
@@ -2877,7 +2877,7 @@
 */
 static void FS_CheckPak0( void )
 {
-	searchpath_t	*path;
+/*	searchpath_t	*path;
 	qboolean founddemo = qfalse;
 	unsigned foundPak = 0;
 
@@ -2961,6 +2961,7 @@
 		|| !Q_stricmp( fs_gamedirvar->string, "missionpack" ))
 			Com_Error(ERR_FATAL, "\n*** you need to install Quake III Arena in order to play ***");
 	}
+*/
 }
 
 /*
@@ -3372,7 +3373,7 @@
 	// try to start up normally
 	FS_Startup( BASEGAME );
 
-	FS_CheckPak0( );
+//	FS_CheckPak0( );
 
 	// if we can't find default.cfg, assume that the paths are
 	// busted and error out now, rather than getting an unreadable
Index: code/qcommon/qcommon.h
===================================================================
--- code/qcommon/qcommon.h	(revision 1145)
+++ code/qcommon/qcommon.h	(working copy)
@@ -222,7 +222,7 @@
 
 ==============================================================
 */
-
+//up this to 69 for 0.8 release!!
 #define	PROTOCOL_VERSION	68
 // 1.31 - 67
 
@@ -230,13 +230,13 @@
 // NOTE: that stuff only works with two digits protocols
 extern int demo_protocols[];
 
-#define	UPDATE_SERVER_NAME	"update.quake3arena.com"
+#define	UPDATE_SERVER_NAME	""
 // override on command line, config files etc.
 #ifndef MASTER_SERVER_NAME
-#define MASTER_SERVER_NAME	"master.quake3arena.com"
+#define MASTER_SERVER_NAME	"dpmaster.deathmask.net"
 #endif
 #ifndef AUTHORIZE_SERVER_NAME
-#define	AUTHORIZE_SERVER_NAME	"authorize.quake3arena.com"
+#define	AUTHORIZE_SERVER_NAME	""
 #endif
 
 #define	PORT_MASTER			27950
Index: code/qcommon/qfiles.h
===================================================================
--- code/qcommon/qfiles.h	(revision 1145)
+++ code/qcommon/qfiles.h	(working copy)
@@ -35,7 +35,7 @@
 #endif
 
 // surface geometry should not exceed these limits
-#define	SHADER_MAX_VERTEXES	1000
+#define	SHADER_MAX_VERTEXES	16384
 #define	SHADER_MAX_INDEXES	(6*SHADER_MAX_VERTEXES)
 
 
Index: code/qcommon/common.c
===================================================================
--- code/qcommon/common.c	(revision 1145)
+++ code/qcommon/common.c	(working copy)
@@ -37,9 +37,9 @@
 #define MAX_NUM_ARGVS	50
 
 #define MIN_DEDICATED_COMHUNKMEGS 1
-#define MIN_COMHUNKMEGS		56
-#define DEF_COMHUNKMEGS		64
-#define DEF_COMZONEMEGS		24
+#define MIN_COMHUNKMEGS		112
+#define DEF_COMHUNKMEGS		128
+#define DEF_COMZONEMEGS		48
 #define XSTRING(x)				STRING(x)
 #define STRING(x)					#x
 #define DEF_COMHUNKMEGS_S	XSTRING(DEF_COMHUNKMEGS)
Index: code/botlib/be_ai_chat.c
===================================================================
--- code/botlib/be_ai_chat.c	(revision 1145)
+++ code/botlib/be_ai_chat.c	(working copy)
@@ -367,26 +367,13 @@
 int BotNextConsoleMessage(int chatstate, bot_consolemessage_t *cm)
 {
 	bot_chatstate_t *cs;
-	bot_consolemessage_t *firstmsg;
 
 	cs = BotChatStateFromHandle(chatstate);
 	if (!cs) return 0;
-	if ((firstmsg = cs->firstmessage))
+	if (cs->firstmessage)
 	{
-		cm->handle = firstmsg->handle;
-		cm->time = firstmsg->time;
-		cm->type = firstmsg->type;
-		Q_strncpyz(cm->message, firstmsg->message,
-			   sizeof(cm->message));
-		
-		/* We omit setting the two pointers in cm because pointer
-		 * size in the VM differs between the size in the engine on
-		 * 64 bit machines, which would lead to a buffer overflow if
-		 * this functions is called from the VM. The pointers are
-		 * of no interest to functions calling
-		 * BotNextConsoleMessage anyways.
-		 */
-		
+		Com_Memcpy(cm, cs->firstmessage, sizeof(bot_consolemessage_t));
+		cm->next = cm->prev = NULL;
 		return cm->handle;
 	} //end if
 	return 0;
Index: code/botlib/be_ai_goal.c
===================================================================
--- code/botlib/be_ai_goal.c	(revision 1145)
+++ code/botlib/be_ai_goal.c	(working copy)
@@ -103,6 +103,10 @@
 	GT_OBELISK,
 	GT_HARVESTER,
 #endif
+	GT_ELIMINATION,
+	GT_CTF_ELIMINATION,
+	GT_LMS,
+	GT_DOUBLE_D,
 	GT_MAX_GAME_TYPE
 } gametype_t;
 
@@ -134,7 +138,7 @@
 	int number;							//number of the item info
 } iteminfo_t;
 
-#define ITEMINFO_OFS(x)	(size_t)&(((iteminfo_t *)0)->x)
+#define ITEMINFO_OFS(x)	(int)&(((iteminfo_t *)0)->x)
 
 fielddef_t iteminfo_fields[] =
 {
Index: code/botlib/be_ai_weap.c
===================================================================
--- code/botlib/be_ai_weap.c	(revision 1145)
+++ code/botlib/be_ai_weap.c	(working copy)
@@ -48,8 +48,8 @@
 //#define DEBUG_AI_WEAP
 
 //structure field offsets
-#define WEAPON_OFS(x) (size_t)&(((weaponinfo_t *)0)->x)
-#define PROJECTILE_OFS(x) (size_t)&(((projectileinfo_t *)0)->x)
+#define WEAPON_OFS(x) (int)&(((weaponinfo_t *)0)->x)
+#define PROJECTILE_OFS(x) (int)&(((projectileinfo_t *)0)->x)
 
 //weapon definition // bk001212 - static
 static fielddef_t weaponinfo_fields[] =
Index: code/cgame/cg_predict.c
===================================================================
--- code/cgame/cg_predict.c	(revision 1145)
+++ code/cgame/cg_predict.c	(working copy)
@@ -260,7 +260,19 @@
 */
 static void CG_TouchItem( centity_t *cent ) {
 	gitem_t		*item;
+	//For instantgib
+	qboolean	canBePicked;
 
+	if(cgs.gametype == GT_ELIMINATION || cgs.gametype == GT_LMS)
+		return; //No weapon pickup in elimination
+
+	//normally we can
+	canBePicked = qtrue;
+
+	//But in instantgib and CTF_ELIMINATION we normally can't:
+	if(cgs.instantgib || cgs.gametype == GT_CTF_ELIMINATION)
+		canBePicked = qfalse;
+
 	if ( !cg_predictItems.integer ) {
 		return;
 	}
@@ -287,9 +299,9 @@
 			return;
 		}
 	}
-	if( cgs.gametype == GT_CTF || cgs.gametype == GT_HARVESTER ) {
+	if( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION || cgs.gametype == GT_HARVESTER ) {
 #else
-	if( cgs.gametype == GT_CTF ) {
+	if( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION ) {
 #endif
 		if (cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_RED &&
 			item->giTag == PW_REDFLAG)
@@ -297,22 +309,50 @@
 		if (cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_BLUE &&
 			item->giTag == PW_BLUEFLAG)
 			return;
+		//Even in instantgib, we can predict our enemy flag
+		if (cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_RED &&
+			item->giTag == PW_BLUEFLAG && (!cgs.oneway || cgs.attackingTeam == TEAM_RED))
+			canBePicked = qtrue;
+		if (cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_BLUE &&
+			item->giTag == PW_REDFLAG && (!cgs.oneway || cgs.attackingTeam == TEAM_BLUE))
+			canBePicked = qtrue;
+		if (item->giTag == WP_RAILGUN)
+			canBePicked = qfalse;
+		if (item->giTag == WP_PLASMAGUN)
+			canBePicked = qfalse;
 	}
 
+	//Currently we don't predict anything in Double Domination because it looks like we take a flag
+	if( cgs.gametype == GT_DOUBLE_D ) {
+		if(cgs.redflag == TEAM_NONE)
+			return; //Can never pick if just one flag is NONE (because then the other is too)
+		if(item->giTag == PW_REDFLAG){ //at point A
+			//if(cgs.redflag == cg.predictedPlayerState.persistant[PERS_TEAM]) //already taken
+				return;
+		}	
+		if(item->giTag == PW_BLUEFLAG){ //at point B
+			//if(cgs.blueflag == cg.predictedPlayerState.persistant[PERS_TEAM]) //already taken
+				return;
+		}	
+	}
+
 	// grab it
-	BG_AddPredictableEventToPlayerstate( EV_ITEM_PICKUP, cent->currentState.modelindex , &cg.predictedPlayerState);
+	if(canBePicked)
+	{
+		BG_AddPredictableEventToPlayerstate( EV_ITEM_PICKUP, cent->currentState.modelindex , &cg.predictedPlayerState);
 
-	// remove it from the frame so it won't be drawn
-	cent->currentState.eFlags |= EF_NODRAW;
+		// remove it from the frame so it won't be drawn
+		cent->currentState.eFlags |= EF_NODRAW;
 
-	// don't touch it again this prediction
-	cent->miscTime = cg.time;
+		// don't touch it again this prediction
+		cent->miscTime = cg.time;
 
-	// if its a weapon, give them some predicted ammo so the autoswitch will work
-	if ( item->giType == IT_WEAPON ) {
-		cg.predictedPlayerState.stats[ STAT_WEAPONS ] |= 1 << item->giTag;
-		if ( !cg.predictedPlayerState.ammo[ item->giTag ] ) {
-			cg.predictedPlayerState.ammo[ item->giTag ] = 1;
+		// if its a weapon, give them some predicted ammo so the autoswitch will work
+		if ( item->giType == IT_WEAPON ) {
+			cg.predictedPlayerState.stats[ STAT_WEAPONS ] |= 1 << item->giTag;
+			if ( !cg.predictedPlayerState.ammo[ item->giTag ] ) {
+				cg.predictedPlayerState.ammo[ item->giTag ] = 1;
+			}
 		}
 	}
 }
Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 1145)
+++ code/cgame/cg_local.h	(working copy)
@@ -85,8 +85,8 @@
 
 #define	DEFAULT_MODEL			"sarge"
 #ifdef MISSIONPACK
-#define	DEFAULT_TEAM_MODEL		"james"
-#define	DEFAULT_TEAM_HEAD		"*james"
+#define	DEFAULT_TEAM_MODEL		"sergei"
+#define	DEFAULT_TEAM_HEAD		"*sergei"
 #else
 #define	DEFAULT_TEAM_MODEL		"sarge"
 #define	DEFAULT_TEAM_HEAD		"sarge"
@@ -301,6 +301,7 @@
 	int				captures;
 	qboolean	perfect;
 	int				team;
+	qboolean			isDead;
 } score_t;
 
 // each client has an associated clientInfo_t
@@ -374,6 +375,8 @@
 	animation_t		animations[MAX_TOTALANIMATIONS];
 
 	sfxHandle_t		sounds[MAX_CUSTOM_SOUNDS];
+
+	qboolean		isDead;
 } clientInfo_t;
 
 
@@ -670,6 +673,11 @@
 	qhandle_t	blueFlagShader[3];
 	qhandle_t	flagShader[4];
 
+//For Double Domination:
+	qhandle_t	ddPointA;
+	qhandle_t	ddPointB;
+	qhandle_t	ddPointSkin[3]; //0=white,1=red,2=blue
+
 	qhandle_t	flagPoleModel;
 	qhandle_t	flagFlapModel;
 
@@ -1023,6 +1031,26 @@
 
 	int				levelStartTime;
 
+//Forced FFA
+	int			ffa_gt;
+
+//Elimination
+	int				roundStartTime;	
+	int				roundtime;
+
+//CTF Elimination
+	qboolean			oneway;
+	int				attackingTeam;
+
+//Last Man Standing
+	int				lms_mode;
+
+//instantgib:
+	int				instantgib;
+
+//Double Domination DD
+	int 				timetaken;
+
 	int				scores1, scores2;		// from configstrings
 	int				redflag, blueflag;		// flag status from configstrings
 	int				flagStatus;
Index: code/cgame/cg_weapons.c
===================================================================
--- code/cgame/cg_weapons.c	(revision 1145)
+++ code/cgame/cg_weapons.c	(working copy)
@@ -1695,6 +1695,9 @@
 	int				c;
 	weaponInfo_t	*weap;
 
+	if((cgs.gametype == GT_ELIMINATION || cgs.gametype == GT_CTF_ELIMINATION) && cgs.roundStartTime>=cg.time)
+		return; //if we havn't started in ELIMINATION then do not fire
+
 	ent = &cent->currentState;
 	if ( ent->weapon == WP_NONE ) {
 		return;
Index: code/cgame/cg_players.c
===================================================================
--- code/cgame/cg_players.c	(revision 1145)
+++ code/cgame/cg_players.c	(working copy)
@@ -314,7 +314,7 @@
 	char *team, *charactersFolder;
 	int i;
 
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		switch ( ci->team ) {
 			case TEAM_BLUE: {
 				team = "blue";
@@ -333,33 +333,33 @@
 	while(1) {
 		for ( i = 0; i < 2; i++ ) {
 			if ( i == 0 && teamName && *teamName ) {
-				//								"models/players/characters/james/stroggs/lower_lily_red.skin"
+				//								"models/players/characters/sergei/stroggs/lower_lily_red.skin"
 				Com_sprintf( filename, length, "models/players/%s%s/%s%s_%s_%s.%s", charactersFolder, modelName, teamName, base, skinName, team, ext );
 			}
 			else {
-				//								"models/players/characters/james/lower_lily_red.skin"
+				//								"models/players/characters/sergei/lower_lily_red.skin"
 				Com_sprintf( filename, length, "models/players/%s%s/%s_%s_%s.%s", charactersFolder, modelName, base, skinName, team, ext );
 			}
 			if ( CG_FileExists( filename ) ) {
 				return qtrue;
 			}
-			if ( cgs.gametype >= GT_TEAM ) {
+			if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 				if ( i == 0 && teamName && *teamName ) {
-					//								"models/players/characters/james/stroggs/lower_red.skin"
+					//								"models/players/characters/sergei/stroggs/lower_red.skin"
 					Com_sprintf( filename, length, "models/players/%s%s/%s%s_%s.%s", charactersFolder, modelName, teamName, base, team, ext );
 				}
 				else {
-					//								"models/players/characters/james/lower_red.skin"
+					//								"models/players/characters/sergei/lower_red.skin"
 					Com_sprintf( filename, length, "models/players/%s%s/%s_%s.%s", charactersFolder, modelName, base, team, ext );
 				}
 			}
 			else {
 				if ( i == 0 && teamName && *teamName ) {
-					//								"models/players/characters/james/stroggs/lower_lily.skin"
+					//								"models/players/characters/sergei/stroggs/lower_lily.skin"
 					Com_sprintf( filename, length, "models/players/%s%s/%s%s_%s.%s", charactersFolder, modelName, teamName, base, skinName, ext );
 				}
 				else {
-					//								"models/players/characters/james/lower_lily.skin"
+					//								"models/players/characters/sergei/lower_lily.skin"
 					Com_sprintf( filename, length, "models/players/%s%s/%s_%s.%s", charactersFolder, modelName, base, skinName, ext );
 				}
 			}
@@ -389,7 +389,7 @@
 	char *team, *headsFolder;
 	int i;
 
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		switch ( ci->team ) {
 			case TEAM_BLUE: {
 				team = "blue";
@@ -423,7 +423,7 @@
 			if ( CG_FileExists( filename ) ) {
 				return qtrue;
 			}
-			if ( cgs.gametype >= GT_TEAM ) {
+			if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 				if ( i == 0 &&  teamName && *teamName ) {
 					Com_sprintf( filename, length, "models/players/%s%s/%s%s_%s.%s", headsFolder, headModelName, teamName, base, team, ext );
 				}
@@ -657,7 +657,7 @@
 
 	teamname[0] = 0;
 #ifdef MISSIONPACK
-	if( cgs.gametype >= GT_TEAM) {
+	if( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		if( ci->team == TEAM_BLUE ) {
 			Q_strncpyz(teamname, cg_blueTeamName.string, sizeof(teamname) );
 		} else {
@@ -675,7 +675,7 @@
 		}
 
 		// fall back to default team name
-		if( cgs.gametype >= GT_TEAM) {
+		if( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 			// keep skin name
 			if( ci->team == TEAM_BLUE ) {
 				Q_strncpyz(teamname, DEFAULT_BLUETEAM_NAME, sizeof(teamname) );
@@ -704,7 +704,7 @@
 
 	// sounds
 	dir = ci->modelName;
-	fallback = (cgs.gametype >= GT_TEAM) ? DEFAULT_TEAM_MODEL : DEFAULT_MODEL;
+	fallback = (cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) ? DEFAULT_TEAM_MODEL : DEFAULT_MODEL;
 
 	for ( i = 0 ; i < MAX_CUSTOM_SOUNDS ; i++ ) {
 		s = cg_customSoundNames[i];
@@ -780,7 +780,7 @@
 			&& !Q_stricmp( ci->headSkinName, match->headSkinName ) 
 			&& !Q_stricmp( ci->blueTeam, match->blueTeam ) 
 			&& !Q_stricmp( ci->redTeam, match->redTeam )
-			&& (cgs.gametype < GT_TEAM || ci->team == match->team) ) {
+			&& (cgs.gametype < GT_TEAM || cgs.ffa_gt==1 || ci->team == match->team) ) {
 			// this clientinfo is identical, so use it's handles
 
 			ci->deferred = qfalse;
@@ -818,7 +818,7 @@
 			 Q_stricmp( ci->modelName, match->modelName ) ||
 //			 Q_stricmp( ci->headModelName, match->headModelName ) ||
 //			 Q_stricmp( ci->headSkinName, match->headSkinName ) ||
-			 (cgs.gametype >= GT_TEAM && ci->team != match->team) ) {
+			 (cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1 && ci->team != match->team) ) {
 			continue;
 		}
 		// just load the real info cause it uses the same models and skins
@@ -827,14 +827,14 @@
 	}
 
 	// if we are in teamplay, only grab a model if the skin is correct
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		for ( i = 0 ; i < cgs.maxclients ; i++ ) {
 			match = &cgs.clientinfo[ i ];
 			if ( !match->infoValid || match->deferred ) {
 				continue;
 			}
 			if ( Q_stricmp( ci->skinName, match->skinName ) ||
-				(cgs.gametype >= GT_TEAM && ci->team != match->team) ) {
+				(cgs.gametype >= GT_TEAM && cgs.ffa_gt != 1 && ci->team != match->team) ) {
 				continue;
 			}
 			ci->deferred = qtrue;
@@ -945,7 +945,7 @@
 		char modelStr[MAX_QPATH];
 		char *skin;
 
-		if( cgs.gametype >= GT_TEAM ) {
+		if( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 			Q_strncpyz( newInfo.modelName, DEFAULT_TEAM_MODEL, sizeof( newInfo.modelName ) );
 			Q_strncpyz( newInfo.skinName, "default", sizeof( newInfo.skinName ) );
 		} else {
@@ -960,7 +960,7 @@
 			Q_strncpyz( newInfo.modelName, modelStr, sizeof( newInfo.modelName ) );
 		}
 
-		if ( cgs.gametype >= GT_TEAM ) {
+		if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1 ) {
 			// keep skin name
 			slash = strchr( v, '/' );
 			if ( slash ) {
@@ -989,7 +989,7 @@
 		char modelStr[MAX_QPATH];
 		char *skin;
 
-		if( cgs.gametype >= GT_TEAM ) {
+		if( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 			Q_strncpyz( newInfo.headModelName, DEFAULT_TEAM_MODEL, sizeof( newInfo.headModelName ) );
 			Q_strncpyz( newInfo.headSkinName, "default", sizeof( newInfo.headSkinName ) );
 		} else {
@@ -1004,7 +1004,7 @@
 			Q_strncpyz( newInfo.headModelName, modelStr, sizeof( newInfo.headModelName ) );
 		}
 
-		if ( cgs.gametype >= GT_TEAM ) {
+		if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 			// keep skin name
 			slash = strchr( v, '/' );
 			if ( slash ) {
@@ -1971,7 +1971,7 @@
 	team = cgs.clientinfo[ cent->currentState.clientNum ].team;
 	if ( !(cent->currentState.eFlags & EF_DEAD) && 
 		cg.snap->ps.persistant[PERS_TEAM] == team &&
-		cgs.gametype >= GT_TEAM) {
+		cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		if (cg_drawFriend.integer) {
 			CG_PlayerFloatSprite( cent, cgs.media.friendShader );
 		}
Index: code/cgame/cg_info.c
===================================================================
--- code/cgame/cg_info.c	(revision 1145)
+++ code/cgame/cg_info.c	(working copy)
@@ -261,6 +261,18 @@
 		s = "Harvester";
 		break;
 #endif
+	case GT_ELIMINATION:
+		s = "Elimination";
+		break;
+	case GT_CTF_ELIMINATION:
+		s = " CTF Elimination";
+		break;
+	case GT_LMS:
+		s = "Last Man Standing";
+		break;
+	case GT_DOUBLE_D:
+		s = "Double Domination";
+		break;
 	default:
 		s = "Unknown Gametype";
 		break;
@@ -276,7 +288,7 @@
 		y += PROP_HEIGHT;
 	}
 
-	if (cgs.gametype < GT_CTF ) {
+	if (cgs.gametype < GT_CTF || cgs.ffa_gt>0) {
 		value = atoi( Info_ValueForKey( info, "fraglimit" ) );
 		if ( value ) {
 			UI_DrawProportionalString( 320, y, va( "fraglimit %i", value ),
@@ -285,7 +297,7 @@
 		}
 	}
 
-	if (cgs.gametype >= GT_CTF) {
+	if (cgs.gametype >= GT_CTF && cgs.ffa_gt == 0) {
 		value = atoi( Info_ValueForKey( info, "capturelimit" ) );
 		if ( value ) {
 			UI_DrawProportionalString( 320, y, va( "capturelimit %i", value ),
Index: code/cgame/cg_draw.c
===================================================================
--- code/cgame/cg_draw.c	(revision 1145)
+++ code/cgame/cg_draw.c	(working copy)
@@ -390,8 +390,24 @@
 
 		if( team == TEAM_RED ) {
 			handle = cgs.media.redFlagModel;
+			if(cgs.gametype == GT_DOUBLE_D){
+				if(cgs.redflag == TEAM_BLUE)
+					handle = cgs.media.blueFlagModel;
+				if(cgs.redflag == TEAM_FREE)
+					handle = cgs.media.neutralFlagModel;
+				if(cgs.redflag == TEAM_NONE)
+					handle = cgs.media.neutralFlagModel;
+			}
 		} else if( team == TEAM_BLUE ) {
 			handle = cgs.media.blueFlagModel;
+			if(cgs.gametype == GT_DOUBLE_D){
+				if(cgs.redflag == TEAM_BLUE)
+					handle = cgs.media.blueFlagModel;
+				if(cgs.redflag == TEAM_FREE)
+					handle = cgs.media.neutralFlagModel;
+				if(cgs.redflag == TEAM_NONE)
+					handle = cgs.media.neutralFlagModel;
+			}
 		} else if( team == TEAM_FREE ) {
 			handle = cgs.media.neutralFlagModel;
 		} else {
@@ -530,7 +546,9 @@
 	vec4_t		hcolor;
 	vec3_t		angles;
 	vec3_t		origin;
-
+#ifdef MISSIONPACK
+	qhandle_t	handle;
+#endif
 	static float colors[4][4] = { 
 //		{ 0.2, 1.0, 0.2, 1.0 } , { 1.0, 0.2, 0.2, 1.0 }, {0.5, 0.5, 0.5, 1} };
 		{ 1.0f, 0.69f, 0.0f, 1.0f },    // normal
@@ -578,6 +596,20 @@
 		CG_Draw3DModel( 370 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE,
 					   cgs.media.armorModel, 0, origin, angles );
 	}
+#ifdef MISSIONPACK
+	if( cgs.gametype == GT_HARVESTER ) {
+		origin[0] = 90;
+		origin[1] = 0;
+		origin[2] = -10;
+		angles[YAW] = ( cg.time & 2047 ) * 360 / 2048.0;
+		if( cg.snap->ps.persistant[PERS_TEAM] == TEAM_BLUE ) {
+			handle = cgs.media.redCubeModel;
+		} else {
+			handle = cgs.media.blueCubeModel;
+		}
+		CG_Draw3DModel( 640 - (TEXT_ICON_SPACE + ICON_SIZE), 416, ICON_SIZE, ICON_SIZE, handle, 0, origin, angles );
+	}
+#endif
 	//
 	// ammo
 	//
@@ -647,6 +679,29 @@
 		}
 
 	}
+#ifdef MISSIONPACK
+	//
+	// cubes
+	//
+	if( cgs.gametype == GT_HARVESTER ) {
+		value = ps->generic1;
+		if( value > 99 ) {
+			value = 99;
+		}
+		trap_R_SetColor( colors[0] );
+		CG_DrawField (640 - (CHAR_WIDTH*2 + TEXT_ICON_SPACE + ICON_SIZE), 432, 2, value);
+		trap_R_SetColor( NULL );
+		// if we didn't draw a 3D icon, draw a 2D icon for armor
+		if ( !cg_draw3dIcons.integer && cg_drawIcons.integer ) {
+			if( cg.snap->ps.persistant[PERS_TEAM] == TEAM_BLUE ) {
+				handle = cgs.media.redCubeIcon;
+			} else {
+				handle = cgs.media.blueCubeIcon;
+			}
+			CG_DrawPic( 640 - (TEXT_ICON_SPACE + ICON_SIZE), 432, ICON_SIZE, ICON_SIZE, handle );
+		}
+	}
+#endif
 }
 #endif
 
@@ -795,9 +850,257 @@
 	return y + BIGCHAR_HEIGHT + 4;
 }
 
+/*
+CG_DrawDoubleDominationThings
+*/
 
+static float CG_DrawDoubleDominationThings( float y ) {
+	char		*s;
+	int			w;
+	int 		statusA, statusB;
+	statusA = cgs.redflag;
+	statusB = cgs.blueflag;
+
+	if(statusA == TEAM_NONE) {
+		s = va("Point A not spawned");
+	} else
+	if(statusA == TEAM_FREE) {
+		s = va("Point A is not controlled");
+	} else
+	if(statusA == TEAM_RED) {
+		s = va("Point A is controlled by RED");
+	} else
+	if(statusA == TEAM_BLUE) {
+		s = va("Point A is controlled by BLUE");
+	} else
+		s = va("Point A has an error");
+	w = CG_DrawStrlen( s ) * SMALLCHAR_WIDTH;
+	CG_DrawSmallString( 635 - w, y + 2, s, 1.0F);
+	y+=SMALLCHAR_HEIGHT+4;
+
+	if(statusB == TEAM_NONE) {
+		s = va("Point B not spawned");
+	} else
+	if(statusB == TEAM_FREE) {
+		s = va("Point B is not controlled");
+	} else
+	if(statusB == TEAM_RED) {
+		s = va("Point B is controlled by RED");
+	} else
+	if(statusB == TEAM_BLUE) {
+		s = va("Point B is controlled by BLUE");
+	} else
+		s = va("Point B has an error");
+	w = CG_DrawStrlen( s ) * SMALLCHAR_WIDTH;
+	CG_DrawSmallString( 635 - w, y + 2, s, 1.0F);
+
+	if( ( ( statusB == statusA ) && ( statusA == TEAM_RED ) ) ||
+		( ( statusB == statusA ) && ( statusA == TEAM_BLUE ) ) ) {
+		s = va("Capture in: %i",(cgs.timetaken+10*1000-cg.time)/1000+1);
+		w = CG_DrawStrlen( s ) * SMALLCHAR_WIDTH;
+		y+=SMALLCHAR_HEIGHT+4;
+		CG_DrawSmallString( 635 - w, y + 2, s, 1.0F);
+	}
+
+	return y + SMALLCHAR_HEIGHT+4;
+}
+
 /*
 =================
+CG_DrawLMSmode
+=================
+*/
+
+static float CG_DrawLMSmode( float y ) {
+	char		*s;
+	int		w;
+
+	if(cgs.lms_mode == 0) {
+		s = va("LMS: Point/round + OT");
+	} else
+	if(cgs.lms_mode == 1) {
+		s = va("LMS: Point/round - OT");
+	} else
+	if(cgs.lms_mode == 2) {
+		s = va("LMS: Point/kill + OT");
+	} else
+	if(cgs.lms_mode == 3) {
+		s = va("LMS: Point/kill - OT");
+	} else
+		s = va("LMS: Unknown mode");
+
+	w = CG_DrawStrlen( s ) * SMALLCHAR_WIDTH;
+	CG_DrawSmallString( 635 - w, y + 2, s, 1.0F);
+
+	return y + SMALLCHAR_HEIGHT+4;
+}
+
+/*
+=================
+CG_DrawCTFoneway
+=================
+*/
+
+static float CG_DrawCTFoneway( float y ) {
+	char		*s;
+	int		w;
+	vec4_t		color;
+
+	if(cgs.gametype != GT_CTF_ELIMINATION)
+		return y;
+
+	memcpy(color,g_color_table[ColorIndex(COLOR_WHITE)],sizeof(color));
+
+	if(cgs.oneway == 0) {
+		return y; //nothing to draw
+	} else
+	if(cgs.attackingTeam == TEAM_BLUE) {
+		memcpy(color,g_color_table[ColorIndex(COLOR_BLUE)],sizeof(color));
+		s = va("Blue team on offence");
+	} else
+	if(cgs.attackingTeam == TEAM_RED) {
+		memcpy(color,g_color_table[ColorIndex(COLOR_RED)],sizeof(color));
+		s = va("Red team on offence");
+	} else
+		s = va("Unknown team on offence");
+
+	w = CG_DrawStrlen( s ) * SMALLCHAR_WIDTH;
+	CG_DrawSmallStringColor( 635 - w, y + 2, s, color);
+
+	return y + SMALLCHAR_HEIGHT+4;
+}
+
+/*
+=================
+CG_DrawEliminationDeathMessage
+=================
+*/
+
+static float CG_DrawEliminationDeathMessage( float y ) {
+	char		*s;
+	int			w;
+
+	s = va("You are waiting for a new round");
+	w = CG_DrawStrlen( s ) * SMALLCHAR_WIDTH;
+	CG_DrawSmallString( 635 - w, y + 2, s, 1.0F);
+
+	return y + SMALLCHAR_HEIGHT+4;
+}
+
+/*
+=================
+CG_DrawEliminationTimer
+=================
+*/
+static float CG_DrawEliminationTimer( float y ) {
+	char		*s;
+	int			w;
+	int			mins, seconds, tens, sec;
+	int			msec;
+	vec4_t			color;
+	const char	*st;
+	float scale;
+	int cw;
+	int rst;
+	
+	rst = cgs.roundStartTime;
+
+	//default color is white
+	memcpy(color,g_color_table[ColorIndex(COLOR_WHITE)],sizeof(color));
+
+	//msec = cg.time - cgs.levelStartTime;
+	if(cg.time>rst) //We are started
+	{
+		msec = cgs.roundtime*1000 - (cg.time -rst);
+		if(msec<=30*1000-1) //<= 30 seconds
+			memcpy(color,g_color_table[ColorIndex(COLOR_YELLOW)],sizeof(color));
+		if(msec<=10*1000-1) //<= 10 seconds
+			memcpy(color,g_color_table[ColorIndex(COLOR_RED)],sizeof(color));
+		msec += 1000; //120-1 instead of 119-0
+	}
+	else
+	{
+		//Warmup
+		msec = -cg.time +rst;
+		memcpy(color,g_color_table[ColorIndex(COLOR_GREEN)],sizeof(color));
+		sec = msec/1000;
+		msec += 1000; //5-1 instead of 4-0
+/***
+Lots of stuff
+****/
+	if(cg.warmup == 0)
+	{
+		st = va( "Round in: %i", sec + 1 );
+		if ( sec != cg.warmupCount ) {
+			cg.warmupCount = sec;
+			switch ( sec ) {
+			case 0:
+				trap_S_StartLocalSound( cgs.media.count1Sound, CHAN_ANNOUNCER );
+				break;
+			case 1:
+				trap_S_StartLocalSound( cgs.media.count2Sound, CHAN_ANNOUNCER );
+				break;
+			case 2:
+				trap_S_StartLocalSound( cgs.media.count3Sound, CHAN_ANNOUNCER );
+				break;
+			default:
+				break;
+			}
+		} 
+		scale = 0.45f;
+		switch ( cg.warmupCount ) {
+		case 0:
+			cw = 28;
+			scale = 0.54f;
+			break;
+		case 1:
+			cw = 24;
+			scale = 0.51f;
+			break;
+		case 2:
+			cw = 20;
+			scale = 0.48f;
+			break;
+		default:
+			cw = 16;
+			scale = 0.45f;
+			break;
+		}
+
+	#ifdef MISSIONPACK
+			//w = CG_Text_Width(s, scale, 0);
+			//CG_Text_Paint(320 - w / 2, 125, scale, colorWhite, st, 0, 0, ITEM_TEXTSTYLE_SHADOWEDMORE);
+	#else
+		w = CG_DrawStrlen( st );
+		CG_DrawStringExt( 320 - w * cw/2, 70, st, colorWhite, 
+				qfalse, qtrue, cw, (int)(cw * 1.5), 0 );
+	#endif
+	}
+/*
+Lots of stuff
+*/
+	}
+
+	seconds = msec / 1000;
+	mins = seconds / 60;
+	seconds -= mins * 60;
+	tens = seconds / 10;
+	seconds -= tens * 10;
+
+	if(msec>=0)
+		s = va( " %i:%i%i", mins, tens, seconds );
+	else
+		s = va( " Overtime");
+	w = CG_DrawStrlen( s ) * BIGCHAR_WIDTH;
+	
+	CG_DrawBigStringColor( 635 - w, y + 2, s, color);
+
+	return y + BIGCHAR_HEIGHT + 4;
+}
+
+
+/*
+=================
 CG_DrawTeamOverlay
 =================
 */
@@ -969,7 +1272,22 @@
 //#endif
 }
 
+static float CG_DrawFollowMessage( float y ) {
+	char		*s;
+	int			w;	
 
+	if ( !(cg.snap->ps.pm_flags & PMF_FOLLOW) ) {
+		return y;
+	}
+
+	s = va("USE_ITEM to stop following");
+	w = CG_DrawStrlen( s ) * SMALLCHAR_WIDTH;
+	CG_DrawSmallString( 635 - w, y + 2, s, 1.0F);
+
+	return y + SMALLCHAR_HEIGHT+4;
+}
+
+
 /*
 =====================
 CG_DrawUpperRight
@@ -981,16 +1299,36 @@
 
 	y = 0;
 
-	if ( cgs.gametype >= GT_TEAM && cg_drawTeamOverlay.integer == 1 ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1 && cg_drawTeamOverlay.integer == 1 ) {
 		y = CG_DrawTeamOverlay( y, qtrue, qtrue );
+	}
+	if ( cgs.gametype == GT_DOUBLE_D ) {
+		y = CG_DrawDoubleDominationThings(y);
 	} 
+	else
+	if ( cgs.gametype == GT_LMS && cg.showScores ) {
+		y = CG_DrawLMSmode(y);
+	}
+	else
+	if ( cgs.gametype == GT_CTF_ELIMINATION ) {
+		y = CG_DrawCTFoneway(y);
+	}
+	
 	if ( cg_drawSnapshot.integer ) {
 		y = CG_DrawSnapshot( y );
 	}
 	if ( cg_drawFPS.integer ) {
 		y = CG_DrawFPS( y );
 	}
-	if ( cg_drawTimer.integer ) {
+	if (cgs.gametype==GT_ELIMINATION || cgs.gametype == GT_CTF_ELIMINATION || cgs.gametype==GT_LMS) {
+		y = CG_DrawEliminationTimer( y );
+		if (cgs.clientinfo[ cg.clientNum ].isDead)
+			y = CG_DrawEliminationDeathMessage( y);
+	}
+
+	y = CG_DrawFollowMessage( y );
+
+	if ( cg_drawTimer.integer) {
 		y = CG_DrawTimer( y );
 	}
 	if ( cg_drawAttacker.integer ) {
@@ -1032,7 +1370,7 @@
 	y1 = y;
 
 	// draw from the right side to left
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		x = 640;
 		color[0] = 0.0f;
 		color[1] = 0.0f;
@@ -1047,7 +1385,7 @@
 		}
 		CG_DrawBigString( x + 4, y, s, 1.0F);
 
-		if ( cgs.gametype == GT_CTF ) {
+		if ( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION) {
 			// Display flag status
 			item = BG_FindItemForPowerup( PW_BLUEFLAG );
 
@@ -1071,7 +1409,7 @@
 		}
 		CG_DrawBigString( x + 4, y, s, 1.0F);
 
-		if ( cgs.gametype == GT_CTF ) {
+		if ( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION ) {
 			// Display flag status
 			item = BG_FindItemForPowerup( PW_REDFLAG );
 
@@ -1083,7 +1421,20 @@
 			}
 		}
 
-		if ( cgs.gametype >= GT_CTF ) {
+#ifdef MISSIONPACK
+		if ( cgs.gametype == GT_1FCTF ) {
+			// Display flag status
+			item = BG_FindItemForPowerup( PW_NEUTRALFLAG );
+
+			if (item) {
+				y1 = y - BIGCHAR_HEIGHT - 8;
+				if( cgs.flagStatus >= 0 && cgs.flagStatus <= 3 ) {
+					CG_DrawPic( x, y1-4, w, BIGCHAR_HEIGHT+8, cgs.media.flagShader[cgs.flagStatus] );
+				}
+			}
+		}
+#endif
+		if ( cgs.gametype >= GT_CTF && cgs.ffa_gt==0) {
 			v = cgs.capturelimit;
 		} else {
 			v = cgs.fraglimit;
@@ -1275,7 +1626,7 @@
 
 	y = 480 - ICON_SIZE;
 
-	if ( cgs.gametype >= GT_TEAM && cg_drawTeamOverlay.integer == 2 ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1 && cg_drawTeamOverlay.integer == 2 ) {
 		y = CG_DrawTeamOverlay( y, qtrue, qfalse );
 	} 
 
@@ -1328,7 +1679,7 @@
 
 	y = 480 - ICON_SIZE;
 
-	if ( cgs.gametype >= GT_TEAM && cg_drawTeamOverlay.integer == 3 ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1 && cg_drawTeamOverlay.integer == 3 ) {
 		y = CG_DrawTeamOverlay( y, qfalse, qfalse );
 	} 
 
@@ -2008,7 +2359,7 @@
 	if ( cgs.gametype == GT_TOURNAMENT ) {
 		CG_DrawBigString(320 - 15 * 8, 460, "waiting to play", 1.0F);
 	}
-	else if ( cgs.gametype >= GT_TEAM ) {
+	else if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		CG_DrawBigString(320 - 39 * 8, 460, "press ESC and use the JOIN menu to play", 1.0F);
 	}
 }
@@ -2126,7 +2477,7 @@
 
 
 	if (menuScoreboard == NULL) {
-		if ( cgs.gametype >= GT_TEAM ) {
+		if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 			menuScoreboard = Menus_FindByName("teamscore_menu");
 		} else {
 			menuScoreboard = Menus_FindByName("score_menu");
@@ -2215,6 +2566,10 @@
 	const char	*s;
 	int			w;
 
+	//Don't rapport in instant gib
+	if(cgs.instantgib)
+		return;
+
 	if ( cg_drawAmmoWarning.integer == 0 ) {
 		return;
 	}
@@ -2338,6 +2693,14 @@
 			s = "Team Deathmatch";
 		} else if ( cgs.gametype == GT_CTF ) {
 			s = "Capture the Flag";
+		} else if ( cgs.gametype == GT_ELIMINATION ) {
+			s = "Elimination";
+		} else if ( cgs.gametype == GT_CTF_ELIMINATION ) {
+			s = "CTF Elimination";
+		} else if ( cgs.gametype == GT_LMS ) {
+			s = "Last Man Standing";
+		} else if ( cgs.gametype == GT_DOUBLE_D ) {
+			s = "Double Domination";
 #ifdef MISSIONPACK
 		} else if ( cgs.gametype == GT_1FCTF ) {
 			s = "One Flag CTF";
@@ -2464,7 +2827,7 @@
 		return;
 	}
 */
-	if ( cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR ) {
+	if ( cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR /*|| cg.snap->ps.pm_type == PM_SPECTATOR*/ ) {
 		CG_DrawSpectator();
 		CG_DrawCrosshair();
 		CG_DrawCrosshairNames();
@@ -2498,7 +2861,7 @@
 			CG_DrawReward();
 		}
     
-		if ( cgs.gametype >= GT_TEAM ) {
+		if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 #ifndef MISSIONPACK
 			CG_DrawTeamInfo();
 #endif
Index: code/cgame/cg_newdraw.c
===================================================================
--- code/cgame/cg_newdraw.c	(revision 1145)
+++ code/cgame/cg_newdraw.c	(working copy)
@@ -56,7 +56,7 @@
 }
 
 void CG_CheckOrderPending(void) {
-	if (cgs.gametype < GT_CTF) {
+	if (cgs.gametype < GT_CTF || cgs.ffa_gt>0) {
 		return;
 	}
 	if (cgs.orderPending) {
@@ -651,7 +651,7 @@
 }
 
 static void CG_DrawBlueFlagStatus(rectDef_t *rect, qhandle_t shader) {
-	if (cgs.gametype != GT_CTF && cgs.gametype != GT_1FCTF) {
+	if (cgs.gametype != GT_CTF && cgs.gametype != GT_CTF_ELIMINATION && cgs.gametype != GT_1FCTF) {
 		if (cgs.gametype == GT_HARVESTER) {
 		  vec4_t color = {0, 0, 1, 1};
 		  trap_R_SetColor(color);
@@ -701,7 +701,7 @@
 }
 
 static void CG_DrawRedFlagStatus(rectDef_t *rect, qhandle_t shader) {
-	if (cgs.gametype != GT_CTF && cgs.gametype != GT_1FCTF) {
+	if (cgs.gametype != GT_CTF && cgs.gametype != GT_CTF_ELIMINATION && cgs.gametype != GT_1FCTF) {
 		if (cgs.gametype == GT_HARVESTER) {
 		  vec4_t color = {1, 0, 0, 1};
 		  trap_R_SetColor(color);
@@ -811,7 +811,7 @@
 static void CG_DrawCTFPowerUp(rectDef_t *rect) {
 	int		value;
 
-	if (cgs.gametype < GT_CTF) {
+	if (cgs.gametype < GT_CTF || cgs.ffa_gt>0) {
 		return;
 	}
 	value = cg.snap->ps.stats[STAT_PERSISTANT_POWERUP];
@@ -953,7 +953,7 @@
 }
 
 qboolean CG_OtherTeamHasFlag(void) {
-	if (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF) {
+	if (cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION || cgs.gametype == GT_1FCTF) {
 		int team = cg.snap->ps.persistant[PERS_TEAM];
 		if (cgs.gametype == GT_1FCTF) {
 			if (team == TEAM_RED && cgs.flagStatus == FLAG_TAKEN_BLUE) {
@@ -977,7 +977,7 @@
 }
 
 qboolean CG_YourTeamHasFlag(void) {
-	if (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF) {
+	if (cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION || cgs.gametype == GT_1FCTF) {
 		int team = cg.snap->ps.persistant[PERS_TEAM];
 		if (cgs.gametype == GT_1FCTF) {
 			if (team == TEAM_RED && cgs.flagStatus == FLAG_TAKEN_RED) {
@@ -1030,13 +1030,13 @@
 	}
 
 	if (flags & CG_SHOW_ANYTEAMGAME) {
-		if( cgs.gametype >= GT_TEAM) {
+		if( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 			return qtrue;
 		}
 	}
 
 	if (flags & CG_SHOW_ANYNONTEAMGAME) {
-		if( cgs.gametype < GT_TEAM) {
+		if( cgs.gametype < GT_TEAM || cgs.ffa_gt==1) {
 			return qtrue;
 		}
 	}
@@ -1058,7 +1058,7 @@
 	}
 
 	if (flags & CG_SHOW_CTF) {
-		if( cgs.gametype == GT_CTF ) {
+		if( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION) {
 			return qtrue;
 		}
 	}
@@ -1151,7 +1151,7 @@
 
 
 static void CG_DrawCapFragLimit(rectDef_t *rect, float scale, vec4_t color, qhandle_t shader, int textStyle) {
-	int limit = (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
+	int limit = (cgs.gametype >= GT_CTF && cgs.ffa_gt==0) ? cgs.capturelimit : cgs.fraglimit;
 	CG_Text_Paint(rect->x, rect->y, scale, color, va("%2i", limit),0, 0, textStyle); 
 }
 
@@ -1169,7 +1169,7 @@
 
 const char *CG_GetGameStatusText(void) {
 	const char *s = "";
-	if ( cgs.gametype < GT_TEAM) {
+	if ( cgs.gametype < GT_TEAM || cgs.ffa_gt==1) {
 		if (cg.snap->ps.persistant[PERS_TEAM] != TEAM_SPECTATOR ) {
 			s = va("%s place with %i",CG_PlaceString( cg.snap->ps.persistant[PERS_RANK] + 1 ),cg.snap->ps.persistant[PERS_SCORE] );
 		}
@@ -1202,6 +1202,14 @@
 		return "Overload";
 	} else if ( cgs.gametype == GT_HARVESTER ) {
 		return "Harvester";
+	} else if ( cgs.gametype == GT_ELIMINATION ) {
+		return "Elimination";
+	} else if ( cgs.gametype == GT_CTF_ELIMINATION ) {
+		return "CTF Elimination";
+	} else if ( cgs.gametype == GT_LMS ) {
+		return "Last Man Standing";
+	} else if ( cgs.gametype == GT_DOUBLE_D ) {
+		return "Double Domination";
 	}
 	return "";
 }
Index: code/cgame/cg_consolecmds.c
===================================================================
--- code/cgame/cg_consolecmds.c	(revision 1145)
+++ code/cgame/cg_consolecmds.c	(working copy)
@@ -299,7 +299,7 @@
 }
 
 static void CG_TaskOffense_f (void ) {
-	if (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF) {
+	if (cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION || cgs.gametype == GT_1FCTF) {
 		trap_SendConsoleCommand(va("cmd vsay_team %s\n", VOICECHAT_ONGETFLAG));
 	} else {
 		trap_SendConsoleCommand(va("cmd vsay_team %s\n", VOICECHAT_ONOFFENSE));
Index: code/cgame/cg_view.c
===================================================================
--- code/cgame/cg_view.c	(revision 1145)
+++ code/cgame/cg_view.c	(working copy)
@@ -234,7 +234,8 @@
 	VectorCopy( cg.refdefViewAngles, focusAngles );
 
 	// if dead, look at killer
-	if ( cg.predictedPlayerState.stats[STAT_HEALTH] <= 0 ) {
+	if ( (cg.predictedPlayerState.stats[STAT_HEALTH] <= 0) && 
+				(cgs.gametype !=GT_ELIMINATION && cgs.gametype !=GT_CTF_ELIMINATION && cgs.gametype !=GT_LMS) ) {
 		focusAngles[YAW] = cg.predictedPlayerState.stats[STAT_DEAD_YAW];
 		cg.refdefViewAngles[YAW] = cg.predictedPlayerState.stats[STAT_DEAD_YAW];
 	}
Index: code/cgame/cg_servercmds.c
===================================================================
--- code/cgame/cg_servercmds.c	(revision 1145)
+++ code/cgame/cg_servercmds.c	(working copy)
@@ -75,29 +75,45 @@
 	cg.teamScores[0] = atoi( CG_Argv( 2 ) );
 	cg.teamScores[1] = atoi( CG_Argv( 3 ) );
 
+	cgs.roundStartTime = atoi( CG_Argv( 4 ) );
+
+	//Update thing in lower-right corner
+	if(cgs.gametype == GT_ELIMINATION || cgs.gametype == GT_CTF_ELIMINATION)
+	{
+		cgs.scores1 = cg.teamScores[0];
+		cgs.scores2 = cg.teamScores[1];
+	}
+
 	memset( cg.scores, 0, sizeof( cg.scores ) );
+
+#define NUM_DATA 15
+#define FIRST_DATA 4
+
 	for ( i = 0 ; i < cg.numScores ; i++ ) {
 		//
-		cg.scores[i].client = atoi( CG_Argv( i * 14 + 4 ) );
-		cg.scores[i].score = atoi( CG_Argv( i * 14 + 5 ) );
-		cg.scores[i].ping = atoi( CG_Argv( i * 14 + 6 ) );
-		cg.scores[i].time = atoi( CG_Argv( i * 14 + 7 ) );
-		cg.scores[i].scoreFlags = atoi( CG_Argv( i * 14 + 8 ) );
-		powerups = atoi( CG_Argv( i * 14 + 9 ) );
-		cg.scores[i].accuracy = atoi(CG_Argv(i * 14 + 10));
-		cg.scores[i].impressiveCount = atoi(CG_Argv(i * 14 + 11));
-		cg.scores[i].excellentCount = atoi(CG_Argv(i * 14 + 12));
-		cg.scores[i].guantletCount = atoi(CG_Argv(i * 14 + 13));
-		cg.scores[i].defendCount = atoi(CG_Argv(i * 14 + 14));
-		cg.scores[i].assistCount = atoi(CG_Argv(i * 14 + 15));
-		cg.scores[i].perfect = atoi(CG_Argv(i * 14 + 16));
-		cg.scores[i].captures = atoi(CG_Argv(i * 14 + 17));
+		cg.scores[i].client = atoi( CG_Argv( i * NUM_DATA + FIRST_DATA + 1 ) );
+		cg.scores[i].score = atoi( CG_Argv( i * NUM_DATA + FIRST_DATA + 2 ) );
+		cg.scores[i].ping = atoi( CG_Argv( i * NUM_DATA + FIRST_DATA + 3 ) );
+		cg.scores[i].time = atoi( CG_Argv( i * NUM_DATA + FIRST_DATA + 4 ) );
+		cg.scores[i].scoreFlags = atoi( CG_Argv( i * NUM_DATA + FIRST_DATA + 5 ) );
+		powerups = atoi( CG_Argv( i * NUM_DATA + FIRST_DATA + 6 ) );
+		cg.scores[i].accuracy = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 7));
+		cg.scores[i].impressiveCount = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 8));
+		cg.scores[i].excellentCount = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 9));
+		cg.scores[i].guantletCount = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 10));
+		cg.scores[i].defendCount = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 11));
+		cg.scores[i].assistCount = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 12));
+		cg.scores[i].perfect = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 13));
+		cg.scores[i].captures = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 14));
+		cg.scores[i].isDead = atoi(CG_Argv(i * NUM_DATA + FIRST_DATA + 15));
+		//cgs.roundStartTime = 
 
 		if ( cg.scores[i].client < 0 || cg.scores[i].client >= MAX_CLIENTS ) {
 			cg.scores[i].client = 0;
 		}
 		cgs.clientinfo[ cg.scores[i].client ].score = cg.scores[i].score;
 		cgs.clientinfo[ cg.scores[i].client ].powerups = powerups;
+		cgs.clientinfo[ cg.scores[i].client ].isDead = cg.scores[i].isDead;
 
 		cg.scores[i].team = cgs.clientinfo[cg.scores[i].client].team;
 	}
@@ -109,6 +125,48 @@
 
 /*
 =================
+CG_ParseElimination
+
+=================
+*/
+static void CG_ParseElimination( void ) {
+	if(cgs.gametype == GT_ELIMINATION || cgs.gametype == GT_CTF_ELIMINATION)
+	{
+		cgs.scores1 = atoi( CG_Argv( 1 ) );
+		cgs.scores2 = atoi( CG_Argv( 2 ) );
+	}
+	cgs.roundStartTime = atoi( CG_Argv( 3 ) );
+}
+
+/*
+=================
+CG_ParseDDtimetaken
+
+=================
+*/
+static void CG_ParseDDtimetaken( void ) {
+	cgs.timetaken = atoi( CG_Argv( 1 ) );
+}
+
+/*
+=================
+CG_ParseAttackingTeam
+
+=================
+*/
+static void CG_ParseAttackingTeam( void ) {
+	int temp;
+	temp = atoi( CG_Argv( 1 ) );
+	if(temp==TEAM_RED)
+		cgs.attackingTeam = TEAM_RED;
+	else if (temp==TEAM_BLUE)
+		cgs.attackingTeam = TEAM_BLUE;
+	else
+		cgs.attackingTeam = TEAM_NONE; //Should never happen.
+}
+
+/*
+=================
 CG_ParseTeamInfo
 
 =================
@@ -147,6 +205,11 @@
 
 	info = CG_ConfigString( CS_SERVERINFO );
 	cgs.gametype = atoi( Info_ValueForKey( info, "g_gametype" ) );
+	//By default do as normal:
+	cgs.ffa_gt = 0;
+	//See if ffa gametype
+	if(cgs.gametype == GT_LMS)	
+		cgs.ffa_gt = 1;
 	trap_Cvar_Set("g_gametype", va("%i", cgs.gametype));
 	cgs.dmflags = atoi( Info_ValueForKey( info, "dmflags" ) );
 	cgs.teamflags = atoi( Info_ValueForKey( info, "teamflags" ) );
@@ -154,6 +217,10 @@
 	cgs.capturelimit = atoi( Info_ValueForKey( info, "capturelimit" ) );
 	cgs.timelimit = atoi( Info_ValueForKey( info, "timelimit" ) );
 	cgs.maxclients = atoi( Info_ValueForKey( info, "sv_maxclients" ) );
+	cgs.roundtime = atoi( Info_ValueForKey( info, "elimination_roundtime" ) );
+	cgs.instantgib = atoi( Info_ValueForKey( info, "g_instantgib" ) );
+	cgs.lms_mode = atoi( Info_ValueForKey( info, "g_lms_mode" ) );
+	cgs.oneway = atoi( Info_ValueForKey( info, "elimination_ctf_oneway" ) )? qtrue : qfalse;
 	mapname = Info_ValueForKey( info, "mapname" );
 	Com_sprintf( cgs.mapname, sizeof( cgs.mapname ), "maps/%s.bsp", mapname );
 	Q_strncpyz( cgs.redTeam, Info_ValueForKey( info, "g_redTeam" ), sizeof(cgs.redTeam) );
@@ -205,7 +272,7 @@
 	cgs.scores1 = atoi( CG_ConfigString( CS_SCORES1 ) );
 	cgs.scores2 = atoi( CG_ConfigString( CS_SCORES2 ) );
 	cgs.levelStartTime = atoi( CG_ConfigString( CS_LEVEL_START_TIME ) );
-	if( cgs.gametype == GT_CTF ) {
+	if( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION || cgs.gametype == GT_DOUBLE_D) {
 		s = CG_ConfigString( CS_FLAGSTATUS );
 		cgs.redflag = s[0] - '0';
 		cgs.blueflag = s[1] - '0';
@@ -331,7 +398,7 @@
 		CG_NewClientInfo( num - CS_PLAYERS );
 		CG_BuildSpectatorString();
 	} else if ( num == CS_FLAGSTATUS ) {
-		if( cgs.gametype == GT_CTF ) {
+		if( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION || cgs.gametype == GT_DOUBLE_D) {
 			// format is rb where its red/blue, 0 is at base, 1 is taken, 2 is dropped
 			cgs.redflag = str[0] - '0';
 			cgs.blueflag = str[1] - '0';
@@ -1048,6 +1115,21 @@
 		return;
 	}
 
+	if ( !strcmp( cmd, "ddtaken" ) ) {
+		CG_ParseDDtimetaken();
+		return;
+	}
+
+	if ( !strcmp( cmd, "elimination" ) ) {
+		CG_ParseElimination();
+		return;
+	}
+
+	if ( !strcmp( cmd, "attackingteam" ) ) {
+		CG_ParseAttackingTeam();
+		return;
+	}
+
 	if ( !strcmp( cmd, "tinfo" ) ) {
 		CG_ParseTeamInfo();
 		return;
Index: code/cgame/cg_scoreboard.c
===================================================================
--- code/cgame/cg_scoreboard.c	(revision 1145)
+++ code/cgame/cg_scoreboard.c	(working copy)
@@ -176,8 +176,12 @@
 		Com_sprintf(string, sizeof(string),
 			" SPECT %3i %4i %s", score->ping, score->time, ci->name);
 	} else {
-		Com_sprintf(string, sizeof(string),
-			"%5i %4i %4i %s", score->score, score->ping, score->time, ci->name);
+		if(ci->isDead)
+			Com_sprintf(string, sizeof(string),
+				"%5i %4i %4i %s *DEAD*", score->score, score->ping, score->time, ci->name);
+		else
+			Com_sprintf(string, sizeof(string),
+				"%5i %4i %4i %s", score->score, score->ping, score->time, ci->name);
 	}
 
 	// highlight your position
@@ -187,8 +191,10 @@
 
 		localClient = qtrue;
 
-		if ( cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR 
-			|| cgs.gametype >= GT_TEAM ) {
+		if ( ( cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR ) ||
+			( ( cgs.gametype >= GT_TEAM ) &&
+			( cgs.ffa_gt != 1 ) ) ) {
+			// Sago: I think this means that it doesn't matter if to players are tied in team game - only team score counts
 			rank = -1;
 		} else {
 			rank = cg.snap->ps.persistant[PERS_RANK] & ~RANK_TIED_FLAG;
@@ -315,7 +321,7 @@
 	}
 
 	// current rank
-	if ( cgs.gametype < GT_TEAM) {
+	if ( cgs.gametype < GT_TEAM || cgs.ffa_gt == 1) {
 		if (cg.snap->ps.persistant[PERS_TEAM] != TEAM_SPECTATOR ) {
 			s = va("%s place with %i",
 				CG_PlaceString( cg.snap->ps.persistant[PERS_RANK] + 1 ),
@@ -365,7 +371,7 @@
 
 	localClient = qfalse;
 
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		//
 		// teamplay scoreboard
 		//
@@ -496,7 +502,7 @@
 	// print the two scores
 
 	y = 160;
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		//
 		// teamplay scoreboard
 		//
Index: code/cgame/cg_main.c
===================================================================
--- code/cgame/cg_main.c	(revision 1145)
+++ code/cgame/cg_main.c	(working copy)
@@ -183,6 +183,7 @@
 vmCvar_t	cg_oldPlasma;
 vmCvar_t	cg_trueLightning;
 
+
 #ifdef MISSIONPACK
 vmCvar_t 	cg_redTeamName;
 vmCvar_t 	cg_blueTeamName;
@@ -296,6 +297,7 @@
 	{ &cg_obeliskRespawnDelay, "g_obeliskRespawnDelay", "10", CVAR_SERVERINFO},
 	{ &cg_hudFiles, "cg_hudFiles", "ui/hud.txt", CVAR_ARCHIVE},
 #endif
+
 	{ &cg_cameraOrbit, "cg_cameraOrbit", "0", CVAR_CHEAT},
 	{ &cg_cameraOrbitDelay, "cg_cameraOrbitDelay", "50", CVAR_ARCHIVE},
 	{ &cg_timescaleFadeEnd, "cg_timescaleFadeEnd", "1", 0},
@@ -556,7 +558,11 @@
 	cgs.media.countPrepareTeamSound = trap_S_RegisterSound( "sound/feedback/prepare_team.wav", qtrue );
 #endif
 
-	if ( cgs.gametype >= GT_TEAM || cg_buildScript.integer ) {
+	// N_G: Another condition that makes no sense to me, see for
+	// yourself if you really meant this
+	// Sago: Makes perfect sense: Load team game stuff if the gametype is a teamgame and not an exception (like GT_LMS)
+	if ( ( ( cgs.gametype >= GT_TEAM ) && ( cgs.ffa_gt != 1 ) ) ||
+		cg_buildScript.integer ) {
 
 		cgs.media.captureAwardSound = trap_S_RegisterSound( "sound/teamplay/flagcapture_yourteam.wav", qtrue );
 		cgs.media.redLeadsSound = trap_S_RegisterSound( "sound/feedback/redleads.wav", qtrue );
@@ -576,7 +582,7 @@
 		cgs.media.takenYourTeamSound = trap_S_RegisterSound( "sound/teamplay/flagtaken_yourteam.wav", qtrue );
 		cgs.media.takenOpponentSound = trap_S_RegisterSound( "sound/teamplay/flagtaken_opponent.wav", qtrue );
 
-		if ( cgs.gametype == GT_CTF || cg_buildScript.integer ) {
+		if ( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION|| cg_buildScript.integer ) {
 			cgs.media.redFlagReturnedSound = trap_S_RegisterSound( "sound/teamplay/voc_red_returned.wav", qtrue );
 			cgs.media.blueFlagReturnedSound = trap_S_RegisterSound( "sound/teamplay/voc_blue_returned.wav", qtrue );
 			cgs.media.enemyTookYourFlagSound = trap_S_RegisterSound( "sound/teamplay/voc_enemy_flag.wav", qtrue );
@@ -591,7 +597,7 @@
 			cgs.media.enemyTookTheFlagSound = trap_S_RegisterSound( "sound/teamplay/voc_enemy_1flag.wav", qtrue );
 		}
 
-		if ( cgs.gametype == GT_1FCTF || cgs.gametype == GT_CTF || cg_buildScript.integer ) {
+		if ( cgs.gametype == GT_1FCTF || cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION ||cg_buildScript.integer ) {
 			cgs.media.youHaveFlagSound = trap_S_RegisterSound( "sound/teamplay/voc_you_flag.wav", qtrue );
 			cgs.media.holyShitSound = trap_S_RegisterSound("sound/feedback/voc_holyshit.wav", qtrue);
 		}
@@ -759,31 +765,31 @@
 	cgs.media.hgrenb2aSound = trap_S_RegisterSound("sound/weapons/grenade/hgrenb2a.wav", qfalse);
 
 #ifdef MISSIONPACK
-	trap_S_RegisterSound("sound/player/james/death1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/death2.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/death3.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/jump1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/pain25_1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/pain75_1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/pain100_1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/falling1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/gasp.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/drown.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/fall1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/james/taunt.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/death1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/death2.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/death3.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/jump1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/pain25_1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/pain75_1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/pain100_1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/falling1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/gasp.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/drown.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/fall1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/sergei/taunt.wav", qfalse );
 
-	trap_S_RegisterSound("sound/player/janet/death1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/death2.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/death3.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/jump1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/pain25_1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/pain75_1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/pain100_1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/falling1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/gasp.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/drown.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/fall1.wav", qfalse );
-	trap_S_RegisterSound("sound/player/janet/taunt.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/death1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/death2.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/death3.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/jump1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/pain25_1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/pain75_1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/pain100_1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/falling1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/gasp.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/drown.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/fall1.wav", qfalse );
+	trap_S_RegisterSound("sound/player/kyonshi/taunt.wav", qfalse );
 #endif
 
 }
@@ -880,9 +886,9 @@
 	cgs.media.hastePuffShader = trap_R_RegisterShader("hasteSmokePuff" );
 
 #ifdef MISSIONPACK
-	if ( cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF || cgs.gametype == GT_HARVESTER || cg_buildScript.integer ) {
+	if ( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION|| cgs.gametype == GT_1FCTF || cgs.gametype == GT_HARVESTER || cg_buildScript.integer ) {
 #else
-	if ( cgs.gametype == GT_CTF || cg_buildScript.integer ) {
+	if ( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION|| cg_buildScript.integer ) {
 #endif
 		cgs.media.redCubeModel = trap_R_RegisterModel( "models/powerups/orb/r_orb.md3" );
 		cgs.media.blueCubeModel = trap_R_RegisterModel( "models/powerups/orb/b_orb.md3" );
@@ -890,10 +896,19 @@
 		cgs.media.blueCubeIcon = trap_R_RegisterShader( "icons/skull_blue" );
 	}
 
+//For Double Domination:
+/*	if ( cgs.gametype == GT_DOUBLE_D ) {
+		cgs.media.ddPointA = trap_R_RegisterModel( "models/flag2/flagflap3.md3" );
+		cgs.media.ddPointB = trap_R_RegisterModel( "models/flag2/flagflap3.md3" );
+		cgs.media.ddPointSkin[1] = trap_R_RegisterSkin( "models/flag2/red.skin" );
+		cgs.media.ddPointSkin[2] = trap_R_RegisterSkin( "models/flag2/blue.skin" );
+		cgs.media.ddPointSkin[0] = trap_R_RegisterSkin( "models/flag2/white.skin" );
+	}
+*/
 #ifdef MISSIONPACK
-	if ( cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF || cgs.gametype == GT_HARVESTER || cg_buildScript.integer ) {
+	if ( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION || cgs.gametype == GT_1FCTF || cgs.gametype == GT_HARVESTER || cg_buildScript.integer ) {
 #else
-	if ( cgs.gametype == GT_CTF || cg_buildScript.integer ) {
+	if ( cgs.gametype == GT_CTF || cgs.gametype == GT_CTF_ELIMINATION || cg_buildScript.integer ) {
 #endif
 		cgs.media.redFlagModel = trap_R_RegisterModel( "models/flags/r_flag.md3" );
 		cgs.media.blueFlagModel = trap_R_RegisterModel( "models/flags/b_flag.md3" );
@@ -944,7 +959,9 @@
 	cgs.media.dustPuffShader = trap_R_RegisterShader("hasteSmokePuff" );
 #endif
 
-	if ( cgs.gametype >= GT_TEAM || cg_buildScript.integer ) {
+	if ( ( ( cgs.gametype >= GT_TEAM ) && ( cgs.ffa_gt != 1 ) ) ||
+		cg_buildScript.integer ) {
+
 		cgs.media.friendShader = trap_R_RegisterShader( "sprites/foe" );
 		cgs.media.redQuadShader = trap_R_RegisterShader("powerups/blueflag" );
 		cgs.media.teamStatusBar = trap_R_RegisterShader( "gfx/2d/colorbar.tga" );
@@ -1075,13 +1092,13 @@
 	cgs.media.flagShaders[1] = trap_R_RegisterShaderNoMip("ui/assets/statusbar/flag_capture.tga");
 	cgs.media.flagShaders[2] = trap_R_RegisterShaderNoMip("ui/assets/statusbar/flag_missing.tga");
 
-	trap_R_RegisterModel( "models/players/james/lower.md3" );
-	trap_R_RegisterModel( "models/players/james/upper.md3" );
-	trap_R_RegisterModel( "models/players/heads/james/james.md3" );
+	trap_R_RegisterModel( "models/players/sergei/lower.md3" );
+	trap_R_RegisterModel( "models/players/sergei/upper.md3" );
+	trap_R_RegisterModel( "models/players/sergei/head.md3" );
 
-	trap_R_RegisterModel( "models/players/janet/lower.md3" );
-	trap_R_RegisterModel( "models/players/janet/upper.md3" );
-	trap_R_RegisterModel( "models/players/heads/janet/janet.md3" );
+	trap_R_RegisterModel( "models/players/kyonshi/lower.md3" );
+	trap_R_RegisterModel( "models/players/kyonshi/upper.md3" );
+	trap_R_RegisterModel( "models/players/kyonshi/head.md3" );
 
 #endif
 	CG_ClearParticles ();
@@ -1551,7 +1568,7 @@
 		return;
 	}
 
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		int feeder = FEEDER_REDTEAM_LIST;
 		i = red;
 		if (cg.scores[cg.selectedScore].team == TEAM_BLUE) {
@@ -1567,7 +1584,7 @@
 // FIXME: might need to cache this info
 static clientInfo_t * CG_InfoFromScoreIndex(int index, int team, int *scoreIndex) {
 	int i, count;
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		count = 0;
 		for (i = 0; i < cg.numScores; i++) {
 			if (cg.scores[i].team == team) {
@@ -1672,7 +1689,7 @@
 }
 
 static void CG_FeederSelection(float feederID, int index) {
-	if ( cgs.gametype >= GT_TEAM ) {
+	if ( cgs.gametype >= GT_TEAM && cgs.ffa_gt!=1) {
 		int i, count;
 		int team = (feederID == FEEDER_REDTEAM_LIST) ? TEAM_RED : TEAM_BLUE;
 		count = 0;
Index: code/ui/ui_main.c
===================================================================
--- code/ui/ui_main.c	(revision 1145)
+++ code/ui/ui_main.c	(working copy)
@@ -64,7 +64,7 @@
 
 static const serverFilter_t serverFilters[] = {
 	{"All", "" },
-	{"Quake 3 Arena", "" },
+	{"OpenArena", "" },
 	{"Team Arena", "missionpack" },
 	{"Rocket Arena", "arena" },
 	{"Alliance", "alliance20" },
@@ -81,7 +81,11 @@
 	"1FCTF",
 	"OVERLOAD",
 	"HARVESTER",
-	"TEAMTOURNAMENT"
+	"TEAMTOURNAMENT",
+	"ELIMINATION",
+	"CTFELIMINATION",
+	"LMS",
+	"DD"
 };
 
 static int const numTeamArenaGameTypes = sizeof(teamArenaGameTypes) / sizeof(const char*);
@@ -97,6 +101,10 @@
 	"Overload",
 	"Harvester",
 	"Team Tournament",
+	"Elimination",
+	"CTF Elimination",
+	"Last Man Standing",
+	"Double Domination"
 };
 
 static int const numTeamArenaGameNames = sizeof(teamArenaGameNames) / sizeof(const char*);
@@ -116,11 +124,12 @@
 static char* netnames[] = {
 	"???",
 	"UDP",
+	"IPX",
 	NULL
 };
 
 #ifndef MISSIONPACK // bk001206
-static char quake3worldMessage[] = "Visit www.quake3world.com - News, Community, Events, Files";
+static char quake3worldMessage[] = "Visit www.openarena.ws - News, Community, Events, Files";
 #endif
 
 static int gamecodetoui[] = {4,2,3,0,5,1,6};
@@ -1426,7 +1435,7 @@
 			return uiInfo.aliasList[j].ai;
 		}
 	}
-	return "James";
+	return "sergei";
 }
 
 #ifndef MISSIONPACK // bk001206
@@ -1470,7 +1479,7 @@
 			return uiInfo.characterList[i].base;
 		}
 	}
-	return "James";
+	return "sergei";
 }
 #endif
 
@@ -1748,7 +1757,7 @@
 	int value = uiInfo.botIndex;
 	int game = trap_Cvar_VariableValue("g_gametype");
 	const char *text = "";
-	if (game >= GT_TEAM) {
+	if (game >= GT_TEAM && !GT_LMS ) {
 		if (value >= uiInfo.characterCount) {
 			value = 0;
 		}
@@ -2149,14 +2158,14 @@
 	while (flags) {
 
 		if (flags & UI_SHOW_FFA) {
-			if (trap_Cvar_VariableValue("g_gametype") != GT_FFA) {
+			if (trap_Cvar_VariableValue("g_gametype") != GT_FFA || trap_Cvar_VariableValue("g_gametype") != GT_LMS ) {
 				vis = qfalse;
 			}
 			flags &= ~UI_SHOW_FFA;
 		}
 
 		if (flags & UI_SHOW_NOTFFA) {
-			if (trap_Cvar_VariableValue("g_gametype") == GT_FFA) {
+			if (trap_Cvar_VariableValue("g_gametype") == GT_FFA || trap_Cvar_VariableValue("g_gametype") == GT_LMS ) {
 				vis = qfalse;
 			}
 			flags &= ~UI_SHOW_NOTFFA;
@@ -2200,25 +2209,25 @@
 			flags &= ~UI_SHOW_NOTFAVORITESERVERS;
 		} 
 		if (flags & UI_SHOW_ANYTEAMGAME) {
-			if (uiInfo.gameTypes[ui_gameType.integer].gtEnum <= GT_TEAM ) {
+			if (uiInfo.gameTypes[ui_gameType.integer].gtEnum <= GT_TEAM && uiInfo.gameTypes[ui_gameType.integer].gtEnum != GT_LMS ) {
 				vis = qfalse;
 			}
 			flags &= ~UI_SHOW_ANYTEAMGAME;
 		} 
 		if (flags & UI_SHOW_ANYNONTEAMGAME) {
-			if (uiInfo.gameTypes[ui_gameType.integer].gtEnum > GT_TEAM ) {
+			if (uiInfo.gameTypes[ui_gameType.integer].gtEnum > GT_TEAM || uiInfo.gameTypes[ui_gameType.integer].gtEnum == GT_LMS ) {
 				vis = qfalse;
 			}
 			flags &= ~UI_SHOW_ANYNONTEAMGAME;
 		} 
 		if (flags & UI_SHOW_NETANYTEAMGAME) {
-			if (uiInfo.gameTypes[ui_netGameType.integer].gtEnum <= GT_TEAM ) {
+			if (uiInfo.gameTypes[ui_netGameType.integer].gtEnum <= GT_TEAM && uiInfo.gameTypes[ui_gameType.integer].gtEnum != GT_LMS ) {
 				vis = qfalse;
 			}
 			flags &= ~UI_SHOW_NETANYTEAMGAME;
 		} 
 		if (flags & UI_SHOW_NETANYNONTEAMGAME) {
-			if (uiInfo.gameTypes[ui_netGameType.integer].gtEnum > GT_TEAM ) {
+			if (uiInfo.gameTypes[ui_netGameType.integer].gtEnum > GT_TEAM || uiInfo.gameTypes[ui_gameType.integer].gtEnum == GT_LMS ) {
 				vis = qfalse;
 			}
 			flags &= ~UI_SHOW_NETANYNONTEAMGAME;
@@ -2563,7 +2572,7 @@
 			value++;
 		}
 
-		if (game >= GT_TEAM) {
+		if (game >= GT_TEAM && !GT_LMS) {
 			if (value >= uiInfo.characterCount + 2) {
 				value = 0;
 			} else if (value < 0) {
@@ -3165,7 +3174,7 @@
 			trap_Cvar_Set("cg_cameraOrbit", "0");
 			trap_Cvar_Set("ui_singlePlayerActive", "0");
 			trap_Cvar_SetValue( "dedicated", Com_Clamp( 0, 2, ui_dedicated.integer ) );
-			trap_Cvar_SetValue( "g_gametype", Com_Clamp( 0, 8, uiInfo.gameTypes[ui_netGameType.integer].gtEnum ) );
+			trap_Cvar_SetValue( "g_gametype", Com_Clamp( 0, 13, uiInfo.gameTypes[ui_netGameType.integer].gtEnum ) );
 			trap_Cvar_Set("g_redTeam", UI_Cvar_VariableString("ui_teamName"));
 			trap_Cvar_Set("g_blueTeam", UI_Cvar_VariableString("ui_opponentName"));
 			trap_Cmd_ExecuteText( EXEC_APPEND, va( "wait ; wait ; map %s\n", uiInfo.mapList[ui_currentNetMap.integer].mapLoadName ) );
@@ -3402,7 +3411,7 @@
 				trap_Cmd_ExecuteText( EXEC_APPEND, va("callteamvote leader %s\n",uiInfo.teamNames[uiInfo.teamIndex]) );
 			}
 		} else if (Q_stricmp(name, "addBot") == 0) {
-			if (trap_Cvar_VariableValue("g_gametype") >= GT_TEAM) {
+			if (trap_Cvar_VariableValue("g_gametype") >= GT_TEAM && !GT_LMS ) {
 				trap_Cmd_ExecuteText( EXEC_APPEND, va("addbot %s %i %s\n", uiInfo.characterList[uiInfo.botIndex].name, uiInfo.skillIndex+1, (uiInfo.redBlue == 0) ? "Red" : "Blue") );
 			} else {
 				trap_Cmd_ExecuteText( EXEC_APPEND, va("addbot %s %i %s\n", UI_GetBotNameByNumber(uiInfo.botIndex), uiInfo.skillIndex+1, (uiInfo.redBlue == 0) ? "Red" : "Blue") );
@@ -4591,9 +4600,9 @@
 			uiInfo.characterList[uiInfo.characterCount].imageName = String_Alloc(va("models/players/heads/%s/icon_default.tga", uiInfo.characterList[uiInfo.characterCount].name));
 
 	  if (tempStr && (!Q_stricmp(tempStr, "female"))) {
-        uiInfo.characterList[uiInfo.characterCount].base = String_Alloc(va("Janet"));
+        uiInfo.characterList[uiInfo.characterCount].base = String_Alloc(va("kyonshi"));
       } else if (tempStr && (!Q_stricmp(tempStr, "male"))) {
-        uiInfo.characterList[uiInfo.characterCount].base = String_Alloc(va("James"));
+        uiInfo.characterList[uiInfo.characterCount].base = String_Alloc(va("sergei"));
 	  } else {
         uiInfo.characterList[uiInfo.characterCount].base = String_Alloc(va("%s",tempStr));
 	  }
@@ -5247,7 +5256,7 @@
 
 		  return;
 	  case UIMENU_MAIN:
-			trap_Cvar_Set( "sv_killserver", "1" );
+			//trap_Cvar_Set( "sv_killserver", "1" );
 			trap_Key_SetCatcher( KEYCATCH_UI );
 			//trap_S_StartLocalSound( trap_S_RegisterSound("sound/misc/menu_background.wav", qfalse) , CHAN_LOCAL_SOUND );
 			//trap_S_StartBackgroundTrack("sound/misc/menu_background.wav", NULL);
@@ -5282,7 +5291,7 @@
 		  //UI_ConfirmMenu( "Bad CD Key", NULL, NeedCDKeyAction );
 		  return;
 	  case UIMENU_POSTGAME:
-			trap_Cvar_Set( "sv_killserver", "1" );
+			//trap_Cvar_Set( "sv_killserver", "1" );
 			trap_Key_SetCatcher( KEYCATCH_UI );
 			if (uiInfo.inGameLoad) {
 				UI_LoadNonIngame();
Index: code/ui/ui_gameinfo.c
===================================================================
--- code/ui/ui_gameinfo.c	(revision 1145)
+++ code/ui/ui_gameinfo.c	(working copy)
@@ -198,6 +198,18 @@
 			if( strstr( type, "harvester" ) ) {
 				uiInfo.mapList[uiInfo.mapCount].typeBits |= (1 << GT_HARVESTER);
 			}
+			if( strstr( type, "elimination" ) ) {
+				uiInfo.mapList[uiInfo.mapCount].typeBits |= (1 << GT_ELIMINATION);
+			}
+			if( strstr( type, "ctfelimination" ) ) {
+				uiInfo.mapList[uiInfo.mapCount].typeBits |= (1 << GT_CTF_ELIMINATION);
+			}
+			if( strstr( type, "lms" ) ) {
+				uiInfo.mapList[uiInfo.mapCount].typeBits |= (1 << GT_LMS);
+			}
+			if( strstr( type, "dd" ) ) {
+				uiInfo.mapList[uiInfo.mapCount].typeBits |= (1 << GT_DOUBLE_D);
+			}
 		} else {
 			uiInfo.mapList[uiInfo.mapCount].typeBits |= (1 << GT_FFA);
 		}
Index: code/ui/ui_players.c
===================================================================
--- code/ui/ui_players.c	(revision 1145)
+++ code/ui/ui_players.c	(working copy)
@@ -1204,7 +1204,7 @@
 		}
 	}
 
-	if (headModelName[0] == '*' ) {
+	if (headModelName && headModelName[0] == '*' ) {
 		Com_sprintf( filename, sizeof( filename ), "models/players/heads/%s/%s.md3", &headModelName[1], &headModelName[1] );
 	}
 	else {
Index: code/client/cl_main.c
===================================================================
--- code/client/cl_main.c	(revision 1145)
+++ code/client/cl_main.c	(working copy)
@@ -2656,8 +2656,8 @@
 	Cvar_Get ("snaps", "20", CVAR_USERINFO | CVAR_ARCHIVE );
 	Cvar_Get ("model", "sarge", CVAR_USERINFO | CVAR_ARCHIVE );
 	Cvar_Get ("headmodel", "sarge", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("team_model", "james", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("team_headmodel", "*james", CVAR_USERINFO | CVAR_ARCHIVE );
+	Cvar_Get ("team_model", "sergei", CVAR_USERINFO | CVAR_ARCHIVE );
+	Cvar_Get ("team_headmodel", "*sergei", CVAR_USERINFO | CVAR_ARCHIVE );
 	Cvar_Get ("g_redTeam", "Stroggs", CVAR_SERVERINFO | CVAR_ARCHIVE);
 	Cvar_Get ("g_blueTeam", "Pagans", CVAR_SERVERINFO | CVAR_ARCHIVE);
 	Cvar_Get ("color1",  "4", CVAR_USERINFO | CVAR_ARCHIVE );
@@ -3573,7 +3573,7 @@
 =================
 */
 qboolean CL_CDKeyValidate( const char *key, const char *checksum ) {
-	char	ch;
+/*	char	ch;
 	byte	sum;
 	char	chs[3];
 	int i, len;
@@ -3627,8 +3627,8 @@
 	if (!checksum) {
 		return qtrue;
 	}
-
-	return qfalse;
+*/
+	return qtrue;
 }
 
 
Index: code/client/snd_dma.c
===================================================================
--- code/client/snd_dma.c	(revision 1145)
+++ code/client/snd_dma.c	(working copy)
@@ -364,7 +364,7 @@
 		Com_Memset( s_knownSfx, 0, sizeof( s_knownSfx ) );
 		Com_Memset(sfxHash, 0, sizeof(sfx_t *)*LOOP_HASH);
 
-		S_Base_RegisterSound("sound/feedback/hit.wav", qfalse);		// changed to a sound in baseq3
+		S_Base_RegisterSound("sound/misc/silence.wav", qfalse);		// changed to a less annoying sound in baseoa
 	}
 }
 
Index: code/client/snd_openal.c
===================================================================
--- code/client/snd_openal.c	(revision 1145)
+++ code/client/snd_openal.c	(working copy)
@@ -384,7 +384,7 @@
 	numSfx = 0;
 
 	// Load the default sound, and lock it
-	default_sfx = S_AL_BufferFind("sound/feedback/hit.wav");
+	default_sfx = S_AL_BufferFind("sound/misc/silence.wav");
 	S_AL_BufferUse(default_sfx);
 	knownSfx[default_sfx].isLocked = qtrue;
 
